## Classes

<dl>
<dt><a href="#Builder">Builder</a></dt>
<dd><p>Builds metadata from a template using market specific customisation</p>
</dd>
<dt><a href="#Deployer">Deployer</a></dt>
<dd><p>Reads metadata from local directory and deploys it to specified target business unit.
Source and target business units are also compared before the deployment to apply metadata specific patches.</p>
</dd>
<dt><a href="#Mcdev">Mcdev</a></dt>
<dd><p>main class</p>
</dd>
<dt><a href="#Asset">Asset</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>FileTransfer MetadataType</p>
</dd>
<dt><a href="#AttributeGroup">AttributeGroup</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>AttributeGroup MetadataType</p>
</dd>
<dt><a href="#AttributeSet">AttributeSet</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>AttributeSet MetadataType</p>
</dd>
<dt><a href="#Automation">Automation</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Automation MetadataType</p>
</dd>
<dt><a href="#Campaign">Campaign</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Campaign MetadataType</p>
</dd>
<dt><a href="#ContentArea">ContentArea</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>ContentArea MetadataType</p>
</dd>
<dt><a href="#DataExtension">DataExtension</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>DataExtension MetadataType</p>
</dd>
<dt><a href="#DataExtensionField">DataExtensionField</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>DataExtensionField MetadataType</p>
</dd>
<dt><a href="#DataExtensionTemplate">DataExtensionTemplate</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>DataExtensionTemplate MetadataType</p>
</dd>
<dt><a href="#DataExtract">DataExtract</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>DataExtract MetadataType</p>
</dd>
<dt><a href="#DataExtractType">DataExtractType</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>DataExtractType MetadataType
Only for Caching No retrieve/upsert is required
as this is a configuration in the EID</p>
</dd>
<dt><a href="#Discovery">Discovery</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>ImportFile MetadataType</p>
</dd>
<dt><a href="#Email">Email</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Email MetadataType</p>
</dd>
<dt><a href="#EmailSend">EmailSend</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>MessageSendActivity MetadataType</p>
</dd>
<dt><a href="#Event">Event</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Event MetadataType</p>
</dd>
<dt><a href="#FtpLocation">FtpLocation</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>ImportFile MetadataType</p>
</dd>
<dt><a href="#FileTransfer">FileTransfer</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>FileTransfer MetadataType</p>
</dd>
<dt><a href="#Filter">Filter</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Filter MetadataType</p>
</dd>
<dt><a href="#Folder">Folder</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Folder MetadataType</p>
</dd>
<dt><a href="#ImportFile">ImportFile</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>ImportFile MetadataType</p>
</dd>
<dt><a href="#Journey">Journey</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Journey MetadataType
! BETA RELEASE of journey support (v4.3.0); it so far only resolves a limited amount of dependencies and will likely break during cross-BU deployments!
id: A unique id of the journey assigned by the journey’s API during its creation
key: A unique id of the journey within the MID. Can be generated by the developer
definitionId: A unique UUID provided by Salesforce Marketing Cloud. Each version of a journey has a unique DefinitionID while the Id and Key remain the same. Version 1 will have id == definitionId</p>
</dd>
<dt><a href="#List">List</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>List MetadataType</p>
</dd>
<dt><a href="#MetadataType">MetadataType</a></dt>
<dd><p>MetadataType class that gets extended by their specific metadata type class.
Provides default functionality that can be overwritten by child metadata type classes</p>
</dd>
<dt><a href="#MobileCode">MobileCode</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>MobileCode MetadataType</p>
</dd>
<dt><a href="#MobileKeyword">MobileKeyword</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>MobileKeyword MetadataType</p>
</dd>
<dt><a href="#MobileMessage">MobileMessage</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>MobileMessage MetadataType</p>
</dd>
<dt><a href="#Query">Query</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Query MetadataType</p>
</dd>
<dt><a href="#Role">Role</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>ImportFile MetadataType</p>
</dd>
<dt><a href="#Script">Script</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Script MetadataType</p>
</dd>
<dt><a href="#SendClassification">SendClassification</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>SendClassification MetadataType</p>
</dd>
<dt><a href="#TransactionalEmail">TransactionalEmail</a> ⇐ <code><a href="#TransactionalMessage">TransactionalMessage</a></code></dt>
<dd><p>TransactionalEmail MetadataType</p>
</dd>
<dt><a href="#TransactionalMessage">TransactionalMessage</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>TransactionalMessage MetadataType</p>
</dd>
<dt><a href="#TransactionalPush">TransactionalPush</a> ⇐ <code><a href="#TransactionalMessage">TransactionalMessage</a></code></dt>
<dd><p>TransactionalPush TransactionalMessage</p>
</dd>
<dt><a href="#TransactionalSMS">TransactionalSMS</a> ⇐ <code><a href="#TransactionalMessage">TransactionalMessage</a></code></dt>
<dd><p>TransactionalSMS MetadataType</p>
</dd>
<dt><a href="#TriggeredSend">TriggeredSend</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>MessageSendActivity MetadataType</p>
</dd>
<dt><a href="#User">User</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>MetadataType</p>
</dd>
<dt><a href="#Retriever">Retriever</a></dt>
<dd><p>Retrieves metadata from a business unit and saves it to the local filesystem.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#Util">Util</a></dt>
<dd><p>CLI entry for SFMC DevTools</p>
</dd>
<dt><a href="#MetadataTypeDefinitions">MetadataTypeDefinitions</a></dt>
<dd><p>Provides access to all metadataType classes</p>
</dd>
<dt><a href="#MetadataTypeInfo">MetadataTypeInfo</a></dt>
<dd><p>Provides access to all metadataType classes</p>
</dd>
<dt><a href="#mcdev">mcdev</a></dt>
<dd><p>sample file on how to retrieve a simple changelog to use in GUIs or automated processing of any kind</p>
</dd>
<dt><a href="#BusinessUnit">BusinessUnit</a></dt>
<dd><p>Helper that handles retrieval of BU info</p>
</dd>
<dt><a href="#dataStore">dataStore</a> : <code>TYPE.Cache</code></dt>
<dd></dd>
<dt><a href="#Cli">Cli</a></dt>
<dd><p>CLI helper class</p>
</dd>
<dt><a href="#config">config</a></dt>
<dd><p>Central class for loading and validating properties from config and auth</p>
</dd>
<dt><a href="#DevOps">DevOps</a></dt>
<dd><p>DevOps helper class</p>
</dd>
<dt><a href="#File">File</a></dt>
<dd><p>File extends fs-extra. It adds logger and util methods for file handling</p>
</dd>
<dt><a href="#Init">Init</a></dt>
<dd><p>CLI helper class</p>
</dd>
<dt><a href="#Init">Init</a></dt>
<dd><p>CLI helper class</p>
</dd>
<dt><a href="#Init">Init</a></dt>
<dd><p>CLI helper class</p>
</dd>
<dt><a href="#Init">Init</a></dt>
<dd><p>CLI helper class</p>
</dd>
<dt><a href="#Util">Util</a></dt>
<dd><p>Util that contains logger and simple util methods</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#csvToArray">csvToArray(csv)</a> ⇒ <code>Array.&lt;string&gt;</code></dt>
<dd><p>helper to convert CSVs into an array. if only one value was given, it&#39;s also returned as an array</p>
</dd>
<dt><a href="#Mcdev.">Mcdev.(methodName, businessUnit, [selectedType], [keys])</a> ⇒ <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code></dt>
<dd><p>run a method across BUs</p>
</dd>
<dt><a href="#Mcdev.">Mcdev.(methodName, cred, bu, [type], keyArr)</a> ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code></dt>
<dd><p>helper for <a href="Mcdev.#runMethod">Mcdev.#runMethod</a></p>
</dd>
<dt><a href="#Mcdev.">Mcdev.(selectedType, buObject)</a> ⇒ <code>Array.&lt;string&gt;</code></dt>
<dd><p>helper for <a href="Mcdev.#runOnBU">Mcdev.#runOnBU</a></p>
</dd>
<dt><a href="#Mcdev.">Mcdev.(cred, bu, type, [keyArr])</a> ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code></dt>
<dd><p>Updates the key to match the name field</p>
</dd>
<dt><a href="#Mcdev.">Mcdev.(type, [keyArr], buObject)</a> ⇒ <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code></dt>
<dd><p>Updates notification email address field</p>
</dd>
<dt><a href="#Automation.">Automation.(metadata)</a> ⇒ <code>boolean</code></dt>
<dd><p>helper for <a href="#Automation.postRetrieveTasks">postRetrieveTasks</a> and <a href="#Automation.execute">execute</a></p>
</dd>
<dt><a href="#Automation.">Automation.(metadataMap, key)</a> ⇒ <code>Promise.&lt;{key:string, response:object}&gt;</code></dt>
<dd><p>helper for <a href="#Automation.execute">execute</a></p>
</dd>
<dt><a href="#Automation.">Automation.(metadataEntry)</a> ⇒ <code>Promise.&lt;{key:string, response:object}&gt;</code></dt>
<dd><p>helper for <a href="#Automation.execute">execute</a></p>
</dd>
<dt><a href="#Automation.">Automation.(metadata)</a> ⇒ <code>Promise.&lt;{key:string, response:object}&gt;</code></dt>
<dd><p>helper for <a href="#Automation.pause">pause</a></p>
</dd>
<dt><a href="#Automation.">Automation.(metadata)</a></dt>
<dd><p>helper for <a href="#Automation.preDeployTasks">preDeployTasks</a> and <a href="#Automation.execute">execute</a></p>
</dd>
<dt><a href="#Automation.">Automation.(metadataMap, key)</a> ⇒ <code>Promise.&lt;void&gt;</code></dt>
<dd><p>helper for <a href="#Automation.postDeployTasks">postDeployTasks</a></p>
</dd>
<dt><a href="#Automation.">Automation.(key, programId, notificationBody)</a> ⇒ <code>string</code></dt>
<dd><p>helper function to send POST request to update notifications</p>
</dd>
<dt><a href="#Automation.">Automation.(metadataMap, originalMetadataMap, key, [oldKey])</a> ⇒ <code>Promise.&lt;{key:string, response:object}&gt;</code></dt>
<dd><p>helper for <a href="#Automation.postDeployTasks">postDeployTasks</a></p>
</dd>
<dt><a href="#Automation.">Automation.()</a> ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code></dt>
<dd><p>helper function to retrieve data about all automations in the BU</p>
</dd>
<dt><a href="#DataExtension.">DataExtension.(upsertedMetadata, originalMetadata, createdUpdated)</a> ⇒ <code>void</code></dt>
<dd><p>takes care of updating attribute groups on child BUs after an update to Shared DataExtensions
helper for <a href="#DataExtension.postDeployTasks">postDeployTasks</a>
fixes an issue where shared data extensions are not visible in data designer on child BU; SF known issue: <a href="https://issues.salesforce.com/#q=W-11031095">https://issues.salesforce.com/#q=W-11031095</a></p>
</dd>
<dt><a href="#DataExtension.">DataExtension.()</a> ⇒ <code>Array.&lt;string&gt;</code></dt>
<dd><p>helper for <a href="DataExtension.#fixShared">DataExtension.#fixShared</a></p>
</dd>
<dt><a href="#DataExtension.">DataExtension.(childBuName, buObjectParent, clientParent, sharedDataExtensionMap)</a> ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code></dt>
<dd><p>helper for <a href="DataExtension.#fixShared">DataExtension.#fixShared</a></p>
</dd>
<dt><a href="#DataExtension.">DataExtension.(deId, deKey, buObjectChildBu, clientChildBu, buObjectParent, clientParent)</a> ⇒ <code>Promise.&lt;boolean&gt;</code></dt>
<dd><p>method that actually takes care of triggering the update for a particular BU-sharedDe combo
helper for <a href="DataExtension.#fixShared_onBU">DataExtension.#fixShared_onBU</a></p>
</dd>
<dt><a href="#DataExtension.">DataExtension.(buObjectChildBu, clientChildBu, deKey, deId)</a> ⇒ <code>Promise.&lt;string&gt;</code></dt>
<dd><p>add a new field to the shared DE to trigger an update to the data model
helper for <a href="DataExtension.#fixShared_item">DataExtension.#fixShared_item</a></p>
</dd>
<dt><a href="#DataExtension.">DataExtension.(randomSuffix, buObjectParent, clientParent, deKey)</a> ⇒ <code>Promise.&lt;string&gt;</code></dt>
<dd><p>get ID of the field added by <a href="DataExtension.#fixShared_item_addField">DataExtension.#fixShared_item_addField</a> on the shared DE via parent BU
helper for <a href="DataExtension.#fixShared_item">DataExtension.#fixShared_item</a></p>
</dd>
<dt><a href="#DataExtension.">DataExtension.(randomSuffix, buObjectChildBu, clientChildBu, deKey, fieldObjectID)</a> ⇒ <code>Promise</code></dt>
<dd><p>delete the field added by <a href="DataExtension.#fixShared_item_addField">DataExtension.#fixShared_item_addField</a>
helper for <a href="DataExtension.#fixShared_item">DataExtension.#fixShared_item</a></p>
</dd>
<dt><a href="#getUserName">getUserName(userList, item, fieldname)</a> ⇒ <code>string</code></dt>
<dd></dd>
<dt><a href="#setupSDK">setupSDK(sessionKey, authObject)</a> ⇒ <code><a href="#SDK">SDK</a></code></dt>
<dd><p>Returns an SDK instance to be used for API calls</p>
</dd>
</dl>

## Typedefs

<dl>
<dt><a href="#TypeKeyCombo">TypeKeyCombo</a> : <code>Object.&lt;string, string&gt;</code></dt>
<dd><p>object-key=metadata type, value=array of external keys</p>
</dd>
<dt><a href="#MetadataTypeItemDiff">MetadataTypeItemDiff</a> : <code>Object.&lt;string, any&gt;</code></dt>
<dd><p>key=customer key</p>
</dd>
<dt><a href="#CodeExtractItem">CodeExtractItem</a> : <code>object</code></dt>
<dd></dd>
<dt><a href="#CodeExtract">CodeExtract</a> : <code>object</code></dt>
<dd></dd>
<dt><a href="#CodeExtractItem">CodeExtractItem</a> : <code>object</code></dt>
<dd></dd>
<dt><a href="#ScriptMap">ScriptMap</a> : <code>object</code></dt>
<dd></dd>
<dt><a href="#AssetSubType">AssetSubType</a> : <code>Object.&lt;string, any&gt;</code></dt>
<dd></dd>
<dt><a href="#DataExtensionFieldMap">DataExtensionFieldMap</a> : <code>object</code></dt>
<dd></dd>
<dt><a href="#DataExtensionMap">DataExtensionMap</a> : <code>object</code></dt>
<dd></dd>
<dt><a href="#UserDocumentMap">UserDocumentMap</a> : <code>object</code></dt>
<dd><p>key=customer key</p>
</dd>
<dt><a href="#BusinessUnitAssignmentConfiguration">BusinessUnitAssignmentConfiguration</a> : <code>object</code></dt>
<dd></dd>
<dt><a href="#AutomationActivity">AutomationActivity</a> : <code>object</code></dt>
<dd></dd>
<dt><a href="#AutomationStep">AutomationStep</a> : <code>object</code></dt>
<dd></dd>
<dt><a href="#AutomationSchedule">AutomationSchedule</a> : <code>object</code></dt>
<dd><p>REST format</p>
</dd>
<dt><a href="#AutomationScheduleSoap">AutomationScheduleSoap</a> : <code>object</code></dt>
<dd><p>SOAP format</p>
</dd>
<dt><a href="#AutomationItem">AutomationItem</a> : <code>object</code></dt>
<dd></dd>
<dt><a href="#SDK">SDK</a> : <code>Object.&lt;string, AutomationItem&gt;</code></dt>
<dd></dd>
<dt><a href="#skipInteraction">skipInteraction</a> : <code>object</code></dt>
<dd><p>signals what to insert automatically for things usually asked via wizard</p>
</dd>
<dt><a href="#AuthObject">AuthObject</a> : <code>object</code></dt>
<dd></dd>
<dt><a href="#SoapFilter">SoapFilter</a> : <code>object</code></dt>
<dd></dd>
<dt><a href="#Mcdevrc">Mcdevrc</a> : <code>object</code></dt>
<dd></dd>
<dt><a href="#Logger">Logger</a> : <code>object</code></dt>
<dd></dd>
</dl>

<a name="Builder"></a>

## Builder
Builds metadata from a template using market specific customisation

**Kind**: global class  

* [Builder](#Builder)
    * [new Builder(properties, buObject)](#new_Builder_new)
    * _instance_
        * [.metadata](#Builder+metadata) : <code>TYPE.MultiMetadataTypeList</code>
        * [._buildDefinition(metadataType, name, templateVariables)](#Builder+_buildDefinition) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code>
        * [._buildTemplate(metadataType, keyArr, templateVariables)](#Builder+_buildTemplate) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code>
    * _static_
        * [.buildTemplate(businessUnit, selectedType, keyArr, market)](#Builder.buildTemplate) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code>
        * [.buildDefinition(businessUnit, selectedType, name, market)](#Builder.buildDefinition) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code>
        * [.buildDefinitionBulk(listName, type, name)](#Builder.buildDefinitionBulk) ⇒ <code>Promise.&lt;Array.&lt;TYPE.MultiMetadataTypeList&gt;&gt;</code>

<a name="new_Builder_new"></a>

### new Builder(properties, buObject)
Creates a Builder, uses v2 auth if v2AuthOptions are passed.


| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | properties for auth saved |
| buObject | <code>TYPE.BuObject</code> | properties for auth |

<a name="Builder+metadata"></a>

### builder.metadata : <code>TYPE.MultiMetadataTypeList</code>
**Kind**: instance property of [<code>Builder</code>](#Builder)  
<a name="Builder+_buildDefinition"></a>

### builder.\_buildDefinition(metadataType, name, templateVariables) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code>
Builds a specific metadata file by name

**Kind**: instance method of [<code>Builder</code>](#Builder)  
**Returns**: <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataType | <code>string</code> | metadata type to build |
| name | <code>string</code> | name of metadata to build |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Builder+_buildTemplate"></a>

### builder.\_buildTemplate(metadataType, keyArr, templateVariables) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code>
Build a template based on a list of metadata files in the retrieve folder.

**Kind**: instance method of [<code>Builder</code>](#Builder)  
**Returns**: <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataType | <code>string</code> | metadata type to create a template of |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of metadata to create a template of |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Builder.buildTemplate"></a>

### Builder.buildTemplate(businessUnit, selectedType, keyArr, market) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code>
Build a template based on a list of metadata files in the retrieve folder.

**Kind**: static method of [<code>Builder</code>](#Builder)  
**Returns**: <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | references credentials from properties.json |
| selectedType | <code>string</code> | supported metadata type |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |
| market | <code>string</code> | market localizations |

<a name="Builder.buildDefinition"></a>

### Builder.buildDefinition(businessUnit, selectedType, name, market) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code>
Build a specific metadata file based on a template.

**Kind**: static method of [<code>Builder</code>](#Builder)  
**Returns**: <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | references credentials from properties.json |
| selectedType | <code>string</code> | supported metadata type |
| name | <code>string</code> | name of the metadata |
| market | <code>string</code> | market localizations |

<a name="Builder.buildDefinitionBulk"></a>

### Builder.buildDefinitionBulk(listName, type, name) ⇒ <code>Promise.&lt;Array.&lt;TYPE.MultiMetadataTypeList&gt;&gt;</code>
Build a specific metadata file based on a template using a list of bu-market combos

**Kind**: static method of [<code>Builder</code>](#Builder)  
**Returns**: <code>Promise.&lt;Array.&lt;TYPE.MultiMetadataTypeList&gt;&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| listName | <code>string</code> | name of list of BU-market combos |
| type | <code>string</code> | supported metadata type |
| name | <code>string</code> | name of the metadata |

<a name="Deployer"></a>

## Deployer
Reads metadata from local directory and deploys it to specified target business unit.
Source and target business units are also compared before the deployment to apply metadata specific patches.

**Kind**: global class  

* [Deployer](#Deployer)
    * [new Deployer(properties, buObject)](#new_Deployer_new)
    * _instance_
        * [.metadata](#Deployer+metadata) : <code>TYPE.MultiMetadataTypeMap</code>
        * [._deploy([typeArr], [keyArr])](#Deployer+_deploy) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeMap&gt;</code>
    * _static_
        * [.deploy(businessUnit, [selectedTypesArr], [keyArr])](#Deployer.deploy) ⇒ <code>Promise.&lt;Object.&lt;string, TYPE.MultiMetadataTypeMap&gt;&gt;</code>
        * [._deployBU(cred, bu, properties, [typeArr], [keyArr])](#Deployer._deployBU) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeMap&gt;</code>
        * [.readBUMetadata(deployDir, [typeArr], [listBadKeys])](#Deployer.readBUMetadata) ⇒ <code>TYPE.MultiMetadataTypeMap</code>
        * [.createFolderDefinitions(deployDir, metadata, metadataTypeArr)](#Deployer.createFolderDefinitions) ⇒ <code>void</code>

<a name="new_Deployer_new"></a>

### new Deployer(properties, buObject)
Creates a Deployer, uses v2 auth if v2AuthOptions are passed.


| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | General configuration to be used in retrieve |
| buObject | <code>TYPE.BuObject</code> | properties for auth |

<a name="Deployer+metadata"></a>

### deployer.metadata : <code>TYPE.MultiMetadataTypeMap</code>
**Kind**: instance property of [<code>Deployer</code>](#Deployer)  
<a name="Deployer+_deploy"></a>

### deployer.\_deploy([typeArr], [keyArr]) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeMap&gt;</code>
Deploy all metadata that is located in the deployDir

**Kind**: instance method of [<code>Deployer</code>](#Deployer)  
**Returns**: <code>Promise.&lt;TYPE.MultiMetadataTypeMap&gt;</code> - Promise of all deployed metadata  

| Param | Type | Description |
| --- | --- | --- |
| [typeArr] | <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code> | limit deployment to given metadata type (can include subtype) |
| [keyArr] | <code>Array.&lt;string&gt;</code> | limit deployment to given metadata keys |

<a name="Deployer.deploy"></a>

### Deployer.deploy(businessUnit, [selectedTypesArr], [keyArr]) ⇒ <code>Promise.&lt;Object.&lt;string, TYPE.MultiMetadataTypeMap&gt;&gt;</code>
Deploys all metadata located in the 'deploy' directory to the specified business unit

**Kind**: static method of [<code>Deployer</code>](#Deployer)  
**Returns**: <code>Promise.&lt;Object.&lt;string, TYPE.MultiMetadataTypeMap&gt;&gt;</code> - deployed metadata per BU (first key: bu name, second key: metadata type)  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | references credentials from properties.json |
| [selectedTypesArr] | <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code> | limit deployment to given metadata type |
| [keyArr] | <code>Array.&lt;string&gt;</code> | limit deployment to given metadata keys |

<a name="Deployer._deployBU"></a>

### Deployer.\_deployBU(cred, bu, properties, [typeArr], [keyArr]) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeMap&gt;</code>
helper for [deploy](#Deployer.deploy)

**Kind**: static method of [<code>Deployer</code>](#Deployer)  
**Returns**: <code>Promise.&lt;TYPE.MultiMetadataTypeMap&gt;</code> - ensure that BUs are worked on sequentially  

| Param | Type | Description |
| --- | --- | --- |
| cred | <code>string</code> | name of Credential |
| bu | <code>string</code> | name of BU |
| properties | <code>TYPE.Mcdevrc</code> | General configuration to be used in retrieve |
| [typeArr] | <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code> | limit deployment to given metadata type |
| [keyArr] | <code>Array.&lt;string&gt;</code> | limit deployment to given metadata keys |

<a name="Deployer.readBUMetadata"></a>

### Deployer.readBUMetadata(deployDir, [typeArr], [listBadKeys]) ⇒ <code>TYPE.MultiMetadataTypeMap</code>
Returns metadata of a business unit that is saved locally

**Kind**: static method of [<code>Deployer</code>](#Deployer)  
**Returns**: <code>TYPE.MultiMetadataTypeMap</code> - Metadata of BU in local directory  

| Param | Type | Description |
| --- | --- | --- |
| deployDir | <code>string</code> | root directory of metadata. |
| [typeArr] | <code>Array.&lt;string&gt;</code> | limit deployment to given metadata type |
| [listBadKeys] | <code>boolean</code> | do not print errors, used for badKeys() |

<a name="Deployer.createFolderDefinitions"></a>

### Deployer.createFolderDefinitions(deployDir, metadata, metadataTypeArr) ⇒ <code>void</code>
parses asset metadata to auto-create folders in target folder

**Kind**: static method of [<code>Deployer</code>](#Deployer)  

| Param | Type | Description |
| --- | --- | --- |
| deployDir | <code>string</code> | root directory of metadata. |
| metadata | <code>TYPE.MultiMetadataTypeMap</code> | list of metadata |
| metadataTypeArr | <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code> | list of metadata types |

<a name="Mcdev"></a>

## Mcdev
main class

**Kind**: global class  

* [Mcdev](#Mcdev)
    * [.setSkipInteraction([skipInteraction])](#Mcdev.setSkipInteraction) ⇒ <code>void</code>
    * [.setLoggingLevel(argv)](#Mcdev.setLoggingLevel) ⇒ <code>void</code>
    * [.setOptions(argv)](#Mcdev.setOptions) ⇒ <code>void</code>
    * [.createDeltaPkg(argv)](#Mcdev.createDeltaPkg) ⇒ <code>Promise.&lt;Array.&lt;TYPE.DeltaPkgItem&gt;&gt;</code>
    * [.selectTypes()](#Mcdev.selectTypes) ⇒ <code>Promise</code>
    * [.explainTypes()](#Mcdev.explainTypes) ⇒ <code>Array.&lt;object&gt;</code>
    * [.upgrade()](#Mcdev.upgrade) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.retrieve(businessUnit, [selectedTypesArr], [keys], [changelogOnly])](#Mcdev.retrieve) ⇒ <code>Promise.&lt;object&gt;</code>
    * [.deploy(businessUnit, [selectedTypesArr], [keyArr])](#Mcdev.deploy) ⇒ <code>Promise.&lt;Object.&lt;string, TYPE.MultiMetadataTypeMap&gt;&gt;</code>
    * [.initProject([credentialsName])](#Mcdev.initProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.joinProject()](#Mcdev.joinProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findBUs(credentialsName)](#Mcdev.findBUs) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.document(businessUnit, type)](#Mcdev.document) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.deleteByKey(businessUnit, type, customerKey)](#Mcdev.deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.refresh(businessUnit, type, [keyArr])](#Mcdev.refresh) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.badKeys(businessUnit)](#Mcdev.badKeys) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.retrieveAsTemplate(businessUnit, selectedType, name, market)](#Mcdev.retrieveAsTemplate) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code>
    * [.buildTemplate(businessUnit, selectedType, keyArr, market)](#Mcdev.buildTemplate) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code>
    * [.buildDefinition(businessUnit, selectedType, name, market)](#Mcdev.buildDefinition) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.buildDefinitionBulk(listName, type, name)](#Mcdev.buildDefinitionBulk) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.getFilesToCommit(businessUnit, selectedType, keyArr)](#Mcdev.getFilesToCommit) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
    * [.schedule(businessUnit, [selectedType], [keys])](#Mcdev.schedule) ⇒ <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code>
    * [.execute(businessUnit, [selectedType], [keys])](#Mcdev.execute) ⇒ <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code>
    * [.pause(businessUnit, [selectedType], [keys])](#Mcdev.pause) ⇒ <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code>
    * [.fixKeys(businessUnit, selectedType, [keys])](#Mcdev.fixKeys) ⇒ <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code>
    * [.updateNotifications(businessUnit, selectedType, [keys])](#Mcdev.updateNotifications) ⇒ <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code>

<a name="Mcdev.setSkipInteraction"></a>

### Mcdev.setSkipInteraction([skipInteraction]) ⇒ <code>void</code>
helper method to use unattended mode when including mcdev as a package

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>boolean</code> \| <code>TYPE.skipInteraction</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Mcdev.setLoggingLevel"></a>

### Mcdev.setLoggingLevel(argv) ⇒ <code>void</code>
configures what is displayed in the console

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  

| Param | Type | Description |
| --- | --- | --- |
| argv | <code>object</code> | list of command line parameters given by user |
| [argv.silent] | <code>boolean</code> | only errors printed to CLI |
| [argv.verbose] | <code>boolean</code> | chatty user CLI output |
| [argv.debug] | <code>boolean</code> | enables developer output & features |

<a name="Mcdev.setOptions"></a>

### Mcdev.setOptions(argv) ⇒ <code>void</code>
allows setting system wide / command related options

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  

| Param | Type | Description |
| --- | --- | --- |
| argv | <code>object</code> | list of command line parameters given by user |

<a name="Mcdev.createDeltaPkg"></a>

### Mcdev.createDeltaPkg(argv) ⇒ <code>Promise.&lt;Array.&lt;TYPE.DeltaPkgItem&gt;&gt;</code>
handler for 'mcdev createDeltaPkg

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;Array.&lt;TYPE.DeltaPkgItem&gt;&gt;</code> - list of changed items  

| Param | Type | Description |
| --- | --- | --- |
| argv | <code>object</code> | yargs parameters |
| [argv.range] | <code>string</code> | git commit range     into deploy directory |
| [argv.filter] | <code>string</code> | filter file paths that start with any |
| [argv.diffArr] | <code>Array.&lt;TYPE.DeltaPkgItem&gt;</code> | list of files to include in delta package (skips git diff when provided) |

<a name="Mcdev.selectTypes"></a>

### Mcdev.selectTypes() ⇒ <code>Promise</code>
**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise</code> - .  
<a name="Mcdev.explainTypes"></a>

### Mcdev.explainTypes() ⇒ <code>Array.&lt;object&gt;</code>
**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Array.&lt;object&gt;</code> - list of supported types with their apiNames  
<a name="Mcdev.upgrade"></a>

### Mcdev.upgrade() ⇒ <code>Promise.&lt;boolean&gt;</code>
**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - success flag  
<a name="Mcdev.retrieve"></a>

### Mcdev.retrieve(businessUnit, [selectedTypesArr], [keys], [changelogOnly]) ⇒ <code>Promise.&lt;object&gt;</code>
Retrieve all metadata from the specified business unit into the local file system.

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;object&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | references credentials from properties.json |
| [selectedTypesArr] | <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code> \| <code>TYPE.TypeKeyCombo</code> | limit retrieval to given metadata type |
| [keys] | <code>Array.&lt;string&gt;</code> | limit retrieval to given metadata key |
| [changelogOnly] | <code>boolean</code> | skip saving, only create json in memory |

<a name="Mcdev.deploy"></a>

### Mcdev.deploy(businessUnit, [selectedTypesArr], [keyArr]) ⇒ <code>Promise.&lt;Object.&lt;string, TYPE.MultiMetadataTypeMap&gt;&gt;</code>
Deploys all metadata located in the 'deploy' directory to the specified business unit

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;Object.&lt;string, TYPE.MultiMetadataTypeMap&gt;&gt;</code> - deployed metadata per BU (first key: bu name, second key: metadata type)  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | references credentials from properties.json |
| [selectedTypesArr] | <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code> | limit deployment to given metadata type |
| [keyArr] | <code>Array.&lt;string&gt;</code> | limit deployment to given metadata keys |

<a name="Mcdev.initProject"></a>

### Mcdev.initProject([credentialsName]) ⇒ <code>Promise.&lt;void&gt;</code>
Creates template file for properties.json

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| [credentialsName] | <code>string</code> | identifying name of the installed package / project |

<a name="Mcdev.joinProject"></a>

### Mcdev.joinProject() ⇒ <code>Promise.&lt;void&gt;</code>
Clones an existing project from git repository and installs it

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  
<a name="Mcdev.findBUs"></a>

### Mcdev.findBUs(credentialsName) ⇒ <code>Promise.&lt;void&gt;</code>
Refreshes BU names and ID's from MC instance

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| credentialsName | <code>string</code> | identifying name of the installed package / project |

<a name="Mcdev.document"></a>

### Mcdev.document(businessUnit, type) ⇒ <code>Promise.&lt;void&gt;</code>
Creates docs for supported metadata types in Markdown and/or HTML format

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | references credentials from properties.json |
| type | <code>string</code> | metadata type |

<a name="Mcdev.deleteByKey"></a>

### Mcdev.deleteByKey(businessUnit, type, customerKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
deletes metadata from MC instance by key

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - true if successful, false otherwise  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | references credentials from properties.json |
| type | <code>string</code> | supported metadata type |
| customerKey | <code>string</code> | Identifier of metadata |

<a name="Mcdev.refresh"></a>

### Mcdev.refresh(businessUnit, type, [keyArr]) ⇒ <code>Promise.&lt;void&gt;</code>
ensures triggered sends are restarted to ensure they pick up on changes of the underlying emails

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | references credentials from properties.json |
| type | <code>string</code> | references credentials from properties.json |
| [keyArr] | <code>Array.&lt;string&gt;</code> | metadata keys |

<a name="Mcdev.badKeys"></a>

### Mcdev.badKeys(businessUnit) ⇒ <code>Promise.&lt;void&gt;</code>
Converts metadata to legacy format. Output is saved in 'converted' directory

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | references credentials from properties.json |

<a name="Mcdev.retrieveAsTemplate"></a>

### Mcdev.retrieveAsTemplate(businessUnit, selectedType, name, market) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code>
Retrieve a specific metadata file and templatise.

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | references credentials from properties.json |
| selectedType | <code>string</code> | supported metadata type |
| name | <code>Array.&lt;string&gt;</code> | name of the metadata |
| market | <code>string</code> | market which should be used to revert template |

<a name="Mcdev.buildTemplate"></a>

### Mcdev.buildTemplate(businessUnit, selectedType, keyArr, market) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code>
Build a template based on a list of metadata files in the retrieve folder.

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | references credentials from properties.json |
| selectedType | <code>string</code> | supported metadata type |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |
| market | <code>string</code> | market localizations |

<a name="Mcdev.buildDefinition"></a>

### Mcdev.buildDefinition(businessUnit, selectedType, name, market) ⇒ <code>Promise.&lt;void&gt;</code>
Build a specific metadata file based on a template.

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | references credentials from properties.json |
| selectedType | <code>string</code> | supported metadata type |
| name | <code>string</code> | name of the metadata |
| market | <code>string</code> | market localizations |

<a name="Mcdev.buildDefinitionBulk"></a>

### Mcdev.buildDefinitionBulk(listName, type, name) ⇒ <code>Promise.&lt;void&gt;</code>
Build a specific metadata file based on a template using a list of bu-market combos

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| listName | <code>string</code> | name of list of BU-market combos |
| type | <code>string</code> | supported metadata type |
| name | <code>string</code> | name of the metadata |

<a name="Mcdev.getFilesToCommit"></a>

### Mcdev.getFilesToCommit(businessUnit, selectedType, keyArr) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - list of all files that need to be committed in a flat array ['path/file1.ext', 'path/file2.ext']  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | references credentials from properties.json |
| selectedType | <code>string</code> | supported metadata type |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="Mcdev.schedule"></a>

### Mcdev.schedule(businessUnit, [selectedType], [keys]) ⇒ <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code>
Schedule an item (shortcut for execute --schedule)

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code> - key: business unit name, value: list of scheduled item keys  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | name of BU |
| [selectedType] | <code>TYPE.SupportedMetadataTypes</code> | limit to given metadata types |
| [keys] | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="Mcdev.execute"></a>

### Mcdev.execute(businessUnit, [selectedType], [keys]) ⇒ <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code>
Start/execute an item

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code> - key: business unit name, value: list of executed item keys  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | name of BU |
| [selectedType] | <code>TYPE.SupportedMetadataTypes</code> | limit to given metadata types |
| [keys] | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="Mcdev.pause"></a>

### Mcdev.pause(businessUnit, [selectedType], [keys]) ⇒ <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code>
pause an item

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code> - key: business unit name, value: list of paused item keys  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | name of BU |
| [selectedType] | <code>TYPE.SupportedMetadataTypes</code> | limit to given metadata types |
| [keys] | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="Mcdev.fixKeys"></a>

### Mcdev.fixKeys(businessUnit, selectedType, [keys]) ⇒ <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code>
Updates the key to match the name field

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code> - key: business unit name, value: list of paused item keys  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | name of BU |
| selectedType | <code>TYPE.SupportedMetadataTypes</code> | limit to given metadata types |
| [keys] | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="Mcdev.updateNotifications"></a>

### Mcdev.updateNotifications(businessUnit, selectedType, [keys]) ⇒ <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code>
Updates notification email address field

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code> - key: business unit name, value: list of affected item keys  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>string</code> | name of BU |
| selectedType | <code>TYPE.SupportedMetadataTypes</code> | limit execution to given metadata type |
| [keys] | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="Asset"></a>

## Asset ⇐ [<code>MetadataType</code>](#MetadataType)
FileTransfer MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Asset](#Asset) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, _, [subTypeArr], [key])](#Asset.retrieve) ⇒ <code>Promise.&lt;{metadata: TYPE.AssetMap, type: string}&gt;</code>
    * [.retrieveForCache(_, [subTypeArr])](#Asset.retrieveForCache) ⇒ <code>Promise.&lt;{metadata: TYPE.AssetMap, type: string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [selectedSubType])](#Asset.retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata: TYPE.AssetItem, type: string}&gt;</code>
    * [.create(metadata)](#Asset.create) ⇒ <code>Promise</code>
    * [.update(metadata)](#Asset.update) ⇒ <code>Promise</code>
    * [.requestSubType(subType, [retrieveDir], [templateName], [templateVariables], key)](#Asset.requestSubType) ⇒ <code>Promise</code>
    * [.requestAndSaveExtended(items, subType, retrieveDir, [templateVariables])](#Asset.requestAndSaveExtended) ⇒ <code>Promise</code>
    * [._retrieveExtendedFile(metadata, subType, retrieveDir)](#Asset._retrieveExtendedFile) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._readExtendedFileFromFS(metadata, subType, deployDir, [pathOnly])](#Asset._readExtendedFileFromFS) ⇒ <code>Promise.&lt;string&gt;</code>
    * [.postRetrieveTasks(metadata)](#Asset.postRetrieveTasks) ⇒ <code>TYPE.CodeExtractItem</code>
    * [.postDeployTasks(metadata, _, createdUpdated)](#Asset.postDeployTasks) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#Asset.preDeployTasks) ⇒ <code>Promise.&lt;TYPE.AssetItem&gt;</code>
    * [._getMainSubtype(extendedSubType)](#Asset._getMainSubtype) ⇒ <code>string</code>
    * [.buildDefinitionForNested(templateDir, targetDir, metadata, templateVariables, templateName)](#Asset.buildDefinitionForNested) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.buildTemplateForNested(templateDir, targetDir, metadata, templateVariables, templateName)](#Asset.buildTemplateForNested) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._buildForNested(templateDir, targetDir, metadata, templateVariables, templateName, mode)](#Asset._buildForNested) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.setFolderPath(metadata)](#Asset.setFolderPath)
    * [.setFolderId(metadata)](#Asset.setFolderId)
    * [._mergeCode(metadata, deployDir, subType, [templateName], [fileListOnly])](#Asset._mergeCode) ⇒ <code>Promise.&lt;Array.&lt;TYPE.CodeExtract&gt;&gt;</code>
    * [._mergeCode_slots(prefix, metadataSlots, readDirArr, subtypeExtension, subDirArr, fileList, customerKey, [templateName], [fileListOnly])](#Asset._mergeCode_slots) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._extractCode(metadata)](#Asset._extractCode) ⇒ <code>TYPE.CodeExtractItem</code>
    * [._extractCode_slots(prefix, metadataSlots, codeArr)](#Asset._extractCode_slots) ⇒ <code>void</code>
    * [.getJsonFromFS(dir, [_], selectedSubType)](#Asset.getJsonFromFS) ⇒ <code>TYPE.MetadataTypeMap</code>
    * [.findSubType(templateDir, templateName)](#Asset.findSubType) ⇒ <code>Promise.&lt;TYPE.AssetSubType&gt;</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName)](#Asset.readSecondaryFolder) ⇒ <code>TYPE.AssetItem</code>
    * [.getFilesToCommit(keyArr)](#Asset.getFilesToCommit) ⇒ <code>Array.&lt;string&gt;</code>

<a name="Asset.retrieve"></a>

### Asset.retrieve(retrieveDir, _, [subTypeArr], [key]) ⇒ <code>Promise.&lt;{metadata: TYPE.AssetMap, type: string}&gt;</code>
Retrieves Metadata of Asset

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.AssetMap, type: string}&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| _ | <code>void</code> | - |
| [subTypeArr] | <code>Array.&lt;TYPE.AssetSubType&gt;</code> | optionally limit to a single subtype |
| [key] | <code>string</code> | customer key |

<a name="Asset.retrieveForCache"></a>

### Asset.retrieveForCache(_, [subTypeArr]) ⇒ <code>Promise.&lt;{metadata: TYPE.AssetMap, type: string}&gt;</code>
Retrieves asset metadata for caching

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.AssetMap, type: string}&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| _ | <code>void</code> | unused |
| [subTypeArr] | <code>Array.&lt;string&gt;</code> | optionally limit to a single subtype |

<a name="Asset.retrieveAsTemplate"></a>

### Asset.retrieveAsTemplate(templateDir, name, templateVariables, [selectedSubType]) ⇒ <code>Promise.&lt;{metadata: TYPE.AssetItem, type: string}&gt;</code>
Retrieves asset metadata for templating

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.AssetItem, type: string}&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| [selectedSubType] | <code>TYPE.AssetSubType</code> | optionally limit to a single subtype |

<a name="Asset.create"></a>

### Asset.create(metadata) ⇒ <code>Promise</code>
Creates a single asset

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AssetItem</code> | a single asset |

<a name="Asset.update"></a>

### Asset.update(metadata) ⇒ <code>Promise</code>
Updates a single asset

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AssetItem</code> | a single asset |

<a name="Asset.requestSubType"></a>

### Asset.requestSubType(subType, [retrieveDir], [templateName], [templateVariables], key) ⇒ <code>Promise</code>
Retrieves Metadata of a specific asset type

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| subType | <code>TYPE.AssetSubType</code> | group of similar assets to put in a folder (ie. images) |
| [retrieveDir] | <code>string</code> | target directory for saving assets |
| [templateName] | <code>string</code> | name of the metadata file |
| [templateVariables] | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| key | <code>string</code> | customer key to filter by |

<a name="Asset.requestAndSaveExtended"></a>

### Asset.requestAndSaveExtended(items, subType, retrieveDir, [templateVariables]) ⇒ <code>Promise</code>
Retrieves extended metadata (files or extended content) of asset

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| items | <code>Array</code> | array of items to retrieve |
| subType | <code>TYPE.AssetSubType</code> | group of similar assets to put in a folder (ie. images) |
| retrieveDir | <code>string</code> | target directory for saving assets |
| [templateVariables] | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Asset._retrieveExtendedFile"></a>

### Asset.\_retrieveExtendedFile(metadata, subType, retrieveDir) ⇒ <code>Promise.&lt;void&gt;</code>
Some metadata types store their actual content as a separate file, e.g. images
This method retrieves these and saves them alongside the metadata json

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AssetItem</code> | a single asset |
| subType | <code>TYPE.AssetSubType</code> | group of similar assets to put in a folder (ie. images) |
| retrieveDir | <code>string</code> | target directory for saving assets |

<a name="Asset._readExtendedFileFromFS"></a>

### Asset.\_readExtendedFileFromFS(metadata, subType, deployDir, [pathOnly]) ⇒ <code>Promise.&lt;string&gt;</code>
helper for [preDeployTasks](#Asset.preDeployTasks)
Some metadata types store their actual content as a separate file, e.g. images
This method reads these from the local FS stores them in the metadata object allowing to deploy it

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;string&gt;</code> - if found will return the path of the binary file  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadata | <code>TYPE.AssetItem</code> |  | a single asset |
| subType | <code>TYPE.AssetSubType</code> |  | group of similar assets to put in a folder (ie. images) |
| deployDir | <code>string</code> |  | directory of deploy files |
| [pathOnly] | <code>boolean</code> | <code>false</code> | used by getFilesToCommit which does not need the binary file to be actually read |

<a name="Asset.postRetrieveTasks"></a>

### Asset.postRetrieveTasks(metadata) ⇒ <code>TYPE.CodeExtractItem</code>
manages post retrieve steps

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>TYPE.CodeExtractItem</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AssetItem</code> | a single asset |

<a name="Asset.postDeployTasks"></a>

### Asset.postDeployTasks(metadata, _, createdUpdated) ⇒ <code>Promise.&lt;void&gt;</code>
Gets executed after deployment of metadata type

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeMap</code> | metadata mapped by their keyField |
| _ | <code>TYPE.MetadataTypeMap</code> | originalMetadata to be updated (contains additioanl fields) |
| createdUpdated | <code>Object</code> | counter representing successful creates/updates |

<a name="Asset.preDeployTasks"></a>

### Asset.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;TYPE.AssetItem&gt;</code>
prepares an asset definition for deployment

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;TYPE.AssetItem&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AssetItem</code> | a single asset |
| deployDir | <code>string</code> | directory of deploy files |

<a name="Asset._getMainSubtype"></a>

### Asset.\_getMainSubtype(extendedSubType) ⇒ <code>string</code>
find the subType matching the extendedSubType

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>string</code> - subType: block, message, other, etc  

| Param | Type | Description |
| --- | --- | --- |
| extendedSubType | <code>string</code> | webpage, htmlblock, etc |

<a name="Asset.buildDefinitionForNested"></a>

### Asset.buildDefinitionForNested(templateDir, targetDir, metadata, templateVariables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for [buildDefinition](#MetadataType.buildDefinition)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>TYPE.AssetItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="Asset.buildTemplateForNested"></a>

### Asset.buildTemplateForNested(templateDir, targetDir, metadata, templateVariables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for [buildTemplate](#MetadataType.buildTemplate)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.AssetItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

**Example**  
```js
assets of type codesnippetblock will result in 1 json and 1 amp/html file. both files need to be run through templating
```
<a name="Asset._buildForNested"></a>

### Asset.\_buildForNested(templateDir, targetDir, metadata, templateVariables, templateName, mode) ⇒ <code>Promise.&lt;void&gt;</code>
helper for [buildDefinition](#MetadataType.buildDefinition)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>TYPE.AssetItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |
| mode | <code>&#x27;definition&#x27;</code> \| <code>&#x27;template&#x27;</code> | defines what we use this helper for |

<a name="Asset.setFolderPath"></a>

### Asset.setFolderPath(metadata)
generic script that retrieves the folder path from cache and updates the given metadata with it after retrieve

**Kind**: static method of [<code>Asset</code>](#Asset)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single script activity definition |

<a name="Asset.setFolderId"></a>

### Asset.setFolderId(metadata)
Asset-specific script that retrieves the folder ID from cache and updates the given metadata with it before deploy

**Kind**: static method of [<code>Asset</code>](#Asset)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="Asset._mergeCode"></a>

### Asset.\_mergeCode(metadata, deployDir, subType, [templateName], [fileListOnly]) ⇒ <code>Promise.&lt;Array.&lt;TYPE.CodeExtract&gt;&gt;</code>
helper for [preDeployTasks](#Asset.preDeployTasks) that loads extracted code content back into JSON

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;Array.&lt;TYPE.CodeExtract&gt;&gt;</code> - fileList for templating (disregarded during deployment)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadata | <code>TYPE.AssetItem</code> |  | a single asset definition |
| deployDir | <code>string</code> |  | directory of deploy files |
| subType | <code>TYPE.AssetSubType</code> |  | asset-subtype name |
| [templateName] | <code>string</code> |  | name of the template used to built defintion (prior applying templating) |
| [fileListOnly] | <code>boolean</code> | <code>false</code> | does not read file contents nor update metadata if true |

<a name="Asset._mergeCode_slots"></a>

### Asset.\_mergeCode\_slots(prefix, metadataSlots, readDirArr, subtypeExtension, subDirArr, fileList, customerKey, [templateName], [fileListOnly]) ⇒ <code>Promise.&lt;void&gt;</code>
helper for [preDeployTasks](#Asset.preDeployTasks) that loads extracted code content back into JSON

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| prefix | <code>string</code> |  | usually the customerkey |
| metadataSlots | <code>object</code> |  | metadata.views.html.slots or deeper slots.<>.blocks.<>.slots |
| readDirArr | <code>Array.&lt;string&gt;</code> |  | directory of deploy files |
| subtypeExtension | <code>string</code> |  | asset-subtype name ending on -meta |
| subDirArr | <code>Array.&lt;string&gt;</code> |  | directory of files w/o leading deploy dir |
| fileList | <code>Array.&lt;object&gt;</code> |  | directory of files w/o leading deploy dir |
| customerKey | <code>string</code> |  | external key of template (could have been changed if used during templating) |
| [templateName] | <code>string</code> |  | name of the template used to built defintion (prior applying templating) |
| [fileListOnly] | <code>boolean</code> | <code>false</code> | does not read file contents nor update metadata if true |

<a name="Asset._extractCode"></a>

### Asset.\_extractCode(metadata) ⇒ <code>TYPE.CodeExtractItem</code>
helper for [postRetrieveTasks](#Asset.postRetrieveTasks) that finds code content in JSON and extracts it
to allow saving that separately and formatted

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>TYPE.CodeExtractItem</code> - { json: metadata, codeArr: object[], subFolder: string[] }  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AssetItem</code> | a single asset definition |

<a name="Asset._extractCode_slots"></a>

### Asset.\_extractCode\_slots(prefix, metadataSlots, codeArr) ⇒ <code>void</code>
**Kind**: static method of [<code>Asset</code>](#Asset)  

| Param | Type | Description |
| --- | --- | --- |
| prefix | <code>string</code> | usually the customerkey |
| metadataSlots | <code>object</code> | metadata.views.html.slots or deeper slots.<>.blocks.<>.slots |
| codeArr | <code>Array.&lt;object&gt;</code> | to be extended array for extracted code |

<a name="Asset.getJsonFromFS"></a>

### Asset.getJsonFromFS(dir, [_], selectedSubType) ⇒ <code>TYPE.MetadataTypeMap</code>
Returns file contents mapped to their fileName without '.json' ending

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>TYPE.MetadataTypeMap</code> - fileName => fileContent map  

| Param | Type | Description |
| --- | --- | --- |
| dir | <code>string</code> | directory that contains '.json' files to be read |
| [_] | <code>void</code> | unused parameter |
| selectedSubType | <code>Array.&lt;string&gt;</code> | asset, message, ... |

<a name="Asset.findSubType"></a>

### Asset.findSubType(templateDir, templateName) ⇒ <code>Promise.&lt;TYPE.AssetSubType&gt;</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;TYPE.AssetSubType&gt;</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="Asset.readSecondaryFolder"></a>

### Asset.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName) ⇒ <code>TYPE.AssetItem</code>
optional method used for some types to try a different folder structure

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>TYPE.AssetItem</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |

<a name="Asset.getFilesToCommit"></a>

### Asset.getFilesToCommit(keyArr) ⇒ <code>Array.&lt;string&gt;</code>
should return only the json for all but asset, query and script that are saved as multiple files
additionally, the documentation for dataExtension and automation should be returned

**Kind**: static method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Array.&lt;string&gt;</code> - list of all files that need to be committed in a flat array ['path/file1.ext', 'path/file2.ext']  

| Param | Type | Description |
| --- | --- | --- |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="AttributeGroup"></a>

## AttributeGroup ⇐ [<code>MetadataType</code>](#MetadataType)
AttributeGroup MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [AttributeGroup](#AttributeGroup) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#AttributeGroup.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveForCache()](#AttributeGroup.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.postRetrieveTasks(metadata)](#AttributeGroup.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code>

<a name="AttributeGroup.retrieve"></a>

### AttributeGroup.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of schema attribute groups.

**Kind**: static method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="AttributeGroup.retrieveForCache"></a>

### AttributeGroup.retrieveForCache() ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of schema attribute groups for caching.

**Kind**: static method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  
<a name="AttributeGroup.postRetrieveTasks"></a>

### AttributeGroup.postRetrieveTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
manages post retrieve steps

**Kind**: static method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single metadata |

<a name="AttributeSet"></a>

## AttributeSet ⇐ [<code>MetadataType</code>](#MetadataType)
AttributeSet MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [AttributeSet](#AttributeSet) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#AttributeSet.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveForCache()](#AttributeSet.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.fixShared_retrieve(sharedDataExtensionMap, fixShared_fields)](#AttributeSet.fixShared_retrieve) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
    * [.parseResponseBody(body, [singleRetrieve])](#AttributeSet.parseResponseBody) ⇒ <code>TYPE.MetadataTypeMap</code>
    * [.postRetrieveTasks(metadata)](#AttributeSet.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [._getSystemValueDefinitions()](#AttributeSet._getSystemValueDefinitions) ⇒ <code>Array.&lt;object&gt;</code>

<a name="AttributeSet.retrieve"></a>

### AttributeSet.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of schema set Definitions.

**Kind**: static method of [<code>AttributeSet</code>](#AttributeSet)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="AttributeSet.retrieveForCache"></a>

### AttributeSet.retrieveForCache() ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of schema set definitions for caching.

**Kind**: static method of [<code>AttributeSet</code>](#AttributeSet)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise  
<a name="AttributeSet.fixShared_retrieve"></a>

### AttributeSet.fixShared\_retrieve(sharedDataExtensionMap, fixShared_fields) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
used to identify updated shared data extensions that are used in attributeSets.
helper for DataExtension.#fixShared_onBU

**Kind**: static method of [<code>AttributeSet</code>](#AttributeSet)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - Promise of list of shared dataExtension IDs  

| Param | Type | Description |
| --- | --- | --- |
| sharedDataExtensionMap | <code>Object.&lt;string, string&gt;</code> | ID-Key relationship of shared data extensions |
| fixShared_fields | <code>object</code> | DataExtensionField.fixShared_fields |

<a name="AttributeSet.parseResponseBody"></a>

### AttributeSet.parseResponseBody(body, [singleRetrieve]) ⇒ <code>TYPE.MetadataTypeMap</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: static method of [<code>AttributeSet</code>](#AttributeSet)  
**Returns**: <code>TYPE.MetadataTypeMap</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>object</code> | json of response body |
| [singleRetrieve] | <code>string</code> \| <code>number</code> | key of single item to filter by |

<a name="AttributeSet.postRetrieveTasks"></a>

### AttributeSet.postRetrieveTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
manages post retrieve steps

**Kind**: static method of [<code>AttributeSet</code>](#AttributeSet)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single metadata |

<a name="AttributeSet._getSystemValueDefinitions"></a>

### AttributeSet.\_getSystemValueDefinitions() ⇒ <code>Array.&lt;object&gt;</code>
helper for [postRetrieveTasks](#AttributeSet.postRetrieveTasks)

**Kind**: static method of [<code>AttributeSet</code>](#AttributeSet)  
**Returns**: <code>Array.&lt;object&gt;</code> - all system value definitions  
<a name="Automation"></a>

## Automation ⇐ [<code>MetadataType</code>](#MetadataType)
Automation MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Automation](#Automation) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#Automation.retrieve) ⇒ <code>Promise.&lt;TYPE.AutomationMapObj&gt;</code>
    * [.retrieveChangelog()](#Automation.retrieveChangelog) ⇒ <code>Promise.&lt;TYPE.AutomationMapObj&gt;</code>
    * [.retrieveForCache()](#Automation.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.AutomationMapObj&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#Automation.retrieveAsTemplate) ⇒ <code>Promise.&lt;TYPE.AutomationItemObj&gt;</code>
    * [.postRetrieveTasks(metadata)](#Automation.postRetrieveTasks) ⇒ <code>TYPE.AutomationItem</code> \| <code>void</code>
    * [.execute(keyArr)](#Automation.execute) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
    * [.getErrorsREST(ex)](#Automation.getErrorsREST) ⇒ <code>Array.&lt;string&gt;</code> \| <code>void</code>
    * [.pause(keyArr)](#Automation.pause) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
    * [.deploy(metadata, targetBU, retrieveDir)](#Automation.deploy) ⇒ <code>Promise.&lt;TYPE.AutomationMap&gt;</code>
    * [.create(metadata)](#Automation.create) ⇒ <code>Promise</code>
    * [.update(metadata, metadataBefore)](#Automation.update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#Automation.preDeployTasks) ⇒ <code>Promise.&lt;TYPE.AutomationItem&gt;</code>
    * [.validateDeployMetadata(metadata)](#Automation.validateDeployMetadata) ⇒ <code>boolean</code>
    * [.postDeployTasks(metadataMap, originalMetadataMap)](#Automation.postDeployTasks) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.setFolderPath(metadata)](#Automation.setFolderPath)
    * [.setFolderId(metadata)](#Automation.setFolderId)
    * [._buildSchedule(scheduleObject)](#Automation._buildSchedule) ⇒ <code>TYPE.AutomationScheduleSoap</code>
    * [._calcTime(offsetServer, dateInput, [offsetInput])](#Automation._calcTime) ⇒ <code>string</code>
    * [.document([metadata])](#Automation.document) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.getFilesToCommit(keyArr)](#Automation.getFilesToCommit) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deleteByKey(customerKey)](#Automation.deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#Automation.postDeleteTasks) ⇒ <code>void</code>
    * [.updateNotifications(keys)](#Automation.updateNotifications) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
    * [.clearNotifications(keys)](#Automation.clearNotifications) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>

<a name="Automation.retrieve"></a>

### Automation.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.AutomationMapObj&gt;</code>
Retrieves Metadata of Automation

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;TYPE.AutomationMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="Automation.retrieveChangelog"></a>

### Automation.retrieveChangelog() ⇒ <code>Promise.&lt;TYPE.AutomationMapObj&gt;</code>
Retrieves Metadata of Automation

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;TYPE.AutomationMapObj&gt;</code> - Promise of metadata  
<a name="Automation.retrieveForCache"></a>

### Automation.retrieveForCache() ⇒ <code>Promise.&lt;TYPE.AutomationMapObj&gt;</code>
Retrieves automation metadata for caching

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;TYPE.AutomationMapObj&gt;</code> - Promise of metadata  
<a name="Automation.retrieveAsTemplate"></a>

### Automation.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;TYPE.AutomationItemObj&gt;</code>
Retrieve a specific Automation Definition by Name

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;TYPE.AutomationItemObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Automation.postRetrieveTasks"></a>

### Automation.postRetrieveTasks(metadata) ⇒ <code>TYPE.AutomationItem</code> \| <code>void</code>
manages post retrieve steps

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>TYPE.AutomationItem</code> \| <code>void</code> - parsed item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AutomationItem</code> | a single automation |

<a name="Automation.execute"></a>

### Automation.execute(keyArr) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
a function to start query execution via API

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - Returns list of keys that were executed  

| Param | Type | Description |
| --- | --- | --- |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="Automation.getErrorsREST"></a>

### Automation.getErrorsREST(ex) ⇒ <code>Array.&lt;string&gt;</code> \| <code>void</code>
Standardizes a check for multiple messages but adds query specific filters to error texts

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Array.&lt;string&gt;</code> \| <code>void</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>object</code> | response payload from REST API |

<a name="Automation.pause"></a>

### Automation.pause(keyArr) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
a function to start query execution via API

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - Returns list of keys that were paused  

| Param | Type | Description |
| --- | --- | --- |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="Automation.deploy"></a>

### Automation.deploy(metadata, targetBU, retrieveDir) ⇒ <code>Promise.&lt;TYPE.AutomationMap&gt;</code>
Deploys automation - the saved file is the original one due to large differences required for deployment

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;TYPE.AutomationMap&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AutomationMap</code> | metadata mapped by their keyField |
| targetBU | <code>string</code> | name/shorthand of target businessUnit for mapping |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="Automation.create"></a>

### Automation.create(metadata) ⇒ <code>Promise</code>
Creates a single automation

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AutomationItem</code> | single metadata entry |

<a name="Automation.update"></a>

### Automation.update(metadata, metadataBefore) ⇒ <code>Promise</code>
Updates a single automation

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AutomationItem</code> | single metadata entry |
| metadataBefore | <code>TYPE.AutomationItem</code> | metadata mapped by their keyField |

<a name="Automation.preDeployTasks"></a>

### Automation.preDeployTasks(metadata) ⇒ <code>Promise.&lt;TYPE.AutomationItem&gt;</code>
Gets executed before deploying metadata

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;TYPE.AutomationItem&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AutomationItem</code> | metadata mapped by their keyField |

<a name="Automation.validateDeployMetadata"></a>

### Automation.validateDeployMetadata(metadata) ⇒ <code>boolean</code>
Validates the automation to be sure it can be deployed.
Whitelisted Activites are deployed but require configuration

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>boolean</code> - result if automation can be deployed based on steps  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AutomationItem</code> | single automation record |

<a name="Automation.postDeployTasks"></a>

### Automation.postDeployTasks(metadataMap, originalMetadataMap) ⇒ <code>Promise.&lt;void&gt;</code>
Gets executed after deployment of metadata type

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.AutomationMap</code> | metadata mapped by their keyField |
| originalMetadataMap | <code>TYPE.AutomationMap</code> | metadata to be updated (contains additioanl fields) |

<a name="Automation.setFolderPath"></a>

### Automation.setFolderPath(metadata)
generic script that retrieves the folder path from cache and updates the given metadata with it after retrieve

**Kind**: static method of [<code>Automation</code>](#Automation)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single script activity definition |

<a name="Automation.setFolderId"></a>

### Automation.setFolderId(metadata)
automation-specific script that retrieves the folder ID from cache and updates the given metadata with it before deploy

**Kind**: static method of [<code>Automation</code>](#Automation)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="Automation._buildSchedule"></a>

### Automation.\_buildSchedule(scheduleObject) ⇒ <code>TYPE.AutomationScheduleSoap</code>
Builds a schedule object to be used for scheduling an automation
based on combination of ical string and start/end dates.

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>TYPE.AutomationScheduleSoap</code> - Schedulable object for soap API (currently not rest supported)  

| Param | Type | Description |
| --- | --- | --- |
| scheduleObject | <code>TYPE.AutomationSchedule</code> | child of automation metadata used for scheduling |

<a name="Automation._calcTime"></a>

### Automation.\_calcTime(offsetServer, dateInput, [offsetInput]) ⇒ <code>string</code>
used to convert dates to the system timezone required for startDate

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>string</code> - date in server  

| Param | Type | Description |
| --- | --- | --- |
| offsetServer | <code>number</code> | stack4: US Mountain time (UTC-7); other stacks: US Central (UTC-6) |
| dateInput | <code>string</code> \| <code>Date</code> | date in ISO format (2021-12-05T20:00:00.983) |
| [offsetInput] | <code>string</code> | timzone difference (+02:00) |

<a name="Automation.document"></a>

### Automation.document([metadata]) ⇒ <code>Promise.&lt;void&gt;</code>
Parses metadata into a readable Markdown/HTML format then saves it

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>TYPE.AutomationMap</code> | a list of dataExtension definitions |

<a name="Automation.getFilesToCommit"></a>

### Automation.getFilesToCommit(keyArr) ⇒ <code>Array.&lt;string&gt;</code>
should return only the json for all but asset, query and script that are saved as multiple files
additionally, the documentation for dataExtension and automation should be returned

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Array.&lt;string&gt;</code> - list of all files that need to be committed in a flat array ['path/file1.ext', 'path/file2.ext']  

| Param | Type | Description |
| --- | --- | --- |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="Automation.deleteByKey"></a>

### Automation.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="Automation.postDeleteTasks"></a>

### Automation.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: static method of [<code>Automation</code>](#Automation)  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="Automation.updateNotifications"></a>

### Automation.updateNotifications(keys) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
A function to update automation email notifications

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - keys of the automations where notifications were updated  

| Param | Type | Description |
| --- | --- | --- |
| keys | <code>string</code> | metadata keys |

<a name="Automation.clearNotifications"></a>

### Automation.clearNotifications(keys) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
A function to remove automation email notifications and/or notes

**Kind**: static method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - keys of the automations where notifications were updated  

| Param | Type | Description |
| --- | --- | --- |
| keys | <code>string</code> | metadata keys |

<a name="Campaign"></a>

## Campaign ⇐ [<code>MetadataType</code>](#MetadataType)
Campaign MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Campaign](#Campaign) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#Campaign.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveForCache()](#Campaign.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.getAssetTags(retrieveDir, campaignId, name)](#Campaign.getAssetTags) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>

<a name="Campaign.retrieve"></a>

### Campaign.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of campaigns. Afterwards, starts metadata retrieval for their campaign assets

**Kind**: static method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="Campaign.retrieveForCache"></a>

### Campaign.retrieveForCache() ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves event definition metadata for caching

**Kind**: static method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  
<a name="Campaign.getAssetTags"></a>

### Campaign.getAssetTags(retrieveDir, campaignId, name) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Parses campaign asset response body and returns metadata entries mapped to their id

**Kind**: static method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Campaign Asset Object  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | folder where to save |
| campaignId | <code>string</code> | of camapaign to retrieve |
| name | <code>string</code> | of camapaign for saving |

<a name="ContentArea"></a>

## ContentArea ⇐ [<code>MetadataType</code>](#MetadataType)
ContentArea MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [ContentArea](#ContentArea) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#ContentArea.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.postRetrieveTasks(metadata)](#ContentArea.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.setFolderPath(metadata)](#ContentArea.setFolderPath)
    * [.parseMetadata(metadata)](#ContentArea.parseMetadata) ⇒ <code>TYPE.MetadataTypeItem</code>

<a name="ContentArea.retrieve"></a>

### ContentArea.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves SOAP based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: static method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="ContentArea.postRetrieveTasks"></a>

### ContentArea.postRetrieveTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
manages post retrieve steps

**Kind**: static method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - parsed item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="ContentArea.setFolderPath"></a>

### ContentArea.setFolderPath(metadata)
generic script that retrieves the folder path from cache and updates the given metadata with it after retrieve

**Kind**: static method of [<code>ContentArea</code>](#ContentArea)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single script activity definition |

<a name="ContentArea.parseMetadata"></a>

### ContentArea.parseMetadata(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
parses retrieved Metadata before saving

**Kind**: static method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - parsed item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="DataExtension"></a>

## DataExtension ⇐ [<code>MetadataType</code>](#MetadataType)
DataExtension MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [DataExtension](#DataExtension) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.upsert(metadataMap)](#DataExtension.upsert) ⇒ <code>Promise</code>
    * [.createOrUpdate(metadataMap, metadataKey, hasError, metadataToUpdate, metadataToCreate)](#DataExtension.createOrUpdate) ⇒ <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code>
    * [.create(metadata)](#DataExtension.create) ⇒ <code>Promise</code>
    * [.update(metadata)](#DataExtension.update) ⇒ <code>Promise</code>
    * [.postDeployTasks(upsertedMetadata, originalMetadata, createdUpdated)](#DataExtension.postDeployTasks) ⇒ <code>void</code>
    * [.retrieve(retrieveDir, [additionalFields], [_], [key])](#DataExtension.retrieve) ⇒ <code>Promise.&lt;{metadata: TYPE.DataExtensionMap, type: string}&gt;</code>
    * [.retrieveSharedForCache([additionalFields])](#DataExtension.retrieveSharedForCache) ⇒ <code>Promise.&lt;TYPE.DataExtensionMap&gt;</code>
    * [.retrieveChangelog([additionalFields])](#DataExtension.retrieveChangelog) ⇒ <code>Promise.&lt;{metadata: TYPE.DataExtensionMap, type: string}&gt;</code>
    * [.postRetrieveTasks(metadata)](#DataExtension.postRetrieveTasks) ⇒ <code>TYPE.DataExtensionItem</code>
    * [.preDeployTasks(metadata)](#DataExtension.preDeployTasks) ⇒ <code>Promise.&lt;TYPE.DataExtensionItem&gt;</code>
    * [.document([metadataMap])](#DataExtension.document) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.deleteByKey(customerKey)](#DataExtension.deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.postDeleteTasks(customerKey)](#DataExtension.postDeleteTasks) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.retrieveForCache()](#DataExtension.retrieveForCache) ⇒ <code>Promise.&lt;{metadata: TYPE.DataExtensionMap, type: string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#DataExtension.retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata: TYPE.DataExtensionMap, type: string}&gt;</code>
    * [.setFolderPath(metadata)](#DataExtension.setFolderPath)
    * [.getFilesToCommit(keyArr)](#DataExtension.getFilesToCommit) ⇒ <code>Array.&lt;string&gt;</code>

<a name="DataExtension.upsert"></a>

### DataExtension.upsert(metadataMap) ⇒ <code>Promise</code>
Upserts dataExtensions after retrieving them from source and target to compare
if create or update operation is needed.

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.DataExtensionMap</code> | dataExtensions mapped by their customerKey |

<a name="DataExtension.createOrUpdate"></a>

### DataExtension.createOrUpdate(metadataMap, metadataKey, hasError, metadataToUpdate, metadataToCreate) ⇒ <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code>
helper for [upsert](#MetadataType.upsert)

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code> - action to take  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.MetadataTypeMap</code> | list of metadata |
| metadataKey | <code>string</code> | key of item we are looking at |
| hasError | <code>boolean</code> | error flag from previous code |
| metadataToUpdate | <code>Array.&lt;TYPE.MetadataTypeItemDiff&gt;</code> | list of items to update |
| metadataToCreate | <code>Array.&lt;TYPE.MetadataTypeItem&gt;</code> | list of items to create |

<a name="DataExtension.create"></a>

### DataExtension.create(metadata) ⇒ <code>Promise</code>
Create a single dataExtension. Also creates their columns in 'dataExtension.columns'

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.DataExtensionItem</code> | single metadata entry |

<a name="DataExtension.update"></a>

### DataExtension.update(metadata) ⇒ <code>Promise</code>
Updates a single dataExtension. Also updates their columns in 'dataExtension.columns'

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.DataExtensionItem</code> | single metadata entry |

<a name="DataExtension.postDeployTasks"></a>

### DataExtension.postDeployTasks(upsertedMetadata, originalMetadata, createdUpdated) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  

| Param | Type | Description |
| --- | --- | --- |
| upsertedMetadata | <code>TYPE.DataExtensionMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>TYPE.DataExtensionMap</code> | metadata to be updated (contains additioanl fields) |
| createdUpdated | <code>Object</code> | counter representing successful creates/updates |

<a name="DataExtension.retrieve"></a>

### DataExtension.retrieve(retrieveDir, [additionalFields], [_], [key]) ⇒ <code>Promise.&lt;{metadata: TYPE.DataExtensionMap, type: string}&gt;</code>
Retrieves dataExtension metadata. Afterwards starts retrieval of dataExtensionColumn metadata retrieval

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.DataExtensionMap, type: string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [_] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="DataExtension.retrieveSharedForCache"></a>

### DataExtension.retrieveSharedForCache([additionalFields]) ⇒ <code>Promise.&lt;TYPE.DataExtensionMap&gt;</code>
get shared dataExtensions from parent BU and merge them into the cache
helper for [retrieve](#DataExtension.retrieve) and for AttributeSet.fixShared_retrieve

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;TYPE.DataExtensionMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="DataExtension.retrieveChangelog"></a>

### DataExtension.retrieveChangelog([additionalFields]) ⇒ <code>Promise.&lt;{metadata: TYPE.DataExtensionMap, type: string}&gt;</code>
Retrieves dataExtension metadata. Afterwards starts retrieval of dataExtensionColumn metadata retrieval

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.DataExtensionMap, type: string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="DataExtension.postRetrieveTasks"></a>

### DataExtension.postRetrieveTasks(metadata) ⇒ <code>TYPE.DataExtensionItem</code>
manages post retrieve steps

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>TYPE.DataExtensionItem</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.DataExtensionItem</code> | a single dataExtension |

<a name="DataExtension.preDeployTasks"></a>

### DataExtension.preDeployTasks(metadata) ⇒ <code>Promise.&lt;TYPE.DataExtensionItem&gt;</code>
prepares a DataExtension for deployment

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;TYPE.DataExtensionItem&gt;</code> - Promise of updated single DE  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.DataExtensionItem</code> | a single data Extension |

<a name="DataExtension.document"></a>

### DataExtension.document([metadataMap]) ⇒ <code>Promise.&lt;void&gt;</code>
Parses metadata into a readable Markdown/HTML format then saves it

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| [metadataMap] | <code>TYPE.DataExtensionMap</code> | a list of dataExtension definitions |

<a name="DataExtension.deleteByKey"></a>

### DataExtension.deleteByKey(customerKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="DataExtension.postDeleteTasks"></a>

### DataExtension.postDeleteTasks(customerKey) ⇒ <code>Promise.&lt;void&gt;</code>
clean up after deleting a metadata item

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;void&gt;</code> - - promise  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="DataExtension.retrieveForCache"></a>

### DataExtension.retrieveForCache() ⇒ <code>Promise.&lt;{metadata: TYPE.DataExtensionMap, type: string}&gt;</code>
Retrieves folder metadata into local filesystem. Also creates a uniquePath attribute for each folder.

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.DataExtensionMap, type: string}&gt;</code> - Promise  
<a name="DataExtension.retrieveAsTemplate"></a>

### DataExtension.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;{metadata: TYPE.DataExtensionMap, type: string}&gt;</code>
Retrieves dataExtension metadata in template format.

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.DataExtensionMap, type: string}&gt;</code> - Promise of items  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata item |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="DataExtension.setFolderPath"></a>

### DataExtension.setFolderPath(metadata)
dataExtension logic that retrieves the folder path from cache and updates the given metadata with it after retrieve
it also sets the content type which is basically the subtype

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single script activity definition |

<a name="DataExtension.getFilesToCommit"></a>

### DataExtension.getFilesToCommit(keyArr) ⇒ <code>Array.&lt;string&gt;</code>
should return only the json for all but asset, query and script that are saved as multiple files
additionally, the documentation for dataExtension and automation should be returned

**Kind**: static method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Array.&lt;string&gt;</code> - list of all files that need to be committed in a flat array ['path/file1.ext', 'path/file2.ext']  

| Param | Type | Description |
| --- | --- | --- |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="DataExtensionField"></a>

## DataExtensionField ⇐ [<code>MetadataType</code>](#MetadataType)
DataExtensionField MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [DataExtensionField](#DataExtensionField) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [additionalFields])](#DataExtensionField.retrieve) ⇒ <code>Promise.&lt;{metadata: TYPE.DataExtensionFieldMap, type: string}&gt;</code>
    * [.retrieveForCache([requestParams], [additionalFields])](#DataExtensionField.retrieveForCache) ⇒ <code>Promise.&lt;{metadata: TYPE.DataExtensionFieldMap, type: string}&gt;</code>
    * [.convertToSortedArray(fieldsObj)](#DataExtensionField.convertToSortedArray) ⇒ <code>Array.&lt;TYPE.DataExtensionFieldItem&gt;</code>
    * [.sortDeFields(a, b)](#DataExtensionField.sortDeFields) ⇒ <code>boolean</code>
    * [.postRetrieveTasks(metadata, forDataExtension)](#DataExtensionField.postRetrieveTasks) ⇒ <code>TYPE.DataExtensionFieldItem</code>
    * [.prepareDeployColumnsOnUpdate(deployColumns, deKey)](#DataExtensionField.prepareDeployColumnsOnUpdate) ⇒ <code>Promise.&lt;Object.&lt;string, TYPE.DataExtensionFieldItem&gt;&gt;</code>
    * [.deleteByKey(customerKey)](#DataExtensionField.deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.deleteByKeySOAP(customerKey, [fieldId])](#DataExtensionField.deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#DataExtensionField.postDeleteTasks) ⇒ <code>void</code>

<a name="DataExtensionField.retrieve"></a>

### DataExtensionField.retrieve(retrieveDir, [additionalFields]) ⇒ <code>Promise.&lt;{metadata: TYPE.DataExtensionFieldMap, type: string}&gt;</code>
Retrieves all records and saves it to disk

**Kind**: static method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.DataExtensionFieldMap, type: string}&gt;</code> - Promise of items  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="DataExtensionField.retrieveForCache"></a>

### DataExtensionField.retrieveForCache([requestParams], [additionalFields]) ⇒ <code>Promise.&lt;{metadata: TYPE.DataExtensionFieldMap, type: string}&gt;</code>
Retrieves all records for caching

**Kind**: static method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.DataExtensionFieldMap, type: string}&gt;</code> - Promise of items  

| Param | Type | Description |
| --- | --- | --- |
| [requestParams] | <code>TYPE.SoapRequestParams</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="DataExtensionField.convertToSortedArray"></a>

### DataExtensionField.convertToSortedArray(fieldsObj) ⇒ <code>Array.&lt;TYPE.DataExtensionFieldItem&gt;</code>
helper for DataExtension.retrieveFieldsForSingleDe that sorts the fields into an array

**Kind**: static method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Array.&lt;TYPE.DataExtensionFieldItem&gt;</code> - sorted array of field objects  

| Param | Type | Description |
| --- | --- | --- |
| fieldsObj | <code>TYPE.DataExtensionFieldMap</code> | customerKey-based list of fields for one dataExtension |

<a name="DataExtensionField.sortDeFields"></a>

### DataExtensionField.sortDeFields(a, b) ⇒ <code>boolean</code>
sorting method to ensure `Ordinal` is respected

**Kind**: static method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>boolean</code> - sorting based on Ordinal  

| Param | Type | Description |
| --- | --- | --- |
| a | <code>TYPE.DataExtensionFieldItem</code> | - |
| b | <code>TYPE.DataExtensionFieldItem</code> | - |

<a name="DataExtensionField.postRetrieveTasks"></a>

### DataExtensionField.postRetrieveTasks(metadata, forDataExtension) ⇒ <code>TYPE.DataExtensionFieldItem</code>
manages post retrieve steps

**Kind**: static method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>TYPE.DataExtensionFieldItem</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.DataExtensionFieldItem</code> | a single item |
| forDataExtension | <code>boolean</code> | when used by DataExtension class we remove more fields |

<a name="DataExtensionField.prepareDeployColumnsOnUpdate"></a>

### DataExtensionField.prepareDeployColumnsOnUpdate(deployColumns, deKey) ⇒ <code>Promise.&lt;Object.&lt;string, TYPE.DataExtensionFieldItem&gt;&gt;</code>
Mofifies passed deployColumns for update by mapping ObjectID to their target column's values.
Removes FieldType field if its the same in deploy and target column, because it results in an error even if its of the same type

**Kind**: static method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;Object.&lt;string, TYPE.DataExtensionFieldItem&gt;&gt;</code> - existing fields by their original name to allow re-adding FieldType after update  

| Param | Type | Description |
| --- | --- | --- |
| deployColumns | <code>Array.&lt;TYPE.DataExtensionFieldItem&gt;</code> | Columns of data extension that will be deployed |
| deKey | <code>string</code> | external/customer key of Data Extension |

<a name="DataExtensionField.deleteByKey"></a>

### DataExtensionField.deleteByKey(customerKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit

**Kind**: static method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="DataExtensionField.deleteByKeySOAP"></a>

### DataExtensionField.deleteByKeySOAP(customerKey, [fieldId]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: static method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [fieldId] | <code>string</code> | for programmatic deletes only one can pass in the ID directly |

<a name="DataExtensionField.postDeleteTasks"></a>

### DataExtensionField.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: static method of [<code>DataExtensionField</code>](#DataExtensionField)  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="DataExtensionTemplate"></a>

## DataExtensionTemplate ⇐ [<code>MetadataType</code>](#MetadataType)
DataExtensionTemplate MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  
<a name="DataExtensionTemplate.retrieve"></a>

### DataExtensionTemplate.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves SOAP based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: static method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="DataExtract"></a>

## DataExtract ⇐ [<code>MetadataType</code>](#MetadataType)
DataExtract MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [DataExtract](#DataExtract) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#DataExtract.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveForCache()](#DataExtract.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#DataExtract.retrieveAsTemplate) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code>
    * [.postRetrieveTasks(fileTransfer)](#DataExtract.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.create(dataExtract)](#DataExtract.create) ⇒ <code>Promise</code>
    * [.update(dataExtract)](#DataExtract.update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#DataExtract.preDeployTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.parseMetadata(metadata)](#DataExtract.parseMetadata) ⇒ <code>TYPE.MetadataTypeItem</code>

<a name="DataExtract.retrieve"></a>

### DataExtract.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of Data Extract Activity.
Endpoint /automation/v1/dataextracts/ returns all Data Extracts

**Kind**: static method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="DataExtract.retrieveForCache"></a>

### DataExtract.retrieveForCache() ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of  Data Extract Activity for caching

**Kind**: static method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  
<a name="DataExtract.retrieveAsTemplate"></a>

### DataExtract.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code>
Retrieve a specific dataExtract Definition by Name

**Kind**: static method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="DataExtract.postRetrieveTasks"></a>

### DataExtract.postRetrieveTasks(fileTransfer) ⇒ <code>TYPE.MetadataTypeItem</code>
manages post retrieve steps

**Kind**: static method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| fileTransfer | <code>TYPE.MetadataTypeItem</code> | a single fileTransfer |

<a name="DataExtract.create"></a>

### DataExtract.create(dataExtract) ⇒ <code>Promise</code>
Creates a single Data Extract

**Kind**: static method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| dataExtract | <code>TYPE.MetadataTypeItem</code> | a single Data Extract |

<a name="DataExtract.update"></a>

### DataExtract.update(dataExtract) ⇒ <code>Promise</code>
Updates a single Data Extract

**Kind**: static method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| dataExtract | <code>TYPE.MetadataTypeItem</code> | a single Data Extract |

<a name="DataExtract.preDeployTasks"></a>

### DataExtract.preDeployTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
prepares a dataExtract for deployment

**Kind**: static method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - metadata object  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single dataExtract activity definition |

<a name="DataExtract.parseMetadata"></a>

### DataExtract.parseMetadata(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
parses retrieved Metadata before saving

**Kind**: static method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single dataExtract activity definition |

<a name="DataExtractType"></a>

## DataExtractType ⇐ [<code>MetadataType</code>](#MetadataType)
DataExtractType MetadataType
Only for Caching No retrieve/upsert is required
as this is a configuration in the EID

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [DataExtractType](#DataExtractType) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#DataExtractType.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveForCache()](#DataExtractType.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>

<a name="DataExtractType.retrieve"></a>

### DataExtractType.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of  Data Extract Type.

**Kind**: static method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="DataExtractType.retrieveForCache"></a>

### DataExtractType.retrieveForCache() ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of  Data Extract Type for caching.

**Kind**: static method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  
<a name="Discovery"></a>

## Discovery ⇐ [<code>MetadataType</code>](#MetadataType)
ImportFile MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  
<a name="Discovery.retrieve"></a>

### Discovery.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves API endpoint
documentation: https://developer.salesforce.com/docs/atlas.en-us.noversion.mc-apis.meta/mc-apis/routes.htm

**Kind**: static method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | not used |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="Email"></a>

## Email ⇐ [<code>MetadataType</code>](#MetadataType)
Email MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Email](#Email) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#Email.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#Email.saveResults) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code>
    * [.postRetrieveTasks(metadata)](#Email.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.parseMetadata(metadata)](#Email.parseMetadata) ⇒ <code>TYPE.MetadataTypeItem</code>

<a name="Email.retrieve"></a>

### Email.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves SOAP based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: static method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="Email.saveResults"></a>

### Email.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: static method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>TYPE.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Email.postRetrieveTasks"></a>

### Email.postRetrieveTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
manages post retrieve steps

**Kind**: static method of [<code>Email</code>](#Email)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - Array with one metadata object and one query string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single query |

<a name="Email.parseMetadata"></a>

### Email.parseMetadata(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
parses retrieved Metadata before saving

**Kind**: static method of [<code>Email</code>](#Email)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single query activity definition |

<a name="EmailSend"></a>

## EmailSend ⇐ [<code>MetadataType</code>](#MetadataType)
MessageSendActivity MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [EmailSend](#EmailSend) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#EmailSend.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.update(metadataItem)](#EmailSend.update) ⇒ <code>Promise</code>
    * [.create(metadataItem)](#EmailSend.create) ⇒ <code>Promise</code>
    * [.deleteByKey(customerKey)](#EmailSend.deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.preDeployTasks(metadata)](#EmailSend.preDeployTasks) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code>
    * [.postRetrieveTasks(metadata)](#EmailSend.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.parseMetadata(metadata)](#EmailSend.parseMetadata) ⇒ <code>TYPE.MetadataTypeItem</code>

<a name="EmailSend.retrieve"></a>

### EmailSend.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves SOAP based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: static method of [<code>EmailSend</code>](#EmailSend)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="EmailSend.update"></a>

### EmailSend.update(metadataItem) ⇒ <code>Promise</code>
Updates a single item

**Kind**: static method of [<code>EmailSend</code>](#EmailSend)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataItem | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="EmailSend.create"></a>

### EmailSend.create(metadataItem) ⇒ <code>Promise</code>
Creates a single item

**Kind**: static method of [<code>EmailSend</code>](#EmailSend)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataItem | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="EmailSend.deleteByKey"></a>

### EmailSend.deleteByKey(customerKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit

**Kind**: static method of [<code>EmailSend</code>](#EmailSend)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="EmailSend.preDeployTasks"></a>

### EmailSend.preDeployTasks(metadata) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code>
prepares a single item for deployment

**Kind**: static method of [<code>EmailSend</code>](#EmailSend)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single script activity definition |

<a name="EmailSend.postRetrieveTasks"></a>

### EmailSend.postRetrieveTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
manages post retrieve steps

**Kind**: static method of [<code>EmailSend</code>](#EmailSend)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - Array with one metadata object and one query string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single query |

<a name="EmailSend.parseMetadata"></a>

### EmailSend.parseMetadata(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
parses retrieved Metadata before saving

**Kind**: static method of [<code>EmailSend</code>](#EmailSend)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single query activity definition |

<a name="Event"></a>

## Event ⇐ [<code>MetadataType</code>](#MetadataType)
Event MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Event](#Event) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#Event.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveForCache()](#Event.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#Event.retrieveAsTemplate) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code>
    * [.postRetrieveTasks(eventDef)](#Event.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.deleteByKey(key)](#Event.deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#Event.deploy) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code>
    * [.create(metadata)](#Event.create) ⇒ <code>Promise</code>
    * [.update(metadataEntry)](#Event.update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#Event.preDeployTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.parseMetadata(metadata)](#Event.parseMetadata) ⇒ <code>TYPE.MetadataTypeItem</code>

<a name="Event.retrieve"></a>

### Event.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of Event Definition.
Endpoint /interaction/v1/EventDefinitions return all Event Definitions with all details.
Currently it is not needed to loop over Imports with endpoint /interaction/v1/EventDefinitions/{id}

**Kind**: static method of [<code>Event</code>](#Event)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="Event.retrieveForCache"></a>

### Event.retrieveForCache() ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves event definition metadata for caching

**Kind**: static method of [<code>Event</code>](#Event)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  
<a name="Event.retrieveAsTemplate"></a>

### Event.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code>
Retrieve a specific Event Definition by Name

**Kind**: static method of [<code>Event</code>](#Event)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Event.postRetrieveTasks"></a>

### Event.postRetrieveTasks(eventDef) ⇒ <code>TYPE.MetadataTypeItem</code>
manages post retrieve steps

**Kind**: static method of [<code>Event</code>](#Event)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| eventDef | <code>TYPE.MetadataTypeItem</code> | a single item of Event Definition |

<a name="Event.deleteByKey"></a>

### Event.deleteByKey(key) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit

**Kind**: static method of [<code>Event</code>](#Event)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> | Identifier of item |

<a name="Event.deploy"></a>

### Event.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code>
Deploys metadata - merely kept here to be able to print [logBeta](#Util.logBeta) once per deploy

**Kind**: static method of [<code>Event</code>](#Event)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="Event.create"></a>

### Event.create(metadata) ⇒ <code>Promise</code>
Creates a single Event Definition

**Kind**: static method of [<code>Event</code>](#Event)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single Event Definition |

<a name="Event.update"></a>

### Event.update(metadataEntry) ⇒ <code>Promise</code>
Updates a single Event Definition (using PUT method since PATCH isn't supported)

**Kind**: static method of [<code>Event</code>](#Event)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | a single Event Definition |

<a name="Event.preDeployTasks"></a>

### Event.preDeployTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
prepares an event definition for deployment

**Kind**: static method of [<code>Event</code>](#Event)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - parsed version  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single eventDefinition |

<a name="Event.parseMetadata"></a>

### Event.parseMetadata(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
parses retrieved Metadata before saving

**Kind**: static method of [<code>Event</code>](#Event)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - parsed metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single event definition |

<a name="FtpLocation"></a>

## FtpLocation ⇐ [<code>MetadataType</code>](#MetadataType)
ImportFile MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [FtpLocation](#FtpLocation) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#FtpLocation.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveForCache()](#FtpLocation.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>

<a name="FtpLocation.retrieve"></a>

### FtpLocation.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of FtpLocation
Endpoint /automation/v1/ftplocations/ return all FtpLocations

**Kind**: static method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="FtpLocation.retrieveForCache"></a>

### FtpLocation.retrieveForCache() ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves folder metadata into local filesystem. Also creates a uniquePath attribute for each folder.

**Kind**: static method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise  
<a name="FileTransfer"></a>

## FileTransfer ⇐ [<code>MetadataType</code>](#MetadataType)
FileTransfer MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [FileTransfer](#FileTransfer) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#FileTransfer.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveForCache()](#FileTransfer.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#FileTransfer.retrieveAsTemplate) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code>
    * [.postRetrieveTasks(metadata)](#FileTransfer.postRetrieveTasks) ⇒ <code>Array.&lt;object&gt;</code>
    * [.create(fileTransfer)](#FileTransfer.create) ⇒ <code>Promise</code>
    * [.update(fileTransfer)](#FileTransfer.update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#FileTransfer.preDeployTasks) ⇒ <code>Promise</code>
    * [.parseMetadata(metadata)](#FileTransfer.parseMetadata) ⇒ <code>TYPE.MetadataTypeItem</code>

<a name="FileTransfer.retrieve"></a>

### FileTransfer.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of FileTransfer Activity.
Endpoint /automation/v1/filetransfers/ returns all File Transfers

**Kind**: static method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="FileTransfer.retrieveForCache"></a>

### FileTransfer.retrieveForCache() ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of  FileTransfer Activity for caching

**Kind**: static method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise  
<a name="FileTransfer.retrieveAsTemplate"></a>

### FileTransfer.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code>
Retrieve a specific File Transfer Definition by Name

**Kind**: static method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="FileTransfer.postRetrieveTasks"></a>

### FileTransfer.postRetrieveTasks(metadata) ⇒ <code>Array.&lt;object&gt;</code>
manages post retrieve steps

**Kind**: static method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Array.&lt;object&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single fileTransfer activity definition |

<a name="FileTransfer.create"></a>

### FileTransfer.create(fileTransfer) ⇒ <code>Promise</code>
Creates a single File Transfer

**Kind**: static method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| fileTransfer | <code>TYPE.MetadataTypeItem</code> | a single File Transfer |

<a name="FileTransfer.update"></a>

### FileTransfer.update(fileTransfer) ⇒ <code>Promise</code>
Updates a single File Transfer

**Kind**: static method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| fileTransfer | <code>TYPE.MetadataTypeItem</code> | a single File Transfer |

<a name="FileTransfer.preDeployTasks"></a>

### FileTransfer.preDeployTasks(metadata) ⇒ <code>Promise</code>
prepares a fileTransfer for deployment

**Kind**: static method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single fileTransfer activity definition |

<a name="FileTransfer.parseMetadata"></a>

### FileTransfer.parseMetadata(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
parses retrieved Metadata before saving

**Kind**: static method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - parsed metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single fileTransfer activity definition |

<a name="Filter"></a>

## Filter ⇐ [<code>MetadataType</code>](#MetadataType)
Filter MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  
<a name="Filter.retrieve"></a>

### Filter.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of Filter.
Endpoint /automation/v1/filters/ returns all Filters,
but only with some of the fields. So it is needed to loop over
Filters with the endpoint /automation/v1/filters/{id}

**Kind**: static method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="Folder"></a>

## Folder ⇐ [<code>MetadataType</code>](#MetadataType)
Folder MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Folder](#Folder) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [additionalFields], [subTypeArr], [key])](#Folder.retrieve) ⇒ <code>Promise</code>
    * [.retrieveForCache(_, [subTypeArr])](#Folder.retrieveForCache) ⇒ <code>Promise</code>
    * [.upsert(metadata)](#Folder.upsert) ⇒ <code>Promise.&lt;object&gt;</code>
    * [.create(metadataEntry)](#Folder.create) ⇒ <code>Promise</code>
    * [.update(metadataEntry)](#Folder.update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#Folder.preDeployTasks) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#Folder.getJsonFromFS) ⇒ <code>TYPE.MetadataTypeMap</code>
    * [.retrieveHelper([additionalFields], [queryAllAccounts], [contentTypeList])](#Folder.retrieveHelper) ⇒ <code>Promise.&lt;object&gt;</code>
    * [.postRetrieveTasks(metadata)](#Folder.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.saveResults(results, retrieveDir, mid)](#Folder.saveResults) ⇒ <code>Promise.&lt;object&gt;</code>

<a name="Folder.retrieve"></a>

### Folder.retrieve(retrieveDir, [additionalFields], [subTypeArr], [key]) ⇒ <code>Promise</code>
Retrieves metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: static method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subTypeArr] | <code>Array.&lt;string&gt;</code> | content type of folder |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="Folder.retrieveForCache"></a>

### Folder.retrieveForCache(_, [subTypeArr]) ⇒ <code>Promise</code>
Retrieves folder metadata for caching

**Kind**: static method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| _ | <code>void</code> | unused |
| [subTypeArr] | <code>Array.&lt;string&gt;</code> | content type of folder |

<a name="Folder.upsert"></a>

### Folder.upsert(metadata) ⇒ <code>Promise.&lt;object&gt;</code>
Folder upsert (copied from Metadata Upsert), after retrieving from target
and comparing to check if create or update operation is needed.
Copied due to having a dependency on itself, meaning the created need to be serial

**Kind**: static method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise.&lt;object&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeMap</code> | metadata mapped by their keyField |

<a name="Folder.create"></a>

### Folder.create(metadataEntry) ⇒ <code>Promise</code>
creates a folder based on metatadata

**Kind**: static method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | metadata of the folder |

<a name="Folder.update"></a>

### Folder.update(metadataEntry) ⇒ <code>Promise</code>
Updates a single Folder.

**Kind**: static method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | single metadata entry |

<a name="Folder.preDeployTasks"></a>

### Folder.preDeployTasks(metadata) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code>
prepares a folder for deployment

**Kind**: static method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code> - Promise of parsed folder metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single folder definition |

<a name="Folder.getJsonFromFS"></a>

### Folder.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>TYPE.MetadataTypeMap</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: static method of [<code>Folder</code>](#Folder)  
**Returns**: <code>TYPE.MetadataTypeMap</code> - fileName => fileContent map  

| Param | Type | Description |
| --- | --- | --- |
| dir | <code>string</code> | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | do not print errors, used for badKeys() |

<a name="Folder.retrieveHelper"></a>

### Folder.retrieveHelper([additionalFields], [queryAllAccounts], [contentTypeList]) ⇒ <code>Promise.&lt;object&gt;</code>
Helper to retrieve the folders as promise

**Kind**: static method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise.&lt;object&gt;</code> - soap object  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [queryAllAccounts] | <code>boolean</code> | which queryAllAccounts setting to use |
| [contentTypeList] | <code>Array.&lt;string&gt;</code> | content type of folder |

<a name="Folder.postRetrieveTasks"></a>

### Folder.postRetrieveTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: static method of [<code>Folder</code>](#Folder)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="Folder.saveResults"></a>

### Folder.saveResults(results, retrieveDir, mid) ⇒ <code>Promise.&lt;object&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: static method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise.&lt;object&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>object</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| mid | <code>number</code> | current mid for this credential / business unit |

<a name="ImportFile"></a>

## ImportFile ⇐ [<code>MetadataType</code>](#MetadataType)
ImportFile MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [ImportFile](#ImportFile) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#ImportFile.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveForCache()](#ImportFile.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#ImportFile.retrieveAsTemplate) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code>
    * [.postRetrieveTasks(importDef)](#ImportFile.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.create(importFile)](#ImportFile.create) ⇒ <code>Promise</code>
    * [.update(importFile)](#ImportFile.update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#ImportFile.preDeployTasks) ⇒ <code>Promise</code>
    * [.getKeysToSetNotifications(metadataMap)](#ImportFile.getKeysToSetNotifications) ⇒ <code>Array.&lt;string&gt;</code>
    * [.parseMetadata(metadata)](#ImportFile.parseMetadata) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.createOrUpdate(metadataMap, metadataKey, hasError, metadataToUpdate, metadataToCreate)](#ImportFile.createOrUpdate) ⇒ <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code>

<a name="ImportFile.retrieve"></a>

### ImportFile.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of Import File.
Endpoint /automation/v1/imports/ return all Import Files with all details.
Currently it is not needed to loop over Imports with endpoint /automation/v1/imports/{id}

**Kind**: static method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="ImportFile.retrieveForCache"></a>

### ImportFile.retrieveForCache() ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves import definition metadata for caching

**Kind**: static method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise  
<a name="ImportFile.retrieveAsTemplate"></a>

### ImportFile.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code>
Retrieve a specific Import Definition by Name

**Kind**: static method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="ImportFile.postRetrieveTasks"></a>

### ImportFile.postRetrieveTasks(importDef) ⇒ <code>TYPE.MetadataTypeItem</code>
manages post retrieve steps

**Kind**: static method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| importDef | <code>TYPE.MetadataTypeItem</code> | a single importDef |

<a name="ImportFile.create"></a>

### ImportFile.create(importFile) ⇒ <code>Promise</code>
Creates a single Import File

**Kind**: static method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| importFile | <code>TYPE.MetadataTypeItem</code> | a single Import File |

<a name="ImportFile.update"></a>

### ImportFile.update(importFile) ⇒ <code>Promise</code>
Updates a single Import File

**Kind**: static method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| importFile | <code>TYPE.MetadataTypeItem</code> | a single Import File |

<a name="ImportFile.preDeployTasks"></a>

### ImportFile.preDeployTasks(metadata) ⇒ <code>Promise</code>
prepares a import definition for deployment

**Kind**: static method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single importDef |

<a name="ImportFile.getKeysToSetNotifications"></a>

### ImportFile.getKeysToSetNotifications(metadataMap) ⇒ <code>Array.&lt;string&gt;</code>
helper function to get a list of keys where notification email address should be updated

**Kind**: static method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Array.&lt;string&gt;</code> - list of keys  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.MetadataTypeMap</code> | metadata mapped by their keyField |

<a name="ImportFile.parseMetadata"></a>

### ImportFile.parseMetadata(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
parses retrieved Metadata before saving

**Kind**: static method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - parsed metadata definition  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single import definition |

<a name="ImportFile.createOrUpdate"></a>

### ImportFile.createOrUpdate(metadataMap, metadataKey, hasError, metadataToUpdate, metadataToCreate) ⇒ <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code>
helper for [upsert](#MetadataType.upsert)

**Kind**: static method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code> - action to take  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.MetadataTypeMap</code> | list of metadata |
| metadataKey | <code>string</code> | key of item we are looking at |
| hasError | <code>boolean</code> | error flag from previous code |
| metadataToUpdate | <code>Array.&lt;TYPE.MetadataTypeItemDiff&gt;</code> | list of items to update |
| metadataToCreate | <code>Array.&lt;TYPE.MetadataTypeItem&gt;</code> | list of items to create |

<a name="Journey"></a>

## Journey ⇐ [<code>MetadataType</code>](#MetadataType)
Journey MetadataType
! BETA RELEASE of journey support (v4.3.0); it so far only resolves a limited amount of dependencies and will likely break during cross-BU deployments!
id: A unique id of the journey assigned by the journey’s API during its creation
key: A unique id of the journey within the MID. Can be generated by the developer
definitionId: A unique UUID provided by Salesforce Marketing Cloud. Each version of a journey has a unique DefinitionID while the Id and Key remain the same. Version 1 will have id == definitionId

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Journey](#Journey) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#Journey.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.deleteByKey(key)](#Journey.deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#Journey.deploy) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code>
    * [.update(metadata)](#Journey.update) ⇒ <code>Promise</code>
    * [.create(metadata)](#Journey.create) ⇒ <code>Promise</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#Journey.saveResults) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code>
    * [._postRetrieveTasksBulk(metadataMap)](#Journey._postRetrieveTasksBulk)
    * [.postRetrieveTasks(metadata)](#Journey.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.preDeployTasks(metadata)](#Journey.preDeployTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.createOrUpdate(metadataMap, metadataKey, hasError, metadataToUpdate, metadataToCreate)](#Journey.createOrUpdate) ⇒ <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code>

<a name="Journey.retrieve"></a>

### Journey.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of Journey

**Kind**: static method of [<code>Journey</code>](#Journey)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="Journey.deleteByKey"></a>

### Journey.deleteByKey(key) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit

**Kind**: static method of [<code>Journey</code>](#Journey)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> | Identifier of item |

<a name="Journey.deploy"></a>

### Journey.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code>
Deploys metadata - merely kept here to be able to print [logBeta](#Util.logBeta) once per deploy

**Kind**: static method of [<code>Journey</code>](#Journey)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="Journey.update"></a>

### Journey.update(metadata) ⇒ <code>Promise</code>
Updates a single item

**Kind**: static method of [<code>Journey</code>](#Journey)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="Journey.create"></a>

### Journey.create(metadata) ⇒ <code>Promise</code>
Creates a single item

**Kind**: static method of [<code>Journey</code>](#Journey)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="Journey.saveResults"></a>

### Journey.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: static method of [<code>Journey</code>](#Journey)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>TYPE.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Journey._postRetrieveTasksBulk"></a>

### Journey.\_postRetrieveTasksBulk(metadataMap)
helper for Journey's [saveResults](#Journey.saveResults). Gets executed after retreive of metadata type and

**Kind**: static method of [<code>Journey</code>](#Journey)  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.MetadataTypeMap</code> | key=customer key, value=metadata |

<a name="Journey.postRetrieveTasks"></a>

### Journey.postRetrieveTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
manages post retrieve steps
! BETA RELEASE of journey support (v4.3.0); it so far only resolves a limited amount of dependencies and will likely break during cross-BU deployments!

**Kind**: static method of [<code>Journey</code>](#Journey)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - Array with one metadata object  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="Journey.preDeployTasks"></a>

### Journey.preDeployTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
prepares a TSD for deployment
! BETA RELEASE of journey support (v4.3.0); it so far only resolves a limited amount of dependencies and will likely break during cross-BU deployments!

**Kind**: static method of [<code>Journey</code>](#Journey)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - metadata object  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | of a single TSD |

<a name="Journey.createOrUpdate"></a>

### Journey.createOrUpdate(metadataMap, metadataKey, hasError, metadataToUpdate, metadataToCreate) ⇒ <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code>
helper for [upsert](#MetadataType.upsert)

**Kind**: static method of [<code>Journey</code>](#Journey)  
**Returns**: <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code> - action to take  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.MetadataTypeMap</code> | list of metadata |
| metadataKey | <code>string</code> | key of item we are looking at |
| hasError | <code>boolean</code> | error flag from previous code |
| metadataToUpdate | <code>Array.&lt;TYPE.MetadataTypeItemDiff&gt;</code> | list of items to update |
| metadataToCreate | <code>Array.&lt;TYPE.MetadataTypeItem&gt;</code> | list of items to create |

<a name="List"></a>

## List ⇐ [<code>MetadataType</code>](#MetadataType)
List MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [List](#List) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#List.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveForCache()](#List.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.deleteByKey(customerKey)](#List.deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.postRetrieveTasks(list)](#List.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.parseMetadata(metadata, [parseForCache])](#List.parseMetadata) ⇒ <code>TYPE.MetadataTypeItem</code>

<a name="List.retrieve"></a>

### List.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of Lists

**Kind**: static method of [<code>List</code>](#List)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="List.retrieveForCache"></a>

### List.retrieveForCache() ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: static method of [<code>List</code>](#List)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  
<a name="List.deleteByKey"></a>

### List.deleteByKey(customerKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit

**Kind**: static method of [<code>List</code>](#List)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="List.postRetrieveTasks"></a>

### List.postRetrieveTasks(list) ⇒ <code>TYPE.MetadataTypeItem</code>
manages post retrieve steps

**Kind**: static method of [<code>List</code>](#List)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| list | <code>TYPE.MetadataTypeItem</code> | a single list |

<a name="List.parseMetadata"></a>

### List.parseMetadata(metadata, [parseForCache]) ⇒ <code>TYPE.MetadataTypeItem</code>
parses retrieved Metadata before saving

**Kind**: static method of [<code>List</code>](#List)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single list definition |
| [parseForCache] | <code>boolean</code> | if set to true, the Category ID is kept |

<a name="MetadataType"></a>

## MetadataType
MetadataType class that gets extended by their specific metadata type class.
Provides default functionality that can be overwritten by child metadata type classes

**Kind**: global class  

* [MetadataType](#MetadataType)
    * [.client](#MetadataType.client) : <code>TYPE.SDK</code>
    * [.properties](#MetadataType.properties) : <code>TYPE.Mcdevrc</code>
    * [.subType](#MetadataType.subType) : <code>string</code>
    * [.buObject](#MetadataType.buObject) : <code>TYPE.BuObject</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType.getJsonFromFS) ⇒ <code>TYPE.MetadataTypeMap</code>
    * [.getFieldNamesToRetrieve([additionalFields], [isCaching])](#MetadataType.getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType.deploy) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code>
    * [.postDeployTasks(upsertResults, originalMetadata, createdUpdated)](#MetadataType.postDeployTasks) ⇒ <code>void</code>
    * [.postCreateTasks(metadataEntry, apiResponse)](#MetadataType.postCreateTasks) ⇒ <code>void</code>
    * [.postUpdateTasks(metadataEntry, apiResponse)](#MetadataType.postUpdateTasks) ⇒ <code>void</code>
    * [.postDeployTasks_legacyApi(metadataEntry, apiResponse)](#MetadataType.postDeployTasks_legacyApi) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.setFolderPath(metadata)](#MetadataType.setFolderPath)
    * [.setFolderId(metadata)](#MetadataType.setFolderId)
    * [.retrieve(retrieveDir, [additionalFields], [subTypeArr], [key])](#MetadataType.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveChangelog([additionalFields], [subTypeArr])](#MetadataType.retrieveChangelog) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveForCache([additionalFields], [subTypeArr], [key])](#MetadataType.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType.retrieveAsTemplate) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code>
    * [.retrieveTemplateREST(templateDir, uri, templateVariables, name)](#MetadataType.retrieveTemplateREST) ⇒ <code>Promise.&lt;{metadata: TYPE.MetadataTypeItem, type: string}&gt;</code>
    * [.buildTemplate(retrieveDir, templateDir, key, templateVariables)](#MetadataType.buildTemplate) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType.preDeployTasks) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType.create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType.update) ⇒ <code>void</code>
    * [.refresh()](#MetadataType.refresh) ⇒ <code>void</code>
    * [.execute()](#MetadataType.execute) ⇒ <code>void</code>
    * [.pause()](#MetadataType.pause) ⇒ <code>void</code>
    * [.hasChanged(cachedVersion, metadata, [fieldName])](#MetadataType.hasChanged) ⇒ <code>boolean</code>
    * [.hasChangedGeneric(cachedVersion, metadata, [fieldName], [silent])](#MetadataType.hasChangedGeneric) ⇒ <code>boolean</code>
    * [.upsert(metadataMap, deployDir)](#MetadataType.upsert) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code>
    * [.createOrUpdate(metadataMap, metadataKey, hasError, metadataToUpdate, metadataToCreate)](#MetadataType.createOrUpdate) ⇒ <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType.createREST) ⇒ <code>Promise.&lt;object&gt;</code> \| <code>null</code>
    * [.createSOAP(metadataEntry, [handleOutside])](#MetadataType.createSOAP) ⇒ <code>Promise.&lt;object&gt;</code> \| <code>null</code>
    * [.updateREST(metadataEntry, uri, [httpMethod])](#MetadataType.updateREST) ⇒ <code>Promise.&lt;object&gt;</code> \| <code>null</code>
    * [.updateSOAP(metadataEntry, [handleOutside])](#MetadataType.updateSOAP) ⇒ <code>Promise.&lt;object&gt;</code> \| <code>null</code>
    * [._handleSOAPErrors(ex, msg, [metadataEntry], [handleOutside])](#MetadataType._handleSOAPErrors)
    * [.getSOAPErrorMsg(ex)](#MetadataType.getSOAPErrorMsg) ⇒ <code>string</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [singleRetrieve], [additionalFields])](#MetadataType.retrieveSOAP) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [templateVariables], [singleRetrieve])](#MetadataType.retrieveREST) ⇒ <code>Promise.&lt;{metadata: (TYPE.MetadataTypeMap\|TYPE.MetadataTypeItem), type: string}&gt;</code>
    * [.executeREST(uri, key)](#MetadataType.executeREST) ⇒ <code>Promise.&lt;{key:string, response:string}&gt;</code>
    * [.executeSOAP([metadataEntry])](#MetadataType.executeSOAP) ⇒ <code>Promise.&lt;{key:string, response:object}&gt;</code>
    * [.runDocumentOnRetrieve([singleRetrieve], metadataMap)](#MetadataType.runDocumentOnRetrieve) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.parseResponseBody(body, [singleRetrieve])](#MetadataType.parseResponseBody) ⇒ <code>TYPE.MetadataTypeMap</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType.deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType.removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType.removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType.keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType.keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType.isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType.isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType.saveResults) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code>
    * [.applyTemplateValues(code, templateVariables)](#MetadataType.applyTemplateValues) ⇒ <code>string</code>
    * [.applyTemplateNames(code, templateVariables)](#MetadataType.applyTemplateNames) ⇒ <code>string</code>
    * [.buildDefinitionForNested(templateDir, targetDir, metadata, variables, templateName)](#MetadataType.buildDefinitionForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [.buildTemplateForNested(templateDir, targetDir, metadata, templateVariables, templateName)](#MetadataType.buildTemplateForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType.findSubType) ⇒ <code>Promise.&lt;string&gt;</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType.readSecondaryFolder) ⇒ <code>object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType.buildDefinition) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.getErrorsREST(ex)](#MetadataType.getErrorsREST) ⇒ <code>Array.&lt;string&gt;</code> \| <code>void</code>
    * [.document([metadata], [isDeploy])](#MetadataType.document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType.deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey, [additionalExtensions])](#MetadataType.postDeleteTasks) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.deleteByKeySOAP(customerKey, [overrideKeyField], [handleOutside])](#MetadataType.deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.deleteByKeyREST(url, key, [handleOutside])](#MetadataType.deleteByKeyREST) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType.readBUMetadataForType) ⇒ <code>object</code>
    * [.getFilesToCommit(keyArr)](#MetadataType.getFilesToCommit) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
    * [.getKeysForFixing(metadataMap)](#MetadataType.getKeysForFixing) ⇒ <code>Array.&lt;string&gt;</code>
    * [.getKeysToSetNotifications(metadataMap)](#MetadataType.getKeysToSetNotifications) ⇒ <code>Array.&lt;string&gt;</code>
    * [.updateNotifications()](#MetadataType.updateNotifications) ⇒ <code>Array.&lt;string&gt;</code>

<a name="MetadataType.client"></a>

### MetadataType.client : <code>TYPE.SDK</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.properties"></a>

### MetadataType.properties : <code>TYPE.Mcdevrc</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.subType"></a>

### MetadataType.subType : <code>string</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.buObject"></a>

### MetadataType.buObject : <code>TYPE.BuObject</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.getJsonFromFS"></a>

### MetadataType.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>TYPE.MetadataTypeMap</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>TYPE.MetadataTypeMap</code> - fileName => fileContent map  

| Param | Type | Description |
| --- | --- | --- |
| dir | <code>string</code> | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | do not print errors, used for badKeys() |

<a name="MetadataType.getFieldNamesToRetrieve"></a>

### MetadataType.getFieldNamesToRetrieve([additionalFields], [isCaching]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [isCaching] | <code>boolean</code> | if true, then check if field should be skipped for caching |

<a name="MetadataType.deploy"></a>

### MetadataType.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code>
Deploys metadata

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType.postDeployTasks"></a>

### MetadataType.postDeployTasks(upsertResults, originalMetadata, createdUpdated) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| upsertResults | <code>TYPE.MetadataTypeMap</code> | metadata mapped by their keyField as returned by update/create |
| originalMetadata | <code>TYPE.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |
| createdUpdated | <code>Object</code> | counter representing successful creates/updates |

<a name="MetadataType.postCreateTasks"></a>

### MetadataType.postCreateTasks(metadataEntry, apiResponse) ⇒ <code>void</code>
helper for [createREST](#MetadataType.createREST)

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | a single metadata Entry |
| apiResponse | <code>object</code> | varies depending on the API call |

<a name="MetadataType.postUpdateTasks"></a>

### MetadataType.postUpdateTasks(metadataEntry, apiResponse) ⇒ <code>void</code>
helper for [updateREST](#MetadataType.updateREST)

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | a single metadata Entry |
| apiResponse | <code>object</code> | varies depending on the API call |

<a name="MetadataType.postDeployTasks_legacyApi"></a>

### MetadataType.postDeployTasks\_legacyApi(metadataEntry, apiResponse) ⇒ <code>Promise.&lt;void&gt;</code>
helper for [createREST](#MetadataType.createREST) when legacy API endpoints as these do not return the created item but only their new id

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | a single metadata Entry |
| apiResponse | <code>object</code> | varies depending on the API call |

<a name="MetadataType.postRetrieveTasks"></a>

### MetadataType.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>TYPE.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType.setFolderPath"></a>

### MetadataType.setFolderPath(metadata)
generic script that retrieves the folder path from cache and updates the given metadata with it after retrieve

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="MetadataType.setFolderId"></a>

### MetadataType.setFolderId(metadata)
generic script that retrieves the folder ID from cache and updates the given metadata with it before deploy

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="MetadataType.retrieve"></a>

### MetadataType.retrieve(retrieveDir, [additionalFields], [subTypeArr], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subTypeArr] | <code>Array.&lt;string&gt;</code> | optionally limit to a single subtype |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="MetadataType.retrieveChangelog"></a>

### MetadataType.retrieveChangelog([additionalFields], [subTypeArr]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subTypeArr] | <code>Array.&lt;string&gt;</code> | optionally limit to a single subtype |

<a name="MetadataType.retrieveForCache"></a>

### MetadataType.retrieveForCache([additionalFields], [subTypeArr], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subTypeArr] | <code>Array.&lt;string&gt;</code> | optionally limit to a single subtype |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="MetadataType.retrieveAsTemplate"></a>

### MetadataType.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType.retrieveTemplateREST"></a>

### MetadataType.retrieveTemplateREST(templateDir, uri, templateVariables, name) ⇒ <code>Promise.&lt;{metadata: TYPE.MetadataTypeItem, type: string}&gt;</code>
Retrieve a specific Script by Name

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.MetadataTypeItem, type: string}&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| name | <code>string</code> | name (not key) of the metadata item |

<a name="MetadataType.buildTemplate"></a>

### MetadataType.buildTemplate(retrieveDir, templateDir, key, templateVariables) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code> - single metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| templateDir | <code>string</code> | (List of) Directory where built definitions will be saved |
| key | <code>string</code> | name of the metadata file |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType.preDeployTasks"></a>

### MetadataType.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType.create"></a>

### MetadataType.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType.update"></a>

### MetadataType.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>TYPE.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType.refresh"></a>

### MetadataType.refresh() ⇒ <code>void</code>
Abstract refresh method that needs to be implemented in child metadata type

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.execute"></a>

### MetadataType.execute() ⇒ <code>void</code>
Abstract execute method that needs to be implemented in child metadata type

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.pause"></a>

### MetadataType.pause() ⇒ <code>void</code>
Abstract pause method that needs to be implemented in child metadata type

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.hasChanged"></a>

### MetadataType.hasChanged(cachedVersion, metadata, [fieldName]) ⇒ <code>boolean</code>
test if metadata was actually changed or not to potentially skip it during deployment

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - true if metadata was changed  

| Param | Type | Description |
| --- | --- | --- |
| cachedVersion | <code>TYPE.MetadataTypeItem</code> | cached version from the server |
| metadata | <code>TYPE.MetadataTypeItem</code> | item to upload |
| [fieldName] | <code>string</code> | optional field name to use for identifying the record in logs |

<a name="MetadataType.hasChangedGeneric"></a>

### MetadataType.hasChangedGeneric(cachedVersion, metadata, [fieldName], [silent]) ⇒ <code>boolean</code>
test if metadata was actually changed or not to potentially skip it during deployment

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - true on first identified deviation or false if none are found  

| Param | Type | Description |
| --- | --- | --- |
| cachedVersion | <code>TYPE.MetadataTypeItem</code> | cached version from the server |
| metadata | <code>TYPE.MetadataTypeItem</code> | item to upload |
| [fieldName] | <code>string</code> | optional field name to use for identifying the record in logs |
| [silent] | <code>boolean</code> | optionally suppress logging |

<a name="MetadataType.upsert"></a>

### MetadataType.upsert(metadataMap, deployDir) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType.createOrUpdate"></a>

### MetadataType.createOrUpdate(metadataMap, metadataKey, hasError, metadataToUpdate, metadataToCreate) ⇒ <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code>
helper for [upsert](#MetadataType.upsert)

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code> - action to take  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.MetadataTypeMap</code> | list of metadata |
| metadataKey | <code>string</code> | key of item we are looking at |
| hasError | <code>boolean</code> | error flag from previous code |
| metadataToUpdate | <code>Array.&lt;TYPE.MetadataTypeItemDiff&gt;</code> | list of items to update |
| metadataToCreate | <code>Array.&lt;TYPE.MetadataTypeItem&gt;</code> | list of items to create |

<a name="MetadataType.createREST"></a>

### MetadataType.createREST(metadataEntry, uri) ⇒ <code>Promise.&lt;object&gt;</code> \| <code>null</code>
Creates a single metadata entry via REST

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;object&gt;</code> \| <code>null</code> - Promise of API response or null in case of an error  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType.createSOAP"></a>

### MetadataType.createSOAP(metadataEntry, [handleOutside]) ⇒ <code>Promise.&lt;object&gt;</code> \| <code>null</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;object&gt;</code> \| <code>null</code> - Promise of API response or null in case of an error  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | single metadata entry |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType.updateREST"></a>

### MetadataType.updateREST(metadataEntry, uri, [httpMethod]) ⇒ <code>Promise.&lt;object&gt;</code> \| <code>null</code>
Updates a single metadata entry via REST

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;object&gt;</code> \| <code>null</code> - Promise of API response or null in case of an error  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> |  | a single metadata Entry |
| uri | <code>string</code> |  | rest endpoint for PATCH |
| [httpMethod] | <code>&#x27;patch&#x27;</code> \| <code>&#x27;post&#x27;</code> \| <code>&#x27;put&#x27;</code> | <code>patch</code> | defaults to 'patch'; some update requests require PUT instead of PATCH |

<a name="MetadataType.updateSOAP"></a>

### MetadataType.updateSOAP(metadataEntry, [handleOutside]) ⇒ <code>Promise.&lt;object&gt;</code> \| <code>null</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;object&gt;</code> \| <code>null</code> - Promise of API response or null in case of an error  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | single metadata entry |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType._handleSOAPErrors"></a>

### MetadataType.\_handleSOAPErrors(ex, msg, [metadataEntry], [handleOutside])
**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Error</code> | error that occured |
| msg | <code>&#x27;creating&#x27;</code> \| <code>&#x27;updating&#x27;</code> | what to print in the log |
| [metadataEntry] | <code>TYPE.MetadataTypeItem</code> | single metadata entry |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType.getSOAPErrorMsg"></a>

### MetadataType.getSOAPErrorMsg(ex) ⇒ <code>string</code>
helper for [_handleSOAPErrors](#MetadataType._handleSOAPErrors)

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>string</code> - error message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Error</code> | error that occured |

<a name="MetadataType.retrieveSOAP"></a>

### MetadataType.retrieveSOAP(retrieveDir, [requestParams], [singleRetrieve], [additionalFields]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>TYPE.SoapRequestParams</code> | required for the specific request (filter for example) |
| [singleRetrieve] | <code>string</code> \| <code>number</code> | key of single item to filter by |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType.retrieveREST"></a>

### MetadataType.retrieveREST(retrieveDir, uri, [templateVariables], [singleRetrieve]) ⇒ <code>Promise.&lt;{metadata: (TYPE.MetadataTypeMap\|TYPE.MetadataTypeItem), type: string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata: (TYPE.MetadataTypeMap\|TYPE.MetadataTypeItem), type: string}&gt;</code> - Promise of item map (single item for templated result)  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [templateVariables] | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| [singleRetrieve] | <code>string</code> \| <code>number</code> | key of single item to filter by |

<a name="MetadataType.executeREST"></a>

### MetadataType.executeREST(uri, key) ⇒ <code>Promise.&lt;{key:string, response:string}&gt;</code>
Used to execute a query/automation etc.

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{key:string, response:string}&gt;</code> - metadata key and API response (OK or error)  

| Param | Type | Description |
| --- | --- | --- |
| uri | <code>string</code> | REST endpoint where the POST request should be sent |
| key | <code>string</code> | item key |

<a name="MetadataType.executeSOAP"></a>

### MetadataType.executeSOAP([metadataEntry]) ⇒ <code>Promise.&lt;{key:string, response:object}&gt;</code>
Used to execute a query/automation etc.

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{key:string, response:object}&gt;</code> - metadata key and API response  

| Param | Type | Description |
| --- | --- | --- |
| [metadataEntry] | <code>TYPE.MetadataTypeItem</code> | single metadata entry |

<a name="MetadataType.runDocumentOnRetrieve"></a>

### MetadataType.runDocumentOnRetrieve([singleRetrieve], metadataMap) ⇒ <code>Promise.&lt;void&gt;</code>
helper for [retrieveREST](#MetadataType.retrieveREST) and [retrieveSOAP](#MetadataType.retrieveSOAP)

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| [singleRetrieve] | <code>string</code> \| <code>number</code> | key of single item to filter by |
| metadataMap | <code>TYPE.MetadataTypeMap</code> | saved metadata |

<a name="MetadataType.parseResponseBody"></a>

### MetadataType.parseResponseBody(body, [singleRetrieve]) ⇒ <code>TYPE.MetadataTypeMap</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>TYPE.MetadataTypeMap</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>object</code> | json of response body |
| [singleRetrieve] | <code>string</code> \| <code>number</code> | key of single item to filter by |

<a name="MetadataType.deleteFieldByDefinition"></a>

### MetadataType.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType.removeNotCreateableFields"></a>

### MetadataType.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType.removeNotUpdateableFields"></a>

### MetadataType.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType.keepTemplateFields"></a>

### MetadataType.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType.keepRetrieveFields"></a>

### MetadataType.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType.isFiltered"></a>

### MetadataType.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | metadata entry |
| [include] | <code>boolean</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType.isFilteredFolder"></a>

### MetadataType.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>object</code> | metadata entry |
| [include] | <code>boolean</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType.saveResults"></a>

### MetadataType.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>TYPE.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType.applyTemplateValues"></a>

### MetadataType.applyTemplateValues(code, templateVariables) ⇒ <code>string</code>
helper for [buildDefinitionForNested](#MetadataType.buildDefinitionForNested)
searches extracted file for template variable names and applies the market values

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>string</code> - code with markets applied  

| Param | Type | Description |
| --- | --- | --- |
| code | <code>string</code> | code from extracted code |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType.applyTemplateNames"></a>

### MetadataType.applyTemplateNames(code, templateVariables) ⇒ <code>string</code>
helper for [buildTemplateForNested](#MetadataType.buildTemplateForNested)
searches extracted file for template variable values and applies the market variable names

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>string</code> - code with markets applied  

| Param | Type | Description |
| --- | --- | --- |
| code | <code>string</code> | code from extracted code |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType.buildDefinitionForNested"></a>

### MetadataType.buildDefinitionForNested(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [buildDefinition](#MetadataType.buildDefinition)
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>TYPE.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType.buildTemplateForNested"></a>

### MetadataType.buildTemplateForNested(templateDir, targetDir, metadata, templateVariables, templateName) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [buildTemplate](#MetadataType.buildTemplate)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.MetadataTypeItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType.findSubType"></a>

### MetadataType.findSubType(templateDir, templateName) ⇒ <code>Promise.&lt;string&gt;</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;string&gt;</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType.readSecondaryFolder"></a>

### MetadataType.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>object</code>
optional method used for some types to try a different folder structure

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType.buildDefinition"></a>

### MetadataType.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType.getErrorsREST"></a>

### MetadataType.getErrorsREST(ex) ⇒ <code>Array.&lt;string&gt;</code> \| <code>void</code>
Standardizes a check for multiple messages

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Array.&lt;string&gt;</code> \| <code>void</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>object</code> | response payload from REST API |

<a name="MetadataType.document"></a>

### MetadataType.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>TYPE.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType.deleteByKey"></a>

### MetadataType.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType.postDeleteTasks"></a>

### MetadataType.postDeleteTasks(customerKey, [additionalExtensions]) ⇒ <code>Promise.&lt;void&gt;</code>
clean up after deleting a metadata item

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;void&gt;</code> - - Promise  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |
| [additionalExtensions] | <code>Array.&lt;string&gt;</code> | additional file extensions to delete on top of `${this.definition.type}-meta.json` |

<a name="MetadataType.deleteByKeySOAP"></a>

### MetadataType.deleteByKeySOAP(customerKey, [overrideKeyField], [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [overrideKeyField] | <code>string</code> | optionally change the name of the key field if the api uses a different name |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType.deleteByKeyREST"></a>

### MetadataType.deleteByKeyREST(url, key, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | endpoint |
| key | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType.readBUMetadataForType"></a>

### MetadataType.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>object</code>
Returns metadata of a business unit that is saved locally

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>object</code> - Metadata of BU in local directory  

| Param | Type | Description |
| --- | --- | --- |
| readDir | <code>string</code> | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>object</code> | Metadata of BU in local directory |

<a name="MetadataType.getFilesToCommit"></a>

### MetadataType.getFilesToCommit(keyArr) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
should return only the json for all but asset, query and script that are saved as multiple files
additionally, the documentation for dataExtension and automation should be returned

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - list of all files that need to be committed in a flat array ['path/file1.ext', 'path/file2.ext']  

| Param | Type | Description |
| --- | --- | --- |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="MetadataType.getKeysForFixing"></a>

### MetadataType.getKeysForFixing(metadataMap) ⇒ <code>Array.&lt;string&gt;</code>
**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Array.&lt;string&gt;</code> - list of keys  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.MetadataTypeMap</code> | metadata mapped by their keyField |

<a name="MetadataType.getKeysToSetNotifications"></a>

### MetadataType.getKeysToSetNotifications(metadataMap) ⇒ <code>Array.&lt;string&gt;</code>
Abstract function to get a list of keys where notification email address should be updated

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Array.&lt;string&gt;</code> - list of keys  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.MetadataTypeMap</code> | metadata mapped by their keyField |

<a name="MetadataType.updateNotifications"></a>

### MetadataType.updateNotifications() ⇒ <code>Array.&lt;string&gt;</code>
Abstract updateNotifications method that needs to be implemented in child metadata type

**Kind**: static method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Array.&lt;string&gt;</code> - returns keys of items where notification email address was set  
<a name="MobileCode"></a>

## MobileCode ⇐ [<code>MetadataType</code>](#MetadataType)
MobileCode MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [MobileCode](#MobileCode) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#MobileCode.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveForCache()](#MobileCode.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>

<a name="MobileCode.retrieve"></a>

### MobileCode.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata of Mobile Keywords
Endpoint /legacy/v1/beta/mobile/code/ return all Mobile Codes with all details.

**Kind**: static method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="MobileCode.retrieveForCache"></a>

### MobileCode.retrieveForCache() ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves event definition metadata for caching

**Kind**: static method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  
<a name="MobileKeyword"></a>

## MobileKeyword ⇐ [<code>MetadataType</code>](#MetadataType)
MobileKeyword MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [MobileKeyword](#MobileKeyword) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#MobileKeyword.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> \| <code>void</code>
    * [.parseResponseBody(body, [singleRetrieve])](#MobileKeyword.parseResponseBody) ⇒ <code>TYPE.MetadataTypeMap</code>
    * [.createOrUpdate(metadataMap, metadataKey, hasError, metadataToUpdate, metadataToCreate)](#MobileKeyword.createOrUpdate) ⇒ <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code>
    * [.retrieveForCache(_, __, [key])](#MobileKeyword.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveAsTemplate(templateDir, key, templateVariables)](#MobileKeyword.retrieveAsTemplate) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code>
    * [.create(metadata)](#MobileKeyword.create) ⇒ <code>Promise</code>
    * [.update(metadata)](#MobileKeyword.update) ⇒ <code>Promise</code>
    * [.postRetrieveTasks(metadata)](#MobileKeyword.postRetrieveTasks) ⇒ <code>TYPE.CodeExtractItem</code> \| <code>TYPE.MetadataTypeItem</code> \| <code>void</code>
    * [.prepExtractedCode(metadataScript)](#MobileKeyword.prepExtractedCode) ⇒ <code>Object</code>
    * [.buildDefinitionForNested(templateDir, targetDir, metadata, templateVariables, templateName)](#MobileKeyword.buildDefinitionForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [.buildTemplateForNested(templateDir, targetDir, metadata, templateVariables, templateName)](#MobileKeyword.buildTemplateForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [._buildForNested(templateDir, targetDir, metadata, templateVariables, templateName, mode)](#MobileKeyword._buildForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MobileKeyword.preDeployTasks) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code>
    * [.postCreateTasks(metadataEntry, apiResponse)](#MobileKeyword.postCreateTasks) ⇒ <code>void</code>
    * [.postUpdateTasks(metadataEntry, apiResponse)](#MobileKeyword.postUpdateTasks) ⇒ <code>void</code>
    * [._mergeCode(metadata, deployDir, [templateName])](#MobileKeyword._mergeCode) ⇒ <code>Promise.&lt;string&gt;</code>
    * [.deleteByKey(key)](#MobileKeyword.deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.postDeleteTasks(customerKey)](#MobileKeyword.postDeleteTasks) ⇒ <code>void</code>
    * [.getFilesToCommit(keyArr)](#MobileKeyword.getFilesToCommit) ⇒ <code>Array.&lt;string&gt;</code>

<a name="MobileKeyword.retrieve"></a>

### MobileKeyword.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> \| <code>void</code>
Retrieves Metadata of Mobile Keywords
Endpoint /legacy/v1/beta/mobile/keyword/ return all Mobile Keywords with all details.

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> \| <code>void</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="MobileKeyword.parseResponseBody"></a>

### MobileKeyword.parseResponseBody(body, [singleRetrieve]) ⇒ <code>TYPE.MetadataTypeMap</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>TYPE.MetadataTypeMap</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>object</code> | json of response body |
| [singleRetrieve] | <code>string</code> \| <code>number</code> | key of single item to filter by |

<a name="MobileKeyword.createOrUpdate"></a>

### MobileKeyword.createOrUpdate(metadataMap, metadataKey, hasError, metadataToUpdate, metadataToCreate) ⇒ <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code>
helper for [upsert](#MetadataType.upsert)

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>&#x27;create&#x27;</code> \| <code>&#x27;update&#x27;</code> \| <code>&#x27;skip&#x27;</code> - action to take  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.MetadataTypeMap</code> | list of metadata |
| metadataKey | <code>string</code> | key of item we are looking at |
| hasError | <code>boolean</code> | error flag from previous code |
| metadataToUpdate | <code>Array.&lt;TYPE.MetadataTypeItemDiff&gt;</code> | list of items to update |
| metadataToCreate | <code>Array.&lt;TYPE.MetadataTypeItem&gt;</code> | list of items to create |

<a name="MobileKeyword.retrieveForCache"></a>

### MobileKeyword.retrieveForCache(_, __, [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves event definition metadata for caching

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| _ | <code>void</code> | parameter not used |
| __ | <code>void</code> | parameter not used |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="MobileKeyword.retrieveAsTemplate"></a>

### MobileKeyword.retrieveAsTemplate(templateDir, key, templateVariables) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code>
retrieve an item and create a template from it

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeItemObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| key | <code>string</code> | name of the metadata file |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MobileKeyword.create"></a>

### MobileKeyword.create(metadata) ⇒ <code>Promise</code>
Creates a single item

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="MobileKeyword.update"></a>

### MobileKeyword.update(metadata) ⇒ <code>Promise</code>
Updates a single item

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="MobileKeyword.postRetrieveTasks"></a>

### MobileKeyword.postRetrieveTasks(metadata) ⇒ <code>TYPE.CodeExtractItem</code> \| <code>TYPE.MetadataTypeItem</code> \| <code>void</code>
manages post retrieve steps

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>TYPE.CodeExtractItem</code> \| <code>TYPE.MetadataTypeItem</code> \| <code>void</code> - Array with one metadata object and one ssjs string; or single metadata object; nothing if filtered  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="MobileKeyword.prepExtractedCode"></a>

### MobileKeyword.prepExtractedCode(metadataScript) ⇒ <code>Object</code>
helper for [postRetrieveTasks](#MobileKeyword.postRetrieveTasks) and [_buildForNested](#MobileKeyword._buildForNested)

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Object</code> - returns found extension and file content  

| Param | Type | Description |
| --- | --- | --- |
| metadataScript | <code>string</code> | the code of the file |

<a name="MobileKeyword.buildDefinitionForNested"></a>

### MobileKeyword.buildDefinitionForNested(templateDir, targetDir, metadata, templateVariables, templateName) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [buildDefinition](#MetadataType.buildDefinition)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.MetadataTypeItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MobileKeyword.buildTemplateForNested"></a>

### MobileKeyword.buildTemplateForNested(templateDir, targetDir, metadata, templateVariables, templateName) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [buildTemplate](#MetadataType.buildTemplate)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.MetadataTypeItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

**Example**  
```js
scripts are saved as 1 json and 1 ssjs file. both files need to be run through templating
```
<a name="MobileKeyword._buildForNested"></a>

### MobileKeyword.\_buildForNested(templateDir, targetDir, metadata, templateVariables, templateName, mode) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [buildTemplateForNested](#MobileKeyword.buildTemplateForNested) / [buildDefinitionForNested](#MobileKeyword.buildDefinitionForNested)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.MetadataTypeItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |
| mode | <code>&#x27;definition&#x27;</code> \| <code>&#x27;template&#x27;</code> | defines what we use this helper for |

<a name="MobileKeyword.preDeployTasks"></a>

### MobileKeyword.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code>
prepares an event definition for deployment

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single MobileKeyword |
| deployDir | <code>string</code> | directory of deploy files |

<a name="MobileKeyword.postCreateTasks"></a>

### MobileKeyword.postCreateTasks(metadataEntry, apiResponse) ⇒ <code>void</code>
helper for [createREST](#MetadataType.createREST)

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | a single metadata Entry |
| apiResponse | <code>object</code> | varies depending on the API call |

<a name="MobileKeyword.postUpdateTasks"></a>

### MobileKeyword.postUpdateTasks(metadataEntry, apiResponse) ⇒ <code>void</code>
helper for [updateREST](#MetadataType.updateREST)

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | a single metadata Entry |
| apiResponse | <code>object</code> | varies depending on the API call |

<a name="MobileKeyword._mergeCode"></a>

### MobileKeyword.\_mergeCode(metadata, deployDir, [templateName]) ⇒ <code>Promise.&lt;string&gt;</code>
helper for [preDeployTasks](#MobileKeyword.preDeployTasks) that loads extracted code content back into JSON

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;string&gt;</code> - content for metadata.script  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single definition |
| deployDir | <code>string</code> | directory of deploy files |
| [templateName] | <code>string</code> | name of the template used to built defintion (prior applying templating) |

<a name="MobileKeyword.deleteByKey"></a>

### MobileKeyword.deleteByKey(key) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> | Identifier of item |

<a name="MobileKeyword.postDeleteTasks"></a>

### MobileKeyword.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MobileKeyword.getFilesToCommit"></a>

### MobileKeyword.getFilesToCommit(keyArr) ⇒ <code>Array.&lt;string&gt;</code>
should return only the json for all but asset, query and script that are saved as multiple files
additionally, the documentation for dataExtension and automation should be returned

**Kind**: static method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Array.&lt;string&gt;</code> - list of all files that need to be committed in a flat array ['path/file1.ext', 'path/file2.ext']  

| Param | Type | Description |
| --- | --- | --- |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="MobileMessage"></a>

## MobileMessage ⇐ [<code>MetadataType</code>](#MetadataType)
MobileMessage MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [MobileMessage](#MobileMessage) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#MobileMessage.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> \| <code>void</code>
    * [.retrieveForCache(_, __, [key])](#MobileMessage.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.update(metadata)](#MobileMessage.update) ⇒ <code>Promise</code>
    * [.create(metadata)](#MobileMessage.create) ⇒ <code>Promise</code>
    * [._mergeCode(metadata, deployDir, [templateName])](#MobileMessage._mergeCode) ⇒ <code>Promise.&lt;string&gt;</code>
    * [.prepExtractedCode(code)](#MobileMessage.prepExtractedCode) ⇒ <code>Object</code>
    * [.getFilesToCommit(keyArr)](#MobileMessage.getFilesToCommit) ⇒ <code>Array.&lt;string&gt;</code>
    * [.postRetrieveTasks(metadata)](#MobileMessage.postRetrieveTasks) ⇒ <code>TYPE.CodeExtractItem</code>
    * [.preDeployTasks(metadata, deployDir)](#MobileMessage.preDeployTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.postCreateTasks(metadataEntry, apiResponse)](#MobileMessage.postCreateTasks) ⇒ <code>void</code>
    * [.postUpdateTasks(metadataEntry, apiResponse)](#MobileMessage.postUpdateTasks) ⇒ <code>void</code>
    * [.buildDefinitionForNested(templateDir, targetDir, metadata, templateVariables, templateName)](#MobileMessage.buildDefinitionForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [.buildTemplateForNested(templateDir, targetDir, metadata, templateVariables, templateName)](#MobileMessage.buildTemplateForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [._buildForNested(templateDir, targetDir, metadata, templateVariables, templateName, mode)](#MobileMessage._buildForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [.deleteByKey(id)](#MobileMessage.deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>

<a name="MobileMessage.retrieve"></a>

### MobileMessage.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> \| <code>void</code>
Retrieves Metadata of Mobile Keywords

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> \| <code>void</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="MobileMessage.retrieveForCache"></a>

### MobileMessage.retrieveForCache(_, __, [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves event definition metadata for caching

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| _ | <code>void</code> | parameter not used |
| __ | <code>void</code> | parameter not used |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="MobileMessage.update"></a>

### MobileMessage.update(metadata) ⇒ <code>Promise</code>
Updates a single item

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="MobileMessage.create"></a>

### MobileMessage.create(metadata) ⇒ <code>Promise</code>
Creates a single item

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="MobileMessage._mergeCode"></a>

### MobileMessage.\_mergeCode(metadata, deployDir, [templateName]) ⇒ <code>Promise.&lt;string&gt;</code>
helper for [preDeployTasks](#MobileMessage.preDeployTasks) that loads extracted code content back into JSON

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  
**Returns**: <code>Promise.&lt;string&gt;</code> - code  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single definition |
| deployDir | <code>string</code> | directory of deploy files |
| [templateName] | <code>string</code> | name of the template used to built defintion (prior applying templating) |

<a name="MobileMessage.prepExtractedCode"></a>

### MobileMessage.prepExtractedCode(code) ⇒ <code>Object</code>
helper for [postRetrieveTasks](#MobileMessage.postRetrieveTasks) and [_buildForNested](#MobileMessage._buildForNested)

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  
**Returns**: <code>Object</code> - returns found extension and file content  

| Param | Type | Description |
| --- | --- | --- |
| code | <code>string</code> | the code of the file |

<a name="MobileMessage.getFilesToCommit"></a>

### MobileMessage.getFilesToCommit(keyArr) ⇒ <code>Array.&lt;string&gt;</code>
should return only the json for all but asset, query and script that are saved as multiple files
additionally, the documentation for dataExtension and automation should be returned

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  
**Returns**: <code>Array.&lt;string&gt;</code> - list of all files that need to be committed in a flat array ['path/file1.ext', 'path/file2.ext']  

| Param | Type | Description |
| --- | --- | --- |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="MobileMessage.postRetrieveTasks"></a>

### MobileMessage.postRetrieveTasks(metadata) ⇒ <code>TYPE.CodeExtractItem</code>
manages post retrieve steps

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  
**Returns**: <code>TYPE.CodeExtractItem</code> - Array with one metadata object and one query string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single query |

<a name="MobileMessage.preDeployTasks"></a>

### MobileMessage.preDeployTasks(metadata, deployDir) ⇒ <code>TYPE.MetadataTypeItem</code>
prepares an event definition for deployment

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single MobileMessage |
| deployDir | <code>string</code> | directory of deploy files |

<a name="MobileMessage.postCreateTasks"></a>

### MobileMessage.postCreateTasks(metadataEntry, apiResponse) ⇒ <code>void</code>
helper for [createREST](#MetadataType.createREST)

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | a single metadata Entry |
| apiResponse | <code>object</code> | varies depending on the API call |

<a name="MobileMessage.postUpdateTasks"></a>

### MobileMessage.postUpdateTasks(metadataEntry, apiResponse) ⇒ <code>void</code>
helper for [updateREST](#MetadataType.updateREST)

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.MetadataTypeItem</code> | a single metadata Entry |
| apiResponse | <code>object</code> | varies depending on the API call |

<a name="MobileMessage.buildDefinitionForNested"></a>

### MobileMessage.buildDefinitionForNested(templateDir, targetDir, metadata, templateVariables, templateName) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [buildDefinition](#MetadataType.buildDefinition)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.MetadataTypeItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MobileMessage.buildTemplateForNested"></a>

### MobileMessage.buildTemplateForNested(templateDir, targetDir, metadata, templateVariables, templateName) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [buildTemplate](#MetadataType.buildTemplate)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.MetadataTypeItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

**Example**  
```js
scripts are saved as 1 json and 1 ssjs file. both files need to be run through templating
```
<a name="MobileMessage._buildForNested"></a>

### MobileMessage.\_buildForNested(templateDir, targetDir, metadata, templateVariables, templateName, mode) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [buildTemplateForNested](#MobileMessage.buildTemplateForNested) / [buildDefinitionForNested](#MobileMessage.buildDefinitionForNested)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.MetadataTypeItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |
| mode | <code>&#x27;definition&#x27;</code> \| <code>&#x27;template&#x27;</code> | defines what we use this helper for |

<a name="MobileMessage.deleteByKey"></a>

### MobileMessage.deleteByKey(id) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit
! the endpoint expects the ID and not a key but for mcdev in this case key==id

**Kind**: static method of [<code>MobileMessage</code>](#MobileMessage)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| id | <code>string</code> | Identifier of item |

<a name="Query"></a>

## Query ⇐ [<code>MetadataType</code>](#MetadataType)
Query MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Query](#Query) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#Query.retrieve) ⇒ <code>Promise.&lt;{metadata: TYPE.QueryMap, type: string}&gt;</code>
    * [.execute(keyArr)](#Query.execute) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
    * [.retrieveForCache()](#Query.retrieveForCache) ⇒ <code>Promise.&lt;{metadata: TYPE.QueryMap, type: string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#Query.retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata: Query, type: string}&gt;</code>
    * [.postRetrieveTasks(metadata)](#Query.postRetrieveTasks) ⇒ <code>TYPE.CodeExtractItem</code>
    * [.create(query)](#Query.create) ⇒ <code>Promise</code>
    * [.update(query)](#Query.update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata, deployDir)](#Query.preDeployTasks) ⇒ <code>Promise.&lt;TYPE.QueryItem&gt;</code>
    * [.applyTemplateValues(code, templateVariables)](#Query.applyTemplateValues) ⇒ <code>string</code>
    * [.buildDefinitionForNested(templateDir, targetDir, metadata, templateVariables, templateName)](#Query.buildDefinitionForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [.buildTemplateForNested(templateDir, targetDir, metadata, templateVariables, templateName)](#Query.buildTemplateForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [.getFilesToCommit(keyArr)](#Query.getFilesToCommit) ⇒ <code>Array.&lt;string&gt;</code>
    * [.getErrorsREST(ex)](#Query.getErrorsREST) ⇒ <code>Array.&lt;string&gt;</code> \| <code>void</code>
    * [.deleteByKey(customerKey)](#Query.deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#Query.postDeleteTasks) ⇒ <code>void</code>
    * [.postDeployTasks(upsertResults)](#Query.postDeployTasks)

<a name="Query.retrieve"></a>

### Query.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;{metadata: TYPE.QueryMap, type: string}&gt;</code>
Retrieves Metadata of queries

**Kind**: static method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.QueryMap, type: string}&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="Query.execute"></a>

### Query.execute(keyArr) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
a function to start query execution via API

**Kind**: static method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - Returns list of keys that were executed successfully  

| Param | Type | Description |
| --- | --- | --- |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="Query.retrieveForCache"></a>

### Query.retrieveForCache() ⇒ <code>Promise.&lt;{metadata: TYPE.QueryMap, type: string}&gt;</code>
Retrieves query metadata for caching

**Kind**: static method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.QueryMap, type: string}&gt;</code> - Promise of metadata  
<a name="Query.retrieveAsTemplate"></a>

### Query.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;{metadata: Query, type: string}&gt;</code>
Retrieve a specific Query by Name

**Kind**: static method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;{metadata: Query, type: string}&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Query.postRetrieveTasks"></a>

### Query.postRetrieveTasks(metadata) ⇒ <code>TYPE.CodeExtractItem</code>
manages post retrieve steps

**Kind**: static method of [<code>Query</code>](#Query)  
**Returns**: <code>TYPE.CodeExtractItem</code> - Array with one metadata object and one query string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.QueryItem</code> | a single query |

<a name="Query.create"></a>

### Query.create(query) ⇒ <code>Promise</code>
Creates a single query

**Kind**: static method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| query | <code>TYPE.QueryItem</code> | a single query |

<a name="Query.update"></a>

### Query.update(query) ⇒ <code>Promise</code>
Updates a single query

**Kind**: static method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| query | <code>TYPE.QueryItem</code> | a single query |

<a name="Query.preDeployTasks"></a>

### Query.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;TYPE.QueryItem&gt;</code>
prepares a Query for deployment

**Kind**: static method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;TYPE.QueryItem&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.QueryItem</code> | a single query activity |
| deployDir | <code>string</code> | directory of deploy files |

<a name="Query.applyTemplateValues"></a>

### Query.applyTemplateValues(code, templateVariables) ⇒ <code>string</code>
helper for [buildDefinitionForNested](#Query.buildDefinitionForNested)
searches extracted SQL file for template variables and applies the market values

**Kind**: static method of [<code>Query</code>](#Query)  
**Returns**: <code>string</code> - code with markets applied  

| Param | Type | Description |
| --- | --- | --- |
| code | <code>string</code> | code from extracted code |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Query.buildDefinitionForNested"></a>

### Query.buildDefinitionForNested(templateDir, targetDir, metadata, templateVariables, templateName) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [buildDefinition](#MetadataType.buildDefinition)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.QueryItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="Query.buildTemplateForNested"></a>

### Query.buildTemplateForNested(templateDir, targetDir, metadata, templateVariables, templateName) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [buildTemplate](#MetadataType.buildTemplate)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.QueryItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

**Example**  
```js
queries are saved as 1 json and 1 sql file. both files need to be run through templating
```
<a name="Query.getFilesToCommit"></a>

### Query.getFilesToCommit(keyArr) ⇒ <code>Array.&lt;string&gt;</code>
should return only the json for all but asset, query and script that are saved as multiple files
additionally, the documentation for dataExtension and automation should be returned

**Kind**: static method of [<code>Query</code>](#Query)  
**Returns**: <code>Array.&lt;string&gt;</code> - list of all files that need to be committed in a flat array ['path/file1.ext', 'path/file2.ext']  

| Param | Type | Description |
| --- | --- | --- |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="Query.getErrorsREST"></a>

### Query.getErrorsREST(ex) ⇒ <code>Array.&lt;string&gt;</code> \| <code>void</code>
Standardizes a check for multiple messages but adds query specific filters to error texts

**Kind**: static method of [<code>Query</code>](#Query)  
**Returns**: <code>Array.&lt;string&gt;</code> \| <code>void</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>object</code> | response payload from REST API |

<a name="Query.deleteByKey"></a>

### Query.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: static method of [<code>Query</code>](#Query)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="Query.postDeleteTasks"></a>

### Query.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: static method of [<code>Query</code>](#Query)  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="Query.postDeployTasks"></a>

### Query.postDeployTasks(upsertResults)
Gets executed after deployment of metadata type

**Kind**: static method of [<code>Query</code>](#Query)  

| Param | Type | Description |
| --- | --- | --- |
| upsertResults | <code>TYPE.MetadataTypeMap</code> | metadata mapped by their keyField as returned by update/create |

<a name="Role"></a>

## Role ⇐ [<code>MetadataType</code>](#MetadataType)
ImportFile MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Role](#Role) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, _, [___], [key])](#Role.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.preDeployTasks(metadata)](#Role.preDeployTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.create(metadata)](#Role.create) ⇒ <code>Promise</code>
    * [.update(metadata)](#Role.update) ⇒ <code>Promise</code>
    * [.document([metadata])](#Role.document) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._traverseRoles(role, element, [permission], [isAllowed])](#Role._traverseRoles) ⇒ <code>void</code>

<a name="Role.retrieve"></a>

### Role.retrieve(retrieveDir, _, [___], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: static method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Metadata store object  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| _ | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [___] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="Role.preDeployTasks"></a>

### Role.preDeployTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
Gets executed before deploying metadata

**Kind**: static method of [<code>Role</code>](#Role)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single metadata item |

<a name="Role.create"></a>

### Role.create(metadata) ⇒ <code>Promise</code>
Create a single Role.

**Kind**: static method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | single metadata entry |

<a name="Role.update"></a>

### Role.update(metadata) ⇒ <code>Promise</code>
Updates a single Role.

**Kind**: static method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | single metadata entry |

<a name="Role.document"></a>

### Role.document([metadata]) ⇒ <code>Promise.&lt;void&gt;</code>
Creates markdown documentation of all roles

**Kind**: static method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>TYPE.MetadataTypeMap</code> | role definitions |

<a name="Role._traverseRoles"></a>

### Role.\_traverseRoles(role, element, [permission], [isAllowed]) ⇒ <code>void</code>
iterates through permissions to output proper row-names for nested permissionss

**Kind**: static method of [<code>Role</code>](#Role)  

| Param | Type | Description |
| --- | --- | --- |
| role | <code>string</code> | name of the user role |
| element | <code>object</code> | data of the permission |
| [permission] | <code>string</code> | name of the permission |
| [isAllowed] | <code>string</code> | "true" / "false" from the |

<a name="Script"></a>

## Script ⇐ [<code>MetadataType</code>](#MetadataType)
Script MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Script](#Script) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#Script.retrieve) ⇒ <code>Promise.&lt;{metadata: TYPE.ScriptMap, type: string}&gt;</code>
    * [.retrieveForCache()](#Script.retrieveForCache) ⇒ <code>Promise.&lt;{metadata: TYPE.ScriptMap, type: string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#Script.retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata: TYPE.Script, type: string}&gt;</code>
    * [.postRetrieveTasks(metadata)](#Script.postRetrieveTasks) ⇒ <code>TYPE.CodeExtractItem</code>
    * [.update(script)](#Script.update) ⇒ <code>Promise</code>
    * [.create(script)](#Script.create) ⇒ <code>Promise</code>
    * [._mergeCode(metadata, deployDir, [templateName])](#Script._mergeCode) ⇒ <code>Promise.&lt;string&gt;</code>
    * [.preDeployTasks(metadata, dir)](#Script.preDeployTasks) ⇒ <code>TYPE.ScriptItem</code>
    * [.buildDefinitionForNested(templateDir, targetDir, metadata, templateVariables, templateName)](#Script.buildDefinitionForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [.buildTemplateForNested(templateDir, targetDir, metadata, templateVariables, templateName)](#Script.buildTemplateForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [._buildForNested(templateDir, targetDir, metadata, templateVariables, templateName, mode)](#Script._buildForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [.parseMetadata(metadata)](#Script.parseMetadata) ⇒ <code>TYPE.CodeExtractItem</code>
    * [.prepExtractedCode(metadataScript, metadataName)](#Script.prepExtractedCode) ⇒ <code>Object</code>
    * [.getFilesToCommit(keyArr)](#Script.getFilesToCommit) ⇒ <code>Array.&lt;string&gt;</code>

<a name="Script.retrieve"></a>

### Script.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;{metadata: TYPE.ScriptMap, type: string}&gt;</code>
Retrieves Metadata of Script
Endpoint /automation/v1/scripts/ return all Scripts with all details.

**Kind**: static method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.ScriptMap, type: string}&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="Script.retrieveForCache"></a>

### Script.retrieveForCache() ⇒ <code>Promise.&lt;{metadata: TYPE.ScriptMap, type: string}&gt;</code>
Retrieves script metadata for caching

**Kind**: static method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.ScriptMap, type: string}&gt;</code> - Promise  
<a name="Script.retrieveAsTemplate"></a>

### Script.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;{metadata: TYPE.Script, type: string}&gt;</code>
Retrieve a specific Script by Name

**Kind**: static method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;{metadata: TYPE.Script, type: string}&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Script.postRetrieveTasks"></a>

### Script.postRetrieveTasks(metadata) ⇒ <code>TYPE.CodeExtractItem</code>
manages post retrieve steps

**Kind**: static method of [<code>Script</code>](#Script)  
**Returns**: <code>TYPE.CodeExtractItem</code> - Array with one metadata object and one ssjs string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.ScriptItem</code> | a single script |

<a name="Script.update"></a>

### Script.update(script) ⇒ <code>Promise</code>
Updates a single Script

**Kind**: static method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| script | <code>TYPE.MetadataTypeItem</code> | a single Script |

<a name="Script.create"></a>

### Script.create(script) ⇒ <code>Promise</code>
Creates a single Script

**Kind**: static method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| script | <code>TYPE.MetadataTypeItem</code> | a single Script |

<a name="Script._mergeCode"></a>

### Script.\_mergeCode(metadata, deployDir, [templateName]) ⇒ <code>Promise.&lt;string&gt;</code>
helper for [preDeployTasks](#Script.preDeployTasks) that loads extracted code content back into JSON

**Kind**: static method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;string&gt;</code> - content for metadata.script  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.ScriptItem</code> | a single asset definition |
| deployDir | <code>string</code> | directory of deploy files |
| [templateName] | <code>string</code> | name of the template used to built defintion (prior applying templating) |

<a name="Script.preDeployTasks"></a>

### Script.preDeployTasks(metadata, dir) ⇒ <code>TYPE.ScriptItem</code>
prepares a Script for deployment

**Kind**: static method of [<code>Script</code>](#Script)  
**Returns**: <code>TYPE.ScriptItem</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.ScriptItem</code> | a single script activity definition |
| dir | <code>string</code> | directory of deploy files |

<a name="Script.buildDefinitionForNested"></a>

### Script.buildDefinitionForNested(templateDir, targetDir, metadata, templateVariables, templateName) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [buildDefinition](#MetadataType.buildDefinition)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.ScriptItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="Script.buildTemplateForNested"></a>

### Script.buildTemplateForNested(templateDir, targetDir, metadata, templateVariables, templateName) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [buildTemplate](#MetadataType.buildTemplate)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.ScriptItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

**Example**  
```js
scripts are saved as 1 json and 1 ssjs file. both files need to be run through templating
```
<a name="Script._buildForNested"></a>

### Script.\_buildForNested(templateDir, targetDir, metadata, templateVariables, templateName, mode) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [buildTemplateForNested](#Script.buildTemplateForNested) / [buildDefinitionForNested](#Script.buildDefinitionForNested)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.ScriptItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |
| mode | <code>&#x27;definition&#x27;</code> \| <code>&#x27;template&#x27;</code> | defines what we use this helper for |

<a name="Script.parseMetadata"></a>

### Script.parseMetadata(metadata) ⇒ <code>TYPE.CodeExtractItem</code>
Splits the script metadata into two parts and parses in a standard manner

**Kind**: static method of [<code>Script</code>](#Script)  
**Returns**: <code>TYPE.CodeExtractItem</code> - a single item with code parts extracted  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.ScriptItem</code> | a single script activity definition |

<a name="Script.prepExtractedCode"></a>

### Script.prepExtractedCode(metadataScript, metadataName) ⇒ <code>Object</code>
helper for [parseMetadata](#Script.parseMetadata) and [_buildForNested](#Script._buildForNested)

**Kind**: static method of [<code>Script</code>](#Script)  
**Returns**: <code>Object</code> - returns found extension and file content  

| Param | Type | Description |
| --- | --- | --- |
| metadataScript | <code>string</code> | the code of the file |
| metadataName | <code>string</code> | the name of the metadata |

<a name="Script.getFilesToCommit"></a>

### Script.getFilesToCommit(keyArr) ⇒ <code>Array.&lt;string&gt;</code>
should return only the json for all but asset, query and script that are saved as multiple files
additionally, the documentation for dataExtension and automation should be returned

**Kind**: static method of [<code>Script</code>](#Script)  
**Returns**: <code>Array.&lt;string&gt;</code> - list of all files that need to be committed in a flat array ['path/file1.ext', 'path/file2.ext']  

| Param | Type | Description |
| --- | --- | --- |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="SendClassification"></a>

## SendClassification ⇐ [<code>MetadataType</code>](#MetadataType)
SendClassification MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  
<a name="SendClassification.retrieve"></a>

### SendClassification.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves SOAP based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: static method of [<code>SendClassification</code>](#SendClassification)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="TransactionalEmail"></a>

## TransactionalEmail ⇐ [<code>TransactionalMessage</code>](#TransactionalMessage)
TransactionalEmail MetadataType

**Kind**: global class  
**Extends**: [<code>TransactionalMessage</code>](#TransactionalMessage)  

* [TransactionalEmail](#TransactionalEmail) ⇐ [<code>TransactionalMessage</code>](#TransactionalMessage)
    * [.update(metadata)](#TransactionalEmail.update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#TransactionalEmail.preDeployTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.postRetrieveTasks(metadata)](#TransactionalEmail.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code>

<a name="TransactionalEmail.update"></a>

### TransactionalEmail.update(metadata) ⇒ <code>Promise</code>
Updates a single item

**Kind**: static method of [<code>TransactionalEmail</code>](#TransactionalEmail)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | how the item shall look after the update |

<a name="TransactionalEmail.preDeployTasks"></a>

### TransactionalEmail.preDeployTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
prepares for deployment

**Kind**: static method of [<code>TransactionalEmail</code>](#TransactionalEmail)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="TransactionalEmail.postRetrieveTasks"></a>

### TransactionalEmail.postRetrieveTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
manages post retrieve steps

**Kind**: static method of [<code>TransactionalEmail</code>](#TransactionalEmail)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - a single item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="TransactionalMessage"></a>

## TransactionalMessage ⇐ [<code>MetadataType</code>](#MetadataType)
TransactionalMessage MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [TransactionalMessage](#TransactionalMessage) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#TransactionalMessage.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveForCache()](#TransactionalMessage.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.update(metadata)](#TransactionalMessage.update) ⇒ <code>Promise</code>
    * [.create(metadata)](#TransactionalMessage.create) ⇒ <code>Promise</code>
    * [.deleteByKey(key)](#TransactionalMessage.deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>

<a name="TransactionalMessage.retrieve"></a>

### TransactionalMessage.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves Metadata

**Kind**: static method of [<code>TransactionalMessage</code>](#TransactionalMessage)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="TransactionalMessage.retrieveForCache"></a>

### TransactionalMessage.retrieveForCache() ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves event definition metadata for caching

**Kind**: static method of [<code>TransactionalMessage</code>](#TransactionalMessage)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  
<a name="TransactionalMessage.update"></a>

### TransactionalMessage.update(metadata) ⇒ <code>Promise</code>
Updates a single item

**Kind**: static method of [<code>TransactionalMessage</code>](#TransactionalMessage)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="TransactionalMessage.create"></a>

### TransactionalMessage.create(metadata) ⇒ <code>Promise</code>
Creates a single item

**Kind**: static method of [<code>TransactionalMessage</code>](#TransactionalMessage)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="TransactionalMessage.deleteByKey"></a>

### TransactionalMessage.deleteByKey(key) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit

**Kind**: static method of [<code>TransactionalMessage</code>](#TransactionalMessage)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> | Identifier of item |

<a name="TransactionalPush"></a>

## TransactionalPush ⇐ [<code>TransactionalMessage</code>](#TransactionalMessage)
TransactionalPush TransactionalMessage

**Kind**: global class  
**Extends**: [<code>TransactionalMessage</code>](#TransactionalMessage)  

* [TransactionalPush](#TransactionalPush) ⇐ [<code>TransactionalMessage</code>](#TransactionalMessage)
    * [.preDeployTasks(metadata)](#TransactionalPush.preDeployTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.postRetrieveTasks(metadata)](#TransactionalPush.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code>

<a name="TransactionalPush.preDeployTasks"></a>

### TransactionalPush.preDeployTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
prepares for deployment

**Kind**: static method of [<code>TransactionalPush</code>](#TransactionalPush)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="TransactionalPush.postRetrieveTasks"></a>

### TransactionalPush.postRetrieveTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
manages post retrieve steps

**Kind**: static method of [<code>TransactionalPush</code>](#TransactionalPush)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - a single item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="TransactionalSMS"></a>

## TransactionalSMS ⇐ [<code>TransactionalMessage</code>](#TransactionalMessage)
TransactionalSMS MetadataType

**Kind**: global class  
**Extends**: [<code>TransactionalMessage</code>](#TransactionalMessage)  

* [TransactionalSMS](#TransactionalSMS) ⇐ [<code>TransactionalMessage</code>](#TransactionalMessage)
    * [.postDeleteTasks(customerKey)](#TransactionalSMS.postDeleteTasks) ⇒ <code>void</code>
    * [.preDeployTasks(metadata, deployDir)](#TransactionalSMS.preDeployTasks) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code>
    * [._mergeCode(metadata, deployDir, [templateName])](#TransactionalSMS._mergeCode) ⇒ <code>Promise.&lt;string&gt;</code>
    * [.postRetrieveTasks(metadata)](#TransactionalSMS.postRetrieveTasks) ⇒ <code>TYPE.CodeExtractItem</code>
    * [.prepExtractedCode(metadataScript)](#TransactionalSMS.prepExtractedCode) ⇒ <code>Object</code>
    * [.buildDefinitionForNested(templateDir, targetDir, metadata, templateVariables, templateName)](#TransactionalSMS.buildDefinitionForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [.buildTemplateForNested(templateDir, targetDir, metadata, templateVariables, templateName)](#TransactionalSMS.buildTemplateForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [._buildForNested(templateDir, targetDir, metadata, templateVariables, templateName, mode)](#TransactionalSMS._buildForNested) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
    * [._isHTML(code)](#TransactionalSMS._isHTML) ⇒ <code>boolean</code>
    * [.getFilesToCommit(keyArr)](#TransactionalSMS.getFilesToCommit) ⇒ <code>Array.&lt;string&gt;</code>

<a name="TransactionalSMS.postDeleteTasks"></a>

### TransactionalSMS.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: static method of [<code>TransactionalSMS</code>](#TransactionalSMS)  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="TransactionalSMS.preDeployTasks"></a>

### TransactionalSMS.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code>
prepares for deployment

**Kind**: static method of [<code>TransactionalSMS</code>](#TransactionalSMS)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeItem&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |
| deployDir | <code>string</code> | directory of deploy files |

<a name="TransactionalSMS._mergeCode"></a>

### TransactionalSMS.\_mergeCode(metadata, deployDir, [templateName]) ⇒ <code>Promise.&lt;string&gt;</code>
helper for [preDeployTasks](#TransactionalSMS.preDeployTasks) that loads extracted code content back into JSON

**Kind**: static method of [<code>TransactionalSMS</code>](#TransactionalSMS)  
**Returns**: <code>Promise.&lt;string&gt;</code> - content for metadata.script  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single definition |
| deployDir | <code>string</code> | directory of deploy files |
| [templateName] | <code>string</code> | name of the template used to built defintion (prior applying templating) |

<a name="TransactionalSMS.postRetrieveTasks"></a>

### TransactionalSMS.postRetrieveTasks(metadata) ⇒ <code>TYPE.CodeExtractItem</code>
manages post retrieve steps

**Kind**: static method of [<code>TransactionalSMS</code>](#TransactionalSMS)  
**Returns**: <code>TYPE.CodeExtractItem</code> - Array with one metadata object and one ssjs string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="TransactionalSMS.prepExtractedCode"></a>

### TransactionalSMS.prepExtractedCode(metadataScript) ⇒ <code>Object</code>
helper for [postRetrieveTasks](#TransactionalSMS.postRetrieveTasks) and [_buildForNested](#TransactionalSMS._buildForNested)

**Kind**: static method of [<code>TransactionalSMS</code>](#TransactionalSMS)  
**Returns**: <code>Object</code> - returns found extension and file content  

| Param | Type | Description |
| --- | --- | --- |
| metadataScript | <code>string</code> | the code of the file |

<a name="TransactionalSMS.buildDefinitionForNested"></a>

### TransactionalSMS.buildDefinitionForNested(templateDir, targetDir, metadata, templateVariables, templateName) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [TransactionalMessage.buildDefinition](TransactionalMessage.buildDefinition)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>TransactionalSMS</code>](#TransactionalSMS)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.MetadataTypeItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="TransactionalSMS.buildTemplateForNested"></a>

### TransactionalSMS.buildTemplateForNested(templateDir, targetDir, metadata, templateVariables, templateName) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [TransactionalMessage.buildTemplate](TransactionalMessage.buildTemplate)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>TransactionalSMS</code>](#TransactionalSMS)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.MetadataTypeItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

**Example**  
```js
scripts are saved as 1 json and 1 ssjs file. both files need to be run through templating
```
<a name="TransactionalSMS._buildForNested"></a>

### TransactionalSMS.\_buildForNested(templateDir, targetDir, metadata, templateVariables, templateName, mode) ⇒ <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code>
helper for [buildTemplateForNested](#TransactionalSMS.buildTemplateForNested) / [buildDefinitionForNested](#TransactionalSMS.buildDefinitionForNested)
handles extracted code if any are found for complex types

**Kind**: static method of [<code>TransactionalSMS</code>](#TransactionalSMS)  
**Returns**: <code>Promise.&lt;Array.&lt;Array.&lt;string&gt;&gt;&gt;</code> - list of extracted files with path-parts provided as an array  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>TYPE.MetadataTypeItem</code> | main JSON file that was read from file system |
| templateVariables | <code>TYPE.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |
| mode | <code>&#x27;definition&#x27;</code> \| <code>&#x27;template&#x27;</code> | defines what we use this helper for |

<a name="TransactionalSMS._isHTML"></a>

### TransactionalSMS.\_isHTML(code) ⇒ <code>boolean</code>
very simplified test for HTML code in our SMS

**Kind**: static method of [<code>TransactionalSMS</code>](#TransactionalSMS)  
**Returns**: <code>boolean</code> - true if HTML is found  

| Param | Type | Description |
| --- | --- | --- |
| code | <code>string</code> | sms source code |

<a name="TransactionalSMS.getFilesToCommit"></a>

### TransactionalSMS.getFilesToCommit(keyArr) ⇒ <code>Array.&lt;string&gt;</code>
should return only the json for all but asset, query and script that are saved as multiple files
additionally, the documentation for dataExtension and automation should be returned

**Kind**: static method of [<code>TransactionalSMS</code>](#TransactionalSMS)  
**Returns**: <code>Array.&lt;string&gt;</code> - list of all files that need to be committed in a flat array ['path/file1.ext', 'path/file2.ext']  

| Param | Type | Description |
| --- | --- | --- |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="TriggeredSend"></a>

## TriggeredSend ⇐ [<code>MetadataType</code>](#MetadataType)
MessageSendActivity MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [TriggeredSend](#TriggeredSend) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [_], [__], [key])](#TriggeredSend.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.create(metadata)](#TriggeredSend.create) ⇒ <code>Promise</code>
    * [.update(metadata)](#TriggeredSend.update) ⇒ <code>Promise</code>
    * [.deleteByKey(customerKey)](#TriggeredSend.deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.postRetrieveTasks(metadata)](#TriggeredSend.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code> \| <code>void</code>
    * [.preDeployTasks(metadata)](#TriggeredSend.preDeployTasks) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.refresh([keyArr], [checkKey])](#TriggeredSend.refresh) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.getKeysForValidTSDs(metadata)](#TriggeredSend.getKeysForValidTSDs) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
    * [.findRefreshableItems([assetLoaded])](#TriggeredSend.findRefreshableItems) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [._refreshItem(key, checkKey)](#TriggeredSend._refreshItem) ⇒ <code>Promise.&lt;boolean&gt;</code>

<a name="TriggeredSend.retrieve"></a>

### TriggeredSend.retrieve(retrieveDir, [_], [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves SOAP based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: static method of [<code>TriggeredSend</code>](#TriggeredSend)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [_] | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="TriggeredSend.create"></a>

### TriggeredSend.create(metadata) ⇒ <code>Promise</code>
Create a single TSD.

**Kind**: static method of [<code>TriggeredSend</code>](#TriggeredSend)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | single metadata entry |

<a name="TriggeredSend.update"></a>

### TriggeredSend.update(metadata) ⇒ <code>Promise</code>
Updates a single TSD.

**Kind**: static method of [<code>TriggeredSend</code>](#TriggeredSend)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | single metadata entry |

<a name="TriggeredSend.deleteByKey"></a>

### TriggeredSend.deleteByKey(customerKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit

**Kind**: static method of [<code>TriggeredSend</code>](#TriggeredSend)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="TriggeredSend.postRetrieveTasks"></a>

### TriggeredSend.postRetrieveTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code> \| <code>void</code>
parses retrieved Metadata before saving

**Kind**: static method of [<code>TriggeredSend</code>](#TriggeredSend)  
**Returns**: <code>TYPE.MetadataTypeItem</code> \| <code>void</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="TriggeredSend.preDeployTasks"></a>

### TriggeredSend.preDeployTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code>
prepares a TSD for deployment

**Kind**: static method of [<code>TriggeredSend</code>](#TriggeredSend)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - metadata object  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | of a single TSD |

<a name="TriggeredSend.refresh"></a>

### TriggeredSend.refresh([keyArr], [checkKey]) ⇒ <code>Promise.&lt;void&gt;</code>
TSD-specific refresh method that finds active TSDs and refreshes them

**Kind**: static method of [<code>TriggeredSend</code>](#TriggeredSend)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [keyArr] | <code>Array.&lt;string&gt;</code> |  | metadata keys |
| [checkKey] | <code>boolean</code> | <code>true</code> | whether to check if the key is valid |

<a name="TriggeredSend.getKeysForValidTSDs"></a>

### TriggeredSend.getKeysForValidTSDs(metadata) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
helper for [refresh](#TriggeredSend.refresh) that extracts the keys from the TSD item map and eli

**Kind**: static method of [<code>TriggeredSend</code>](#TriggeredSend)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - keyArr  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeMapObj</code> | TSD item map |

<a name="TriggeredSend.findRefreshableItems"></a>

### TriggeredSend.findRefreshableItems([assetLoaded]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
helper for [refresh](#TriggeredSend.refresh) that finds active TSDs on the server and filters it by the same rules that [retrieve](#TriggeredSend.retrieve) is using to avoid refreshing TSDs with broken dependencies

**Kind**: static method of [<code>TriggeredSend</code>](#TriggeredSend)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of TSD item map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [assetLoaded] | <code>boolean</code> | <code>false</code> | if run after Asset.deploy via --refresh option this will skip caching assets |

<a name="TriggeredSend._refreshItem"></a>

### TriggeredSend.\_refreshItem(key, checkKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
helper for [refresh](#TriggeredSend.refresh) that pauses, publishes and starts a triggered send

**Kind**: static method of [<code>TriggeredSend</code>](#TriggeredSend)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - true if refresh was successful  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> | external key of triggered send item |
| checkKey | <code>boolean</code> | whether to check if key exists on the server |

<a name="User"></a>

## User ⇐ [<code>MetadataType</code>](#MetadataType)
MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [User](#User) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, _, [__], [key])](#User.retrieve) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveForCache()](#User.retrieveForCache) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.create(metadata)](#User.create) ⇒ <code>Promise</code>
    * [.update(metadata)](#User.update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#User.preDeployTasks) ⇒ <code>TYPE.UserDocument</code>
    * [.createOrUpdate(metadata, metadataKey, hasError, metadataToUpdate, metadataToCreate)](#User.createOrUpdate) ⇒ <code>void</code>
    * [.postDeployTasks(upsertResults)](#User.postDeployTasks) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._getRoleObjectForDeploy(roleId, roleName, userId, assignmentOnly, [isRoleRemovale])](#User._getRoleObjectForDeploy) ⇒ <code>object</code>
    * [.retrieveChangelog()](#User.retrieveChangelog) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [singleRetrieve], [additionalFields])](#User.retrieveSOAP) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
    * [.document([metadata])](#User.document) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.postRetrieveTasks(metadata)](#User.postRetrieveTasks) ⇒ <code>TYPE.MetadataTypeItem</code> \| <code>void</code>

<a name="User.retrieve"></a>

### User.retrieve(retrieveDir, _, [__], [key]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves SOAP based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: static method of [<code>User</code>](#User)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| _ | <code>void</code> | unused parameter |
| [__] | <code>void</code> | unused parameter |
| [key] | <code>string</code> | customer key of single item to retrieve |

<a name="User.retrieveForCache"></a>

### User.retrieveForCache() ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves import definition metadata for caching

**Kind**: static method of [<code>User</code>](#User)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise  
<a name="User.create"></a>

### User.create(metadata) ⇒ <code>Promise</code>
Create a single item.

**Kind**: static method of [<code>User</code>](#User)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | single metadata entry |

<a name="User.update"></a>

### User.update(metadata) ⇒ <code>Promise</code>
Updates a single item.

**Kind**: static method of [<code>User</code>](#User)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | single metadata entry |

<a name="User.preDeployTasks"></a>

### User.preDeployTasks(metadata) ⇒ <code>TYPE.UserDocument</code>
prepares a item for deployment

**Kind**: static method of [<code>User</code>](#User)  
**Returns**: <code>TYPE.UserDocument</code> - metadata object  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.UserDocument</code> | of a single item |

<a name="User.createOrUpdate"></a>

### User.createOrUpdate(metadata, metadataKey, hasError, metadataToUpdate, metadataToCreate) ⇒ <code>void</code>
helper for [upsert](#MetadataType.upsert)

**Kind**: static method of [<code>User</code>](#User)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeMap</code> | list of metadata |
| metadataKey | <code>string</code> | key of item we are looking at |
| hasError | <code>boolean</code> | error flag from previous code |
| metadataToUpdate | <code>Array.&lt;TYPE.UserDocumentDiff&gt;</code> | list of items to update |
| metadataToCreate | <code>Array.&lt;TYPE.UserDocument&gt;</code> | list of items to create |

<a name="User.postDeployTasks"></a>

### User.postDeployTasks(upsertResults) ⇒ <code>Promise.&lt;void&gt;</code>
Gets executed after deployment of metadata type

**Kind**: static method of [<code>User</code>](#User)  
**Returns**: <code>Promise.&lt;void&gt;</code> - promise  

| Param | Type | Description |
| --- | --- | --- |
| upsertResults | <code>TYPE.UserDocumentMap</code> | metadata mapped by their keyField |

<a name="User._getRoleObjectForDeploy"></a>

### User.\_getRoleObjectForDeploy(roleId, roleName, userId, assignmentOnly, [isRoleRemovale]) ⇒ <code>object</code>
helper for [User._prepareRoleAssignments](User._prepareRoleAssignments)

**Kind**: static method of [<code>User</code>](#User)  
**Returns**: <code>object</code> - format needed by API  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| roleId | <code>string</code> |  | role.ObjectID |
| roleName | <code>string</code> |  | role.Name |
| userId | <code>number</code> |  | user.AccountUserID |
| assignmentOnly | <code>boolean</code> |  | if true, only assignment configuration will be returned |
| [isRoleRemovale] | <code>boolean</code> | <code>false</code> | if true, role will be removed from user; otherwise added |

<a name="User.retrieveChangelog"></a>

### User.retrieveChangelog() ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves SOAP based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: static method of [<code>User</code>](#User)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of metadata  
<a name="User.retrieveSOAP"></a>

### User.retrieveSOAP(retrieveDir, [requestParams], [singleRetrieve], [additionalFields]) ⇒ <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: static method of [<code>User</code>](#User)  
**Returns**: <code>Promise.&lt;TYPE.MetadataTypeMapObj&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>TYPE.SoapRequestParams</code> | required for the specific request (filter for example) |
| [singleRetrieve] | <code>string</code> \| <code>number</code> | key of single item to filter by |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="User.document"></a>

### User.document([metadata]) ⇒ <code>Promise.&lt;void&gt;</code>
Creates markdown documentation of all roles

**Kind**: static method of [<code>User</code>](#User)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>TYPE.MetadataTypeMap</code> | user list |

<a name="User.postRetrieveTasks"></a>

### User.postRetrieveTasks(metadata) ⇒ <code>TYPE.MetadataTypeItem</code> \| <code>void</code>
manages post retrieve steps

**Kind**: static method of [<code>User</code>](#User)  
**Returns**: <code>TYPE.MetadataTypeItem</code> \| <code>void</code> - a single item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single item |

<a name="Retriever"></a>

## Retriever
Retrieves metadata from a business unit and saves it to the local filesystem.

**Kind**: global class  

* [Retriever](#Retriever)
    * [new Retriever(properties, buObject)](#new_Retriever_new)
    * [.retrieve(metadataTypes, [namesOrKeys], [templateVariables], [changelogOnly])](#Retriever+retrieve) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code>
    * [._getTypeDependencies(metadataTypes)](#Retriever+_getTypeDependencies) ⇒ <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code>

<a name="new_Retriever_new"></a>

### new Retriever(properties, buObject)
Creates a Retriever, uses v2 auth if v2AuthOptions are passed.


| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | General configuration to be used in retrieve |
| buObject | <code>TYPE.BuObject</code> | properties for auth |

<a name="Retriever+retrieve"></a>

### retriever.retrieve(metadataTypes, [namesOrKeys], [templateVariables], [changelogOnly]) ⇒ <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code>
Retrieve metadata of specified types into local file system and Retriever.metadata

**Kind**: instance method of [<code>Retriever</code>](#Retriever)  
**Returns**: <code>Promise.&lt;TYPE.MultiMetadataTypeList&gt;</code> - Promise of a list of retrieved items grouped by type {automation:[...], query:[...]}  

| Param | Type | Description |
| --- | --- | --- |
| metadataTypes | <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code> | list of metadata types to retrieve; can include subtypes! |
| [namesOrKeys] | <code>Array.&lt;string&gt;</code> \| <code>TYPE.TypeKeyCombo</code> | name of Metadata to retrieveAsTemplate or list of keys for normal retrieval |
| [templateVariables] | <code>TYPE.TemplateMap</code> | Object of values which can be replaced (in case of templating) |
| [changelogOnly] | <code>boolean</code> | skip saving, only create json in memory |

<a name="Retriever+_getTypeDependencies"></a>

### retriever.\_getTypeDependencies(metadataTypes) ⇒ <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code>
helper for [Retriever.retrieve](Retriever.retrieve) to get all dependencies of the given types

**Kind**: instance method of [<code>Retriever</code>](#Retriever)  
**Returns**: <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code> - unique list dependent metadata types  

| Param | Type | Description |
| --- | --- | --- |
| metadataTypes | <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code> | list of metadata types to retrieve; can include subtypes! |

<a name="Util"></a>

## Util
CLI entry for SFMC DevTools

**Kind**: global constant  

* [Util](#Util)
    * [.skipInteraction](#Util.skipInteraction) : <code>TYPE.skipInteraction</code>
    * [.logger](#Util.logger) : <code>TYPE.Logger</code>
    * [.filterObjByKeys(originalObj, [whitelistArr])](#Util.filterObjByKeys) ⇒ <code>Object.&lt;string, \*&gt;</code>
    * [.includesStartsWith(arr, search)](#Util.includesStartsWith) ⇒ <code>boolean</code>
    * [.includesStartsWithIndex(arr, search)](#Util.includesStartsWithIndex) ⇒ <code>number</code>
    * [.checkMarket(market, properties)](#Util.checkMarket) ⇒ <code>boolean</code>
    * [.verifyMarketList(mlName, properties)](#Util.verifyMarketList)
    * [.signalFatalError()](#Util.signalFatalError) ⇒ <code>void</code>
    * [.isTrue(attrValue)](#Util.isTrue) ⇒ <code>boolean</code>
    * [.isFalse(attrValue)](#Util.isFalse) ⇒ <code>boolean</code>
    * [._isValidType(selectedType, [handleOutside])](#Util._isValidType) ⇒ <code>boolean</code>
    * [.getTypeAndSubType(selectedType)](#Util.getTypeAndSubType) ⇒ <code>Array.&lt;string&gt;</code>
    * [.emailValidator(email)](#Util.emailValidator) ⇒ <code>boolean</code>
    * [.getRetrieveTypeChoices()](#Util.getRetrieveTypeChoices) ⇒ <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code>
    * [._createNewLoggerTransport([noLogFile])](#Util._createNewLoggerTransport) ⇒ <code>object</code>
    * [.startLogger([restart], [noLogFile])](#Util.startLogger) ⇒ <code>void</code>
    * [.metadataLogger(level, type, method, payload, [source])](#Util.metadataLogger) ⇒ <code>void</code>
    * [.replaceByObject(str, obj)](#Util.replaceByObject) ⇒ <code>string</code> \| <code>object</code>
    * [.inverseGet(objs, val)](#Util.inverseGet) ⇒ <code>string</code>
    * [.getDependentMetadata(fixedType)](#Util.getDependentMetadata) ⇒ <code>Array.&lt;string&gt;</code>
    * [.getMetadataHierachy(metadataTypes)](#Util.getMetadataHierachy) ⇒ <code>Object.&lt;string, Array.&lt;string&gt;&gt;</code>
    * [.resolveObjPath(path, obj)](#Util.resolveObjPath) ⇒ <code>any</code>
    * [.execSync(cmd, [args], [hideOutput])](#Util.execSync) ⇒ <code>string</code> \| <code>void</code>
    * [.templateSearchResult(results, keyToSearch, searchValue)](#Util.templateSearchResult) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.setLoggingLevel(argv)](#Util.setLoggingLevel) ⇒ <code>void</code>
    * [.logBeta(type)](#Util.logBeta)
    * [.getGrayMsg(msg)](#Util.getGrayMsg) ⇒ <code>string</code>
    * [.logSubtypes(subTypeArr)](#Util.logSubtypes) ⇒ <code>void</code>
    * [.getKeysString(keyArr, [isId])](#Util.getKeysString) ⇒ <code>string</code>
    * [.sleep(ms)](#Util.sleep) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.getSsjs(code)](#Util.getSsjs) ⇒ <code>string</code>
    * [.stringLike(testString, search)](#Util.stringLike) ⇒ <code>boolean</code>
    * [.fieldsLike(metadata, [filters])](#Util.fieldsLike) ⇒ <code>boolean</code>
    * [.capitalizeFirstLetter(str)](#Util.capitalizeFirstLetter) ⇒ <code>string</code>

<a name="Util.skipInteraction"></a>

### Util.skipInteraction : <code>TYPE.skipInteraction</code>
**Kind**: static property of [<code>Util</code>](#Util)  
<a name="Util.logger"></a>

### Util.logger : <code>TYPE.Logger</code>
Logger that creates timestamped log file in 'logs/' directory

**Kind**: static property of [<code>Util</code>](#Util)  
<a name="Util.filterObjByKeys"></a>

### Util.filterObjByKeys(originalObj, [whitelistArr]) ⇒ <code>Object.&lt;string, \*&gt;</code>
helper that allows filtering an object by its keys

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Object.&lt;string, \*&gt;</code> - filtered object that only contains keys you provided  

| Param | Type | Description |
| --- | --- | --- |
| originalObj | <code>Object.&lt;string, \*&gt;</code> | object that you want to filter |
| [whitelistArr] | <code>Array.&lt;string&gt;</code> | positive filter. if not provided, returns originalObj without filter |

<a name="Util.includesStartsWith"></a>

### Util.includesStartsWith(arr, search) ⇒ <code>boolean</code>
extended Array.includes method that allows check if an array-element starts with a certain string

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - found / not found  

| Param | Type | Description |
| --- | --- | --- |
| arr | <code>Array.&lt;string&gt;</code> | your array of strigns |
| search | <code>string</code> | the string you are looking for |

<a name="Util.includesStartsWithIndex"></a>

### Util.includesStartsWithIndex(arr, search) ⇒ <code>number</code>
extended Array.includes method that allows check if an array-element starts with a certain string

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>number</code> - array index 0..n or -1 of not found  

| Param | Type | Description |
| --- | --- | --- |
| arr | <code>Array.&lt;string&gt;</code> | your array of strigns |
| search | <code>string</code> | the string you are looking for |

<a name="Util.checkMarket"></a>

### Util.checkMarket(market, properties) ⇒ <code>boolean</code>
check if a market name exists in current mcdev config

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - found market or not  

| Param | Type | Description |
| --- | --- | --- |
| market | <code>string</code> | market localizations |
| properties | <code>TYPE.Mcdevrc</code> | local mcdev config |

<a name="Util.verifyMarketList"></a>

### Util.verifyMarketList(mlName, properties)
ensure provided MarketList exists and it's content including markets and BUs checks out

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| mlName | <code>string</code> | name of marketList |
| properties | <code>TYPE.Mcdevrc</code> | General configuration to be used in retrieve |

<a name="Util.signalFatalError"></a>

### Util.signalFatalError() ⇒ <code>void</code>
used to ensure the program tells surrounding software that an unrecoverable error occured

**Kind**: static method of [<code>Util</code>](#Util)  
<a name="Util.isTrue"></a>

### Util.isTrue(attrValue) ⇒ <code>boolean</code>
SFMC accepts multiple true values for Boolean attributes for which we are checking here.
The same problem occurs when evaluating boolean CLI flags

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - attribute value == true ? true : false  

| Param | Type | Description |
| --- | --- | --- |
| attrValue | <code>\*</code> | value |

<a name="Util.isFalse"></a>

### Util.isFalse(attrValue) ⇒ <code>boolean</code>
SFMC accepts multiple false values for Boolean attributes for which we are checking here.
The same problem occurs when evaluating boolean CLI flags

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - attribute value == false ? true : false  

| Param | Type | Description |
| --- | --- | --- |
| attrValue | <code>\*</code> | value |

<a name="Util._isValidType"></a>

### Util.\_isValidType(selectedType, [handleOutside]) ⇒ <code>boolean</code>
helper for Mcdev.retrieve, Mcdev.retrieveAsTemplate and Mcdev.deploy

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - type ok or not  

| Param | Type | Description |
| --- | --- | --- |
| selectedType | <code>TYPE.SupportedMetadataTypes</code> | type or type-subtype |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="Util.getTypeAndSubType"></a>

### Util.getTypeAndSubType(selectedType) ⇒ <code>Array.&lt;string&gt;</code>
helper that deals with extracting type and subtype

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Array.&lt;string&gt;</code> - first elem is type, second elem is subType  

| Param | Type | Description |
| --- | --- | --- |
| selectedType | <code>string</code> | "type" or "type-subtype" |

<a name="Util.emailValidator"></a>

### Util.emailValidator(email) ⇒ <code>boolean</code>
helper that validates email address

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - first elem is type, second elem is subType  

| Param | Type | Description |
| --- | --- | --- |
| email | <code>string</code> | email to validate |

<a name="Util.getRetrieveTypeChoices"></a>

### Util.getRetrieveTypeChoices() ⇒ <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code>
helper for getDefaultProperties()

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code> - type choices  
<a name="Util._createNewLoggerTransport"></a>

### Util.\_createNewLoggerTransport([noLogFile]) ⇒ <code>object</code>
wrapper around our standard winston logging to console and logfile

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>object</code> - initiated logger for console and file  

| Param | Type | Description |
| --- | --- | --- |
| [noLogFile] | <code>boolean</code> | optional flag to indicate if we should log to file; CLI logs are always on |

<a name="Util.startLogger"></a>

### Util.startLogger([restart], [noLogFile]) ⇒ <code>void</code>
initiate winston logger

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| [restart] | <code>boolean</code> | if true, logger will be restarted; otherwise, an existing logger will be used |
| [noLogFile] | <code>boolean</code> | if false, logger will log to file; otherwise, only to console |

<a name="Util.metadataLogger"></a>

### Util.metadataLogger(level, type, method, payload, [source]) ⇒ <code>void</code>
Logger helper for Metadata functions

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| level | <code>string</code> | of log (error, info, warn) |
| type | <code>string</code> | of metadata being referenced |
| method | <code>string</code> | name which log was called from |
| payload | <code>\*</code> | generic object which details the error |
| [source] | <code>string</code> | key/id of metadata which relates to error |

<a name="Util.replaceByObject"></a>

### Util.replaceByObject(str, obj) ⇒ <code>string</code> \| <code>object</code>
replaces values in a JSON object string, based on a series of
key-value pairs (obj)

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>string</code> \| <code>object</code> - replaced version of str  

| Param | Type | Description |
| --- | --- | --- |
| str | <code>string</code> \| <code>object</code> | JSON object or its stringified version, which has values to be replaced |
| obj | <code>TYPE.TemplateMap</code> | key value object which contains keys to be replaced and values to be replaced with |

<a name="Util.inverseGet"></a>

### Util.inverseGet(objs, val) ⇒ <code>string</code>
get key of an object based on the first matching value

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>string</code> - key  

| Param | Type | Description |
| --- | --- | --- |
| objs | <code>object</code> | object of objects to be searched |
| val | <code>string</code> | value to be searched for |

<a name="Util.getDependentMetadata"></a>

### Util.getDependentMetadata(fixedType) ⇒ <code>Array.&lt;string&gt;</code>
helper for Mcdev.fixKeys. Retrieve dependent metadata

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Array.&lt;string&gt;</code> - array of types that depend on the given type  

| Param | Type | Description |
| --- | --- | --- |
| fixedType | <code>string</code> | type of the metadata passed as a parameter to fixKeys function |

<a name="Util.getMetadataHierachy"></a>

### Util.getMetadataHierachy(metadataTypes) ⇒ <code>Object.&lt;string, Array.&lt;string&gt;&gt;</code>
Returns Order in which metadata needs to be retrieved/deployed

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Object.&lt;string, Array.&lt;string&gt;&gt;</code> - retrieve/deploy order as array  

| Param | Type | Description |
| --- | --- | --- |
| metadataTypes | <code>Array.&lt;string&gt;</code> | which should be retrieved/deployed |

<a name="Util.resolveObjPath"></a>

### Util.resolveObjPath(path, obj) ⇒ <code>any</code>
let's you dynamically walk down an object and get a value

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>any</code> - value of obj.path  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | 'fieldA.fieldB.fieldC' |
| obj | <code>object</code> | some parent object |

<a name="Util.execSync"></a>

### Util.execSync(cmd, [args], [hideOutput]) ⇒ <code>string</code> \| <code>void</code>
helper to run other commands as if run manually by user

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>string</code> \| <code>void</code> - output of command if hideOutput is true  

| Param | Type | Description |
| --- | --- | --- |
| cmd | <code>string</code> | to be executed command |
| [args] | <code>Array.&lt;string&gt;</code> | list of arguments |
| [hideOutput] | <code>boolean</code> | if true, output of command will be hidden from CLI |

<a name="Util.templateSearchResult"></a>

### Util.templateSearchResult(results, keyToSearch, searchValue) ⇒ <code>TYPE.MetadataTypeItem</code>
standardize check to ensure only one result is returned from template search

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - metadata to be used in building template  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Array.&lt;TYPE.MetadataTypeItem&gt;</code> | array of metadata |
| keyToSearch | <code>string</code> | the field which contains the searched value |
| searchValue | <code>string</code> | the value which is being looked for |

<a name="Util.setLoggingLevel"></a>

### Util.setLoggingLevel(argv) ⇒ <code>void</code>
configures what is displayed in the console

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| argv | <code>object</code> | list of command line parameters given by user |
| [argv.silent] | <code>boolean</code> | only errors printed to CLI |
| [argv.verbose] | <code>boolean</code> | chatty user CLI output |
| [argv.debug] | <code>boolean</code> | enables developer output & features |

<a name="Util.logBeta"></a>

### Util.logBeta(type)
outputs a warning that the given type is still in beta

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | api name of the type thats in beta |

<a name="Util.getGrayMsg"></a>

### Util.getGrayMsg(msg) ⇒ <code>string</code>
helper that wraps a message in the correct color codes to have them printed gray

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>string</code> - gray msg  

| Param | Type | Description |
| --- | --- | --- |
| msg | <code>string</code> | log message that should be wrapped with color codes |

<a name="Util.logSubtypes"></a>

### Util.logSubtypes(subTypeArr) ⇒ <code>void</code>
helper to print the subtypes we filtered by

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| subTypeArr | <code>Array.&lt;string&gt;</code> | list of subtypes to be printed |

<a name="Util.getKeysString"></a>

### Util.getKeysString(keyArr, [isId]) ⇒ <code>string</code>
helper to print the subtypes we filtered by

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>string</code> - string to be appended to log message  

| Param | Type | Description |
| --- | --- | --- |
| keyArr | <code>Array.&lt;string&gt;</code> \| <code>string</code> | list of subtypes to be printed |
| [isId] | <code>boolean</code> | optional flag to indicate if key is an id |

<a name="Util.sleep"></a>

### Util.sleep(ms) ⇒ <code>Promise.&lt;void&gt;</code>
pause execution of code; useful when multiple server calls are dependent on each other and might not be executed right away

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Promise.&lt;void&gt;</code> - - promise to wait for  

| Param | Type | Description |
| --- | --- | --- |
| ms | <code>number</code> | time in miliseconds to wait |

<a name="Util.getSsjs"></a>

### Util.getSsjs(code) ⇒ <code>string</code>
helper for Asset.extractCode and Script.prepExtractedCode to determine if a code block is a valid SSJS block

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>string</code> - the SSJS code if code block is a valid SSJS block, otherwise null  

| Param | Type | Description |
| --- | --- | --- |
| code | <code>string</code> | code block to check |

**Example**  
```js
the following is invalid:
<script runat="server">
      // 1
  </script>
  <script runat="server">
      // 2
  </script>

  the following is valid:
  <script runat="server">
      // 3
  </script>
```
<a name="Util.stringLike"></a>

### Util.stringLike(testString, search) ⇒ <code>boolean</code>
allows us to filter just like with SQL's LIKE operator

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - true if testString matches search  

| Param | Type | Description |
| --- | --- | --- |
| testString | <code>string</code> | field value to test |
| search | <code>string</code> | search string in SQL LIKE format |

<a name="Util.fieldsLike"></a>

### Util.fieldsLike(metadata, [filters]) ⇒ <code>boolean</code>
returns true if no LIKE filter is defined or if all filters match

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - true if no LIKE filter is defined or if all filters match  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single metadata item |
| [filters] | <code>object</code> | only used in recursive calls |

<a name="Util.capitalizeFirstLetter"></a>

### Util.capitalizeFirstLetter(str) ⇒ <code>string</code>
helper used by SOAP methods to ensure the type always uses an upper-cased first letter

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>string</code> - str with first letter capitalized  

| Param | Type | Description |
| --- | --- | --- |
| str | <code>string</code> | string to capitalize |

<a name="MetadataTypeDefinitions"></a>

## MetadataTypeDefinitions
Provides access to all metadataType classes

**Kind**: global constant  
<a name="MetadataTypeInfo"></a>

## MetadataTypeInfo
Provides access to all metadataType classes

**Kind**: global constant  
<a name="mcdev"></a>

## mcdev
sample file on how to retrieve a simple changelog to use in GUIs or automated processing of any kind

**Kind**: global constant  
**Example**  
```js
[{
    name: 'deName',
    key: 'deKey',
    t: 'dataExtension',
    cd: '2020-05-06T00:16:00.737',
    cb: 'name of creator',
    ld: '2020-05-06T00:16:00.737',
    lb: 'name of lastmodified'
  }]
```
<a name="BusinessUnit"></a>

## BusinessUnit
Helper that handles retrieval of BU info

**Kind**: global constant  
<a name="BusinessUnit.refreshBUProperties"></a>

### BusinessUnit.refreshBUProperties(properties, credentialsName) ⇒ <code>Promise.&lt;boolean&gt;</code>
Refreshes BU names and ID's from MC instance

**Kind**: static method of [<code>BusinessUnit</code>](#BusinessUnit)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - success of refresh  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | current properties that have to be refreshed |
| credentialsName | <code>string</code> | identifying name of the installed package / project |

<a name="dataStore"></a>

## dataStore : <code>TYPE.Cache</code>
**Kind**: global constant  
<a name="Cli"></a>

## Cli
CLI helper class

**Kind**: global constant  

* [Cli](#Cli)
    * [.initMcdevConfig()](#Cli.initMcdevConfig) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.addExtraCredential(properties)](#Cli.addExtraCredential) ⇒ <code>Promise.&lt;(boolean\|string)&gt;</code>
    * [.updateNotificationEmails(type)](#Cli.updateNotificationEmails) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
    * [.postFixKeysReretrieve(type, dependentTypes)](#Cli.postFixKeysReretrieve) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.logExistingCredentials(properties)](#Cli.logExistingCredentials) ⇒ <code>void</code>
    * [.updateCredential(properties, credName)](#Cli.updateCredential) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.getCredentialObject(properties, target, [isCredentialOnly], [allowAll])](#Cli.getCredentialObject) ⇒ <code>Promise.&lt;TYPE.BuObject&gt;</code>
    * [._selectBU(properties, [credential], [isCredentialOnly], [allowAll])](#Cli._selectBU) ⇒ <code>Promise.&lt;Array&gt;</code>
    * [._setCredential(properties, [credName])](#Cli._setCredential) ⇒ <code>Promise.&lt;(boolean\|string)&gt;</code>
    * [._askCredentials(properties, [credName])](#Cli._askCredentials) ⇒ <code>Promise.&lt;object&gt;</code>
    * [.selectTypes(properties, [setTypesArr])](#Cli.selectTypes) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._summarizeSubtypes(responses, type)](#Cli._summarizeSubtypes) ⇒ <code>void</code>
    * [.explainTypes()](#Cli.explainTypes) ⇒ <code>Array.&lt;object&gt;</code>

<a name="Cli.initMcdevConfig"></a>

### Cli.initMcdevConfig() ⇒ <code>Promise.&lt;boolean&gt;</code>
used when initially setting up a project.
loads default config and adds first credential

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - success of init  
<a name="Cli.addExtraCredential"></a>

### Cli.addExtraCredential(properties) ⇒ <code>Promise.&lt;(boolean\|string)&gt;</code>
Extends template file for properties.json

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;(boolean\|string)&gt;</code> - status  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |

<a name="Cli.updateNotificationEmails"></a>

### Cli.updateNotificationEmails(type) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
interactive helper to set automation run completion/error note

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - responses  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>TYPE.SupportedMetadataTypes</code> | note type (error/completion) |

<a name="Cli.postFixKeysReretrieve"></a>

### Cli.postFixKeysReretrieve(type, dependentTypes) ⇒ <code>Promise.&lt;boolean&gt;</code>
**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - true if user wants to continue with retrieve  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>TYPE.SupportedMetadataTypes</code> | limit execution to given metadata type |
| dependentTypes | <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code> | types that depent on type |

<a name="Cli.logExistingCredentials"></a>

### Cli.logExistingCredentials(properties) ⇒ <code>void</code>
helper that logs to cli which credentials are already existing in our config file

**Kind**: static method of [<code>Cli</code>](#Cli)  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |

<a name="Cli.updateCredential"></a>

### Cli.updateCredential(properties, credName) ⇒ <code>Promise.&lt;boolean&gt;</code>
Extends template file for properties.json
update credentials

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - success of update  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |
| credName | <code>string</code> | name of credential that needs updating |

<a name="Cli.getCredentialObject"></a>

### Cli.getCredentialObject(properties, target, [isCredentialOnly], [allowAll]) ⇒ <code>Promise.&lt;TYPE.BuObject&gt;</code>
Returns Object with parameters required for accessing API

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;TYPE.BuObject&gt;</code> - credential to be used for Business Unit  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | object of all configuration including credentials |
| target | <code>string</code> | code of BU to use |
| [isCredentialOnly] | <code>boolean</code> \| <code>string</code> | true:don't ask for BU | string: name of BU |
| [allowAll] | <code>boolean</code> | Offer ALL as option in BU selection |

<a name="Cli._selectBU"></a>

### Cli.\_selectBU(properties, [credential], [isCredentialOnly], [allowAll]) ⇒ <code>Promise.&lt;Array&gt;</code>
helps select the right credential in case of bad initial input

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;Array&gt;</code> - selected credential/BU combo  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |
| [credential] | <code>string</code> | name of valid credential |
| [isCredentialOnly] | <code>boolean</code> | don't ask for BU if true |
| [allowAll] | <code>boolean</code> | Offer ALL as option in BU selection |

<a name="Cli._setCredential"></a>

### Cli.\_setCredential(properties, [credName]) ⇒ <code>Promise.&lt;(boolean\|string)&gt;</code>
helper around _askCredentials

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;(boolean\|string)&gt;</code> - success of refresh or credential name  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | from config file |
| [credName] | <code>string</code> | name of credential that needs updating |

<a name="Cli._askCredentials"></a>

### Cli.\_askCredentials(properties, [credName]) ⇒ <code>Promise.&lt;object&gt;</code>
helper for [addExtraCredential](#Cli.addExtraCredential)

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;object&gt;</code> - credential info  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | from config file |
| [credName] | <code>string</code> | name of credential that needs updating |

<a name="Cli.selectTypes"></a>

### Cli.selectTypes(properties, [setTypesArr]) ⇒ <code>Promise.&lt;void&gt;</code>
allows updating the metadata types that shall be retrieved

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |
| [setTypesArr] | <code>Array.&lt;string&gt;</code> | skip user prompt and overwrite with this list if given |

<a name="Cli._summarizeSubtypes"></a>

### Cli.\_summarizeSubtypes(responses, type) ⇒ <code>void</code>
helper for [selectTypes](#Cli.selectTypes) that converts subtypes back to main type if all and only defaults were selected
this keeps the config automatically upgradable when we add new subtypes or change what is selected by default

**Kind**: static method of [<code>Cli</code>](#Cli)  

| Param | Type | Description |
| --- | --- | --- |
| responses | <code>object</code> | wrapper object for respones |
| responses.selectedTypes | <code>Array.&lt;string&gt;</code> | what types the user selected |
| type | <code>string</code> | metadata type |

<a name="Cli.explainTypes"></a>

### Cli.explainTypes() ⇒ <code>Array.&lt;object&gt;</code>
shows metadata type descriptions

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Array.&lt;object&gt;</code> - list of supported types with their apiNames  
<a name="config"></a>

## config
Central class for loading and validating properties from config and auth

**Kind**: global constant  

* [config](#config)
    * [.getProperties([silent], [isInit])](#config.getProperties) ⇒ <code>Promise.&lt;TYPE.Mcdevrc&gt;</code>
    * [.checkProperties(properties, [silent])](#config.checkProperties) ⇒ <code>Promise.&lt;(boolean\|Array.&lt;string&gt;)&gt;</code>
    * [.getDefaultProperties()](#config.getDefaultProperties) ⇒ <code>Promise.&lt;TYPE.Mcdevrc&gt;</code>

<a name="config.getProperties"></a>

### config.getProperties([silent], [isInit]) ⇒ <code>Promise.&lt;TYPE.Mcdevrc&gt;</code>
loads central properties from config file

**Kind**: static method of [<code>config</code>](#config)  
**Returns**: <code>Promise.&lt;TYPE.Mcdevrc&gt;</code> - central properties object  

| Param | Type | Description |
| --- | --- | --- |
| [silent] | <code>boolean</code> | omit throwing errors and print messages; assuming not silent if not set |
| [isInit] | <code>boolean</code> | don't tell the user to run init |

<a name="config.checkProperties"></a>

### config.checkProperties(properties, [silent]) ⇒ <code>Promise.&lt;(boolean\|Array.&lt;string&gt;)&gt;</code>
check if the config file is correctly formatted and has values

**Kind**: static method of [<code>config</code>](#config)  
**Returns**: <code>Promise.&lt;(boolean\|Array.&lt;string&gt;)&gt;</code> - file structure ok OR list of fields to be fixed  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | javascript object in .mcdevrc.json |
| [silent] | <code>boolean</code> | set to true for internal use w/o cli output |

<a name="config.getDefaultProperties"></a>

### config.getDefaultProperties() ⇒ <code>Promise.&lt;TYPE.Mcdevrc&gt;</code>
defines how the properties.json should look like
used for creating a template and for checking if variables are set

**Kind**: static method of [<code>config</code>](#config)  
**Returns**: <code>Promise.&lt;TYPE.Mcdevrc&gt;</code> - default properties  
<a name="DevOps"></a>

## DevOps
DevOps helper class

**Kind**: global constant  

* [DevOps](#DevOps)
    * [.getDeltaList(properties, [range], [saveToDeployDir], [filterPaths], [commitHistory])](#DevOps.getDeltaList) ⇒ <code>Promise.&lt;Array.&lt;TYPE.DeltaPkgItem&gt;&gt;</code>
        * [~delta](#DevOps.getDeltaList..delta) : <code>Array.&lt;TYPE.DeltaPkgItem&gt;</code>
        * [~buObjects](#DevOps.getDeltaList..buObjects) : <code>Object.&lt;string, TYPE.BuObject&gt;</code>
        * [~copied](#DevOps.getDeltaList..copied) : <code>Array.&lt;TYPE.DeltaPkgItem&gt;</code>
    * [.buildDeltaDefinitions(properties, range, [diffArr], [commitHistory])](#DevOps.buildDeltaDefinitions) ⇒ <code>Promise.&lt;Array.&lt;TYPE.DeltaPkgItem&gt;&gt;</code>
        * [~deltaDeployAll](#DevOps.buildDeltaDefinitions..deltaDeployAll) : <code>Array.&lt;TYPE.DeltaPkgItem&gt;</code>
    * [.document(directory, jsonReport)](#DevOps.document) ⇒ <code>void</code>
    * [.getFilesToCommit(properties, buObject, metadataType, keyArr)](#DevOps.getFilesToCommit) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>

<a name="DevOps.getDeltaList"></a>

### DevOps.getDeltaList(properties, [range], [saveToDeployDir], [filterPaths], [commitHistory]) ⇒ <code>Promise.&lt;Array.&lt;TYPE.DeltaPkgItem&gt;&gt;</code>
Extracts the delta between a commit and the current state for deployment.
Interactive commit selection if no commits are passed.

**Kind**: static method of [<code>DevOps</code>](#DevOps)  
**Returns**: <code>Promise.&lt;Array.&lt;TYPE.DeltaPkgItem&gt;&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | central properties object |
| [range] | <code>string</code> | git commit range |
| [saveToDeployDir] | <code>boolean</code> | if true, copy metadata changes into deploy directory |
| [filterPaths] | <code>string</code> | filter file paths that start with any specified path (comma separated) |
| [commitHistory] | <code>number</code> | cli option to override default commit history value in config |


* [.getDeltaList(properties, [range], [saveToDeployDir], [filterPaths], [commitHistory])](#DevOps.getDeltaList) ⇒ <code>Promise.&lt;Array.&lt;TYPE.DeltaPkgItem&gt;&gt;</code>
    * [~delta](#DevOps.getDeltaList..delta) : <code>Array.&lt;TYPE.DeltaPkgItem&gt;</code>
    * [~buObjects](#DevOps.getDeltaList..buObjects) : <code>Object.&lt;string, TYPE.BuObject&gt;</code>
    * [~copied](#DevOps.getDeltaList..copied) : <code>Array.&lt;TYPE.DeltaPkgItem&gt;</code>

<a name="DevOps.getDeltaList..delta"></a>

#### getDeltaList~delta : <code>Array.&lt;TYPE.DeltaPkgItem&gt;</code>
**Kind**: inner constant of [<code>getDeltaList</code>](#DevOps.getDeltaList)  
<a name="DevOps.getDeltaList..buObjects"></a>

#### getDeltaList~buObjects : <code>Object.&lt;string, TYPE.BuObject&gt;</code>
**Kind**: inner constant of [<code>getDeltaList</code>](#DevOps.getDeltaList)  
<a name="DevOps.getDeltaList..copied"></a>

#### getDeltaList~copied : <code>Array.&lt;TYPE.DeltaPkgItem&gt;</code>
**Kind**: inner constant of [<code>getDeltaList</code>](#DevOps.getDeltaList)  
<a name="DevOps.buildDeltaDefinitions"></a>

### DevOps.buildDeltaDefinitions(properties, range, [diffArr], [commitHistory]) ⇒ <code>Promise.&lt;Array.&lt;TYPE.DeltaPkgItem&gt;&gt;</code>
wrapper around DevOps.getDeltaList, Builder.buildTemplate and M

**Kind**: static method of [<code>DevOps</code>](#DevOps)  
**Returns**: <code>Promise.&lt;Array.&lt;TYPE.DeltaPkgItem&gt;&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | project config file |
| range | <code>string</code> | git commit range |
| [diffArr] | <code>Array.&lt;TYPE.DeltaPkgItem&gt;</code> | instead of running git diff the method can also get a list of files to process |
| [commitHistory] | <code>number</code> | cli option to override default commit history value in config |

<a name="DevOps.buildDeltaDefinitions..deltaDeployAll"></a>

#### buildDeltaDefinitions~deltaDeployAll : <code>Array.&lt;TYPE.DeltaPkgItem&gt;</code>
**Kind**: inner constant of [<code>buildDeltaDefinitions</code>](#DevOps.buildDeltaDefinitions)  
<a name="DevOps.document"></a>

### DevOps.document(directory, jsonReport) ⇒ <code>void</code>
create markdown file for deployment listing

**Kind**: static method of [<code>DevOps</code>](#DevOps)  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>string</code> | - |
| jsonReport | <code>object</code> | - |

<a name="DevOps.getFilesToCommit"></a>

### DevOps.getFilesToCommit(properties, buObject, metadataType, keyArr) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
should return only the json for all but asset, query and script that are saved as multiple files
additionally, the documentation for dataExtension and automation should be returned

**Kind**: static method of [<code>DevOps</code>](#DevOps)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - list of all files that need to be committed in a flat array ['path/file1.ext', 'path/file2.ext']  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | central properties object |
| buObject | <code>TYPE.BuObject</code> | references credentials |
| metadataType | <code>string</code> | metadata type to build |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="File"></a>

## File
File extends fs-extra. It adds logger and util methods for file handling

**Kind**: global constant  

* [File](#File)
    * [.copyFile(from, to)](#File.copyFile) ⇒ <code>object</code>
    * [.filterIllegalPathChars(path)](#File.filterIllegalPathChars) ⇒ <code>string</code>
    * [.filterIllegalFilenames(filename)](#File.filterIllegalFilenames) ⇒ <code>string</code>
    * [.reverseFilterIllegalFilenames(filename)](#File.reverseFilterIllegalFilenames) ⇒ <code>string</code>
    * [.normalizePath(denormalizedPath)](#File.normalizePath) ⇒ <code>string</code>
    * [.writeJSONToFile(directory, filename, content)](#File.writeJSONToFile) ⇒ <code>Promise</code>
    * [.writePrettyToFile(directory, filename, filetype, content, [templateVariables])](#File.writePrettyToFile) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [._beautify_beautyAmp(content)](#File._beautify_beautyAmp) ⇒ <code>string</code>
    * [._beautify_prettier(directory, filename, filetype, content)](#File._beautify_prettier) ⇒ <code>string</code>
    * [.writeToFile(directory, filename, filetype, content, [encoding])](#File.writeToFile) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.readJSONFile(directory, filename, sync, cleanPath)](#File.readJSONFile) ⇒ <code>Promise.&lt;object&gt;</code> \| <code>object</code> \| <code>void</code>
    * [.readFilteredFilename(directory, filename, filetype, [encoding])](#File.readFilteredFilename) ⇒ <code>Promise.&lt;string&gt;</code> \| <code>void</code>
    * [.readDirectories(directory, depth, [includeStem], [_stemLength])](#File.readDirectories) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
    * [.readDirectoriesSync(directory, [depth], [includeStem], [_stemLength])](#File.readDirectoriesSync) ⇒ <code>Array.&lt;string&gt;</code> \| <code>void</code>
    * [.saveConfigFile(properties)](#File.saveConfigFile) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.initPrettier([filetype])](#File.initPrettier) ⇒ <code>Promise.&lt;boolean&gt;</code>

<a name="File.copyFile"></a>

### File.copyFile(from, to) ⇒ <code>object</code>
copies a file from one path to another

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>object</code> - - results object  

| Param | Type | Description |
| --- | --- | --- |
| from | <code>string</code> | full filepath including name of existing file |
| to | <code>string</code> | full filepath including name where file should go |

<a name="File.filterIllegalPathChars"></a>

### File.filterIllegalPathChars(path) ⇒ <code>string</code>
makes sure Windows accepts path names

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>string</code> - - corrected string  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | filename or path |

<a name="File.filterIllegalFilenames"></a>

### File.filterIllegalFilenames(filename) ⇒ <code>string</code>
makes sure Windows accepts file names

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>string</code> - - corrected string  

| Param | Type | Description |
| --- | --- | --- |
| filename | <code>string</code> | filename or path |

<a name="File.reverseFilterIllegalFilenames"></a>

### File.reverseFilterIllegalFilenames(filename) ⇒ <code>string</code>
makes sure Windows accepts file names

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>string</code> - - corrected string  

| Param | Type | Description |
| --- | --- | --- |
| filename | <code>string</code> | filename or path |

<a name="File.normalizePath"></a>

### File.normalizePath(denormalizedPath) ⇒ <code>string</code>
Takes various types of path strings and formats into a platform specific path

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>string</code> - Path strings  

| Param | Type | Description |
| --- | --- | --- |
| denormalizedPath | <code>string</code> \| <code>Array.&lt;string&gt;</code> | directory the file will be written to |

<a name="File.writeJSONToFile"></a>

### File.writeJSONToFile(directory, filename, content) ⇒ <code>Promise</code>
Saves json content to a file in the local file system. Will create the parent directory if it does not exist

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>string</code> \| <code>Array.&lt;string&gt;</code> | directory the file will be written to |
| filename | <code>string</code> | name of the file without '.json' ending |
| content | <code>object</code> | filecontent |

<a name="File.writePrettyToFile"></a>

### File.writePrettyToFile(directory, filename, filetype, content, [templateVariables]) ⇒ <code>Promise.&lt;boolean&gt;</code>
Saves beautified files in the local file system. Will create the parent directory if it does not exist
! Important: run 'await File.initPrettier()' in your MetadataType.retrieve() once before hitting this

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>string</code> \| <code>Array.&lt;string&gt;</code> | directory the file will be written to |
| filename | <code>string</code> | name of the file without suffix |
| filetype | <code>string</code> | filetype ie. JSON or SSJS |
| content | <code>string</code> | filecontent |
| [templateVariables] | <code>TYPE.TemplateMap</code> | templating variables to be replaced in the metadata |

<a name="File._beautify_beautyAmp"></a>

### File.\_beautify\_beautyAmp(content) ⇒ <code>string</code>
helper for [writePrettyToFile](#File.writePrettyToFile), applying beautyAmp onto given stringified content

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>string</code> - original string on error; formatted string on success  

| Param | Type | Description |
| --- | --- | --- |
| content | <code>string</code> | filecontent |

<a name="File._beautify_prettier"></a>

### File.\_beautify\_prettier(directory, filename, filetype, content) ⇒ <code>string</code>
helper for [writePrettyToFile](#File.writePrettyToFile), applying prettier onto given stringified content
! Important: run 'await File.initPrettier()' in your MetadataType.retrieve() once before hitting this

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>string</code> - original string on error; formatted string on success  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>string</code> \| <code>Array.&lt;string&gt;</code> | directory the file will be written to |
| filename | <code>string</code> | name of the file without suffix |
| filetype | <code>string</code> | filetype ie. JSON or SSJS |
| content | <code>string</code> | filecontent |

<a name="File.writeToFile"></a>

### File.writeToFile(directory, filename, filetype, content, [encoding]) ⇒ <code>Promise.&lt;boolean&gt;</code>
Saves text content to a file in the local file system. Will create the parent directory if it does not exist

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>string</code> \| <code>Array.&lt;string&gt;</code> | directory the file will be written to |
| filename | <code>string</code> | name of the file without '.json' ending |
| filetype | <code>string</code> | filetype suffix |
| content | <code>string</code> | filecontent |
| [encoding] | <code>object</code> | added for certain file types (like images) |

<a name="File.readJSONFile"></a>

### File.readJSONFile(directory, filename, sync, cleanPath) ⇒ <code>Promise.&lt;object&gt;</code> \| <code>object</code> \| <code>void</code>
Saves json content to a file in the local file system. Will create the parent directory if it does not exist

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise.&lt;object&gt;</code> \| <code>object</code> \| <code>void</code> - Promise or JSON object depending on if async or not; void on error  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>string</code> \| <code>Array.&lt;string&gt;</code> | directory where the file is stored |
| filename | <code>string</code> | name of the file without '.json' ending |
| sync | <code>boolean</code> | should execute sync (default is async) |
| cleanPath | <code>boolean</code> | should execute sync (default is true) |

<a name="File.readFilteredFilename"></a>

### File.readFilteredFilename(directory, filename, filetype, [encoding]) ⇒ <code>Promise.&lt;string&gt;</code> \| <code>void</code>
reads file from local file system.

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise.&lt;string&gt;</code> \| <code>void</code> - file contents; void on error  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>string</code> \| <code>Array.&lt;string&gt;</code> | directory where the file is stored |
| filename | <code>string</code> | name of the file without '.json' ending |
| filetype | <code>string</code> | filetype suffix |
| [encoding] | <code>string</code> | read file with encoding (defaults to utf-8) |

<a name="File.readDirectories"></a>

### File.readDirectories(directory, depth, [includeStem], [_stemLength]) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
reads directories to a specific depth returning an array
of file paths to be iterated over

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - array of fully defined file paths  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>string</code> | directory to checkin |
| depth | <code>number</code> | how many levels to check (1 base) |
| [includeStem] | <code>boolean</code> | include the parent directory in the response |
| [_stemLength] | <code>number</code> | set recursively for subfolders. do not set manually! |

**Example**  
```js
['deploy/mcdev/bu1']
```
<a name="File.readDirectoriesSync"></a>

### File.readDirectoriesSync(directory, [depth], [includeStem], [_stemLength]) ⇒ <code>Array.&lt;string&gt;</code> \| <code>void</code>
reads directories to a specific depth returning an array
of file paths to be iterated over using sync api (required in constructors)
TODO - merge with readDirectories. so far the logic is really different

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Array.&lt;string&gt;</code> \| <code>void</code> - array of fully defined file paths; void on error  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>string</code> | directory to checkin |
| [depth] | <code>number</code> | how many levels to check (1 base) |
| [includeStem] | <code>boolean</code> | include the parent directory in the response |
| [_stemLength] | <code>number</code> | set recursively for subfolders. do not set manually! |

**Example**  
```js
['deploy/mcdev/bu1']
```
<a name="File.saveConfigFile"></a>

### File.saveConfigFile(properties) ⇒ <code>Promise.&lt;void&gt;</code>
helper that splits the config back into auth & config parts to save them separately

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | central properties object |

<a name="File.initPrettier"></a>

### File.initPrettier([filetype]) ⇒ <code>Promise.&lt;boolean&gt;</code>
Initalises Prettier formatting lib async.

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - success of config load  

| Param | Type | Description |
| --- | --- | --- |
| [filetype] | <code>string</code> | filetype ie. JSON or SSJS |

<a name="Init"></a>

## Init
CLI helper class

**Kind**: global constant  

* [Init](#Init)
    * [.fixMcdevConfig(properties)](#Init.fixMcdevConfig) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.createIdeConfigFiles(versionBeforeUpgrade)](#Init.createIdeConfigFiles) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [._updateLeaf(propertiersCur, defaultPropsCur, fieldName)](#Init._updateLeaf) ⇒ <code>void</code>
    * [._getForcedUpdateList(projectVersion)](#Init._getForcedUpdateList) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
    * [._createIdeConfigFile(fileNameArr, relevantForcedUpdates, [boilerplateFileContent])](#Init._createIdeConfigFile) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.upgradeAuthFile()](#Init.upgradeAuthFile) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.initGitRepo()](#Init.initGitRepo) ⇒ <code>Promise.&lt;{status: string, repoName: string}&gt;</code>
    * [.gitPush()](#Init.gitPush) ⇒ <code>void</code>
    * [._addGitRemote()](#Init._addGitRemote) ⇒ <code>string</code>
    * [._updateGitConfigUser()](#Init._updateGitConfigUser) ⇒ <code>void</code>
    * [._getGitConfigUser()](#Init._getGitConfigUser) ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: string, &#x27;user.email&#x27;: string}&gt;</code>
    * [.initProject(properties, credentialName)](#Init.initProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.joinProject()](#Init.joinProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._initMarkets()](#Init._initMarkets)
    * [._downloadAllBUs(bu, gitStatus)](#Init._downloadAllBUs) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.upgradeProject(properties, [initial], [repoName])](#Init.upgradeProject) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.installDependencies([repoName])](#Init.installDependencies) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [._getDefaultPackageJson([currentContent])](#Init._getDefaultPackageJson) ⇒ <code>Promise.&lt;{script: object, author: string, license: string}&gt;</code>

<a name="Init.fixMcdevConfig"></a>

### Init.fixMcdevConfig(properties) ⇒ <code>Promise.&lt;boolean&gt;</code>
helper method for this.upgradeProject that upgrades project config if needed

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - returns true if worked without errors  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |

<a name="Init.createIdeConfigFiles"></a>

### Init.createIdeConfigFiles(versionBeforeUpgrade) ⇒ <code>Promise.&lt;boolean&gt;</code>
handles creation/update of all config file from the boilerplate

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - status of config file creation  

| Param | Type | Description |
| --- | --- | --- |
| versionBeforeUpgrade | <code>string</code> | 'x.y.z' |

<a name="Init._updateLeaf"></a>

### Init.\_updateLeaf(propertiersCur, defaultPropsCur, fieldName) ⇒ <code>void</code>
recursive helper for [fixMcdevConfig](#Init.fixMcdevConfig) that adds missing settings

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| propertiersCur | <code>object</code> | current sub-object of project settings |
| defaultPropsCur | <code>object</code> | current sub-object of default settings |
| fieldName | <code>string</code> | dot-concatenated object-path that needs adding |

<a name="Init._getForcedUpdateList"></a>

### Init.\_getForcedUpdateList(projectVersion) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
returns list of files that need to be updated

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - relevant files with path that need to be updated  

| Param | Type | Description |
| --- | --- | --- |
| projectVersion | <code>string</code> | version found in config file of the current project |

<a name="Init._createIdeConfigFile"></a>

### Init.\_createIdeConfigFile(fileNameArr, relevantForcedUpdates, [boilerplateFileContent]) ⇒ <code>Promise.&lt;boolean&gt;</code>
handles creation/update of one config file from the boilerplate at a time

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| fileNameArr | <code>Array.&lt;string&gt;</code> | 0: path, 1: filename, 2: extension with dot |
| relevantForcedUpdates | <code>Array.&lt;string&gt;</code> | if fileNameArr is in this list we require an override |
| [boilerplateFileContent] | <code>string</code> | in case we cannot copy files 1:1 this can be used to pass in content |

<a name="Init.upgradeAuthFile"></a>

### Init.upgradeAuthFile() ⇒ <code>Promise.&lt;boolean&gt;</code>
helper method for this.upgradeProject that upgrades project config if needed

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - returns true if worked without errors  
<a name="Init.initGitRepo"></a>

### Init.initGitRepo() ⇒ <code>Promise.&lt;{status: string, repoName: string}&gt;</code>
check if git repo exists and otherwise create one

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{status: string, repoName: string}&gt;</code> - success flag  
<a name="Init.gitPush"></a>

### Init.gitPush() ⇒ <code>void</code>
offer to push the new repo straight to the server

**Kind**: static method of [<code>Init</code>](#Init)  
<a name="Init._addGitRemote"></a>

### Init.\_addGitRemote() ⇒ <code>string</code>
offers to add the git remote origin

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>string</code> - repo name (optionally)  
<a name="Init._updateGitConfigUser"></a>

### Init.\_updateGitConfigUser() ⇒ <code>void</code>
checks global config and ask to config the user info and then store it locally

**Kind**: static method of [<code>Init</code>](#Init)  
<a name="Init._getGitConfigUser"></a>

### Init.\_getGitConfigUser() ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: string, &#x27;user.email&#x27;: string}&gt;</code>
retrieves the global user.name and user.email values

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{&#x27;user.name&#x27;: string, &#x27;user.email&#x27;: string}&gt;</code> - user.name and user.email  
<a name="Init.initProject"></a>

### Init.initProject(properties, credentialName) ⇒ <code>Promise.&lt;void&gt;</code>
Creates template file for properties.json

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |
| credentialName | <code>string</code> | identifying name of the installed package / project |

<a name="Init.joinProject"></a>

### Init.joinProject() ⇒ <code>Promise.&lt;void&gt;</code>
Creates template file for properties.json

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  
<a name="Init._initMarkets"></a>

### Init.\_initMarkets()
helper for @initProject that optionally creates markets and market lists for all BUs

**Kind**: static method of [<code>Init</code>](#Init)  
<a name="Init._downloadAllBUs"></a>

### Init.\_downloadAllBUs(bu, gitStatus) ⇒ <code>Promise.&lt;void&gt;</code>
helper for [initProject](#Init.initProject)

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| bu | <code>string</code> | cred/bu or cred/* or * |
| gitStatus | <code>string</code> | signals what state the git repo is in |

<a name="Init.upgradeProject"></a>

### Init.upgradeProject(properties, [initial], [repoName]) ⇒ <code>Promise.&lt;boolean&gt;</code>
wrapper around npm dependency & configuration file setup

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - success flag  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |
| [initial] | <code>boolean</code> | print message if not part of initial setup |
| [repoName] | <code>string</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init.installDependencies"></a>

### Init.installDependencies([repoName]) ⇒ <code>Promise.&lt;boolean&gt;</code>
initiates npm project and then
takes care of loading the pre-configured dependency list
from the boilerplate directory to them as dev-dependencies

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| [repoName] | <code>string</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init._getDefaultPackageJson"></a>

### Init.\_getDefaultPackageJson([currentContent]) ⇒ <code>Promise.&lt;{script: object, author: string, license: string}&gt;</code>
ensure we have certain default values in our config

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{script: object, author: string, license: string}&gt;</code> - extended currentContent  

| Param | Type | Description |
| --- | --- | --- |
| [currentContent] | <code>object</code> | what was read from existing package.json file |

<a name="Init"></a>

## Init
CLI helper class

**Kind**: global constant  

* [Init](#Init)
    * [.fixMcdevConfig(properties)](#Init.fixMcdevConfig) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.createIdeConfigFiles(versionBeforeUpgrade)](#Init.createIdeConfigFiles) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [._updateLeaf(propertiersCur, defaultPropsCur, fieldName)](#Init._updateLeaf) ⇒ <code>void</code>
    * [._getForcedUpdateList(projectVersion)](#Init._getForcedUpdateList) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
    * [._createIdeConfigFile(fileNameArr, relevantForcedUpdates, [boilerplateFileContent])](#Init._createIdeConfigFile) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.upgradeAuthFile()](#Init.upgradeAuthFile) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.initGitRepo()](#Init.initGitRepo) ⇒ <code>Promise.&lt;{status: string, repoName: string}&gt;</code>
    * [.gitPush()](#Init.gitPush) ⇒ <code>void</code>
    * [._addGitRemote()](#Init._addGitRemote) ⇒ <code>string</code>
    * [._updateGitConfigUser()](#Init._updateGitConfigUser) ⇒ <code>void</code>
    * [._getGitConfigUser()](#Init._getGitConfigUser) ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: string, &#x27;user.email&#x27;: string}&gt;</code>
    * [.initProject(properties, credentialName)](#Init.initProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.joinProject()](#Init.joinProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._initMarkets()](#Init._initMarkets)
    * [._downloadAllBUs(bu, gitStatus)](#Init._downloadAllBUs) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.upgradeProject(properties, [initial], [repoName])](#Init.upgradeProject) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.installDependencies([repoName])](#Init.installDependencies) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [._getDefaultPackageJson([currentContent])](#Init._getDefaultPackageJson) ⇒ <code>Promise.&lt;{script: object, author: string, license: string}&gt;</code>

<a name="Init.fixMcdevConfig"></a>

### Init.fixMcdevConfig(properties) ⇒ <code>Promise.&lt;boolean&gt;</code>
helper method for this.upgradeProject that upgrades project config if needed

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - returns true if worked without errors  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |

<a name="Init.createIdeConfigFiles"></a>

### Init.createIdeConfigFiles(versionBeforeUpgrade) ⇒ <code>Promise.&lt;boolean&gt;</code>
handles creation/update of all config file from the boilerplate

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - status of config file creation  

| Param | Type | Description |
| --- | --- | --- |
| versionBeforeUpgrade | <code>string</code> | 'x.y.z' |

<a name="Init._updateLeaf"></a>

### Init.\_updateLeaf(propertiersCur, defaultPropsCur, fieldName) ⇒ <code>void</code>
recursive helper for [fixMcdevConfig](#Init.fixMcdevConfig) that adds missing settings

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| propertiersCur | <code>object</code> | current sub-object of project settings |
| defaultPropsCur | <code>object</code> | current sub-object of default settings |
| fieldName | <code>string</code> | dot-concatenated object-path that needs adding |

<a name="Init._getForcedUpdateList"></a>

### Init.\_getForcedUpdateList(projectVersion) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
returns list of files that need to be updated

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - relevant files with path that need to be updated  

| Param | Type | Description |
| --- | --- | --- |
| projectVersion | <code>string</code> | version found in config file of the current project |

<a name="Init._createIdeConfigFile"></a>

### Init.\_createIdeConfigFile(fileNameArr, relevantForcedUpdates, [boilerplateFileContent]) ⇒ <code>Promise.&lt;boolean&gt;</code>
handles creation/update of one config file from the boilerplate at a time

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| fileNameArr | <code>Array.&lt;string&gt;</code> | 0: path, 1: filename, 2: extension with dot |
| relevantForcedUpdates | <code>Array.&lt;string&gt;</code> | if fileNameArr is in this list we require an override |
| [boilerplateFileContent] | <code>string</code> | in case we cannot copy files 1:1 this can be used to pass in content |

<a name="Init.upgradeAuthFile"></a>

### Init.upgradeAuthFile() ⇒ <code>Promise.&lt;boolean&gt;</code>
helper method for this.upgradeProject that upgrades project config if needed

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - returns true if worked without errors  
<a name="Init.initGitRepo"></a>

### Init.initGitRepo() ⇒ <code>Promise.&lt;{status: string, repoName: string}&gt;</code>
check if git repo exists and otherwise create one

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{status: string, repoName: string}&gt;</code> - success flag  
<a name="Init.gitPush"></a>

### Init.gitPush() ⇒ <code>void</code>
offer to push the new repo straight to the server

**Kind**: static method of [<code>Init</code>](#Init)  
<a name="Init._addGitRemote"></a>

### Init.\_addGitRemote() ⇒ <code>string</code>
offers to add the git remote origin

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>string</code> - repo name (optionally)  
<a name="Init._updateGitConfigUser"></a>

### Init.\_updateGitConfigUser() ⇒ <code>void</code>
checks global config and ask to config the user info and then store it locally

**Kind**: static method of [<code>Init</code>](#Init)  
<a name="Init._getGitConfigUser"></a>

### Init.\_getGitConfigUser() ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: string, &#x27;user.email&#x27;: string}&gt;</code>
retrieves the global user.name and user.email values

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{&#x27;user.name&#x27;: string, &#x27;user.email&#x27;: string}&gt;</code> - user.name and user.email  
<a name="Init.initProject"></a>

### Init.initProject(properties, credentialName) ⇒ <code>Promise.&lt;void&gt;</code>
Creates template file for properties.json

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |
| credentialName | <code>string</code> | identifying name of the installed package / project |

<a name="Init.joinProject"></a>

### Init.joinProject() ⇒ <code>Promise.&lt;void&gt;</code>
Creates template file for properties.json

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  
<a name="Init._initMarkets"></a>

### Init.\_initMarkets()
helper for @initProject that optionally creates markets and market lists for all BUs

**Kind**: static method of [<code>Init</code>](#Init)  
<a name="Init._downloadAllBUs"></a>

### Init.\_downloadAllBUs(bu, gitStatus) ⇒ <code>Promise.&lt;void&gt;</code>
helper for [initProject](#Init.initProject)

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| bu | <code>string</code> | cred/bu or cred/* or * |
| gitStatus | <code>string</code> | signals what state the git repo is in |

<a name="Init.upgradeProject"></a>

### Init.upgradeProject(properties, [initial], [repoName]) ⇒ <code>Promise.&lt;boolean&gt;</code>
wrapper around npm dependency & configuration file setup

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - success flag  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |
| [initial] | <code>boolean</code> | print message if not part of initial setup |
| [repoName] | <code>string</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init.installDependencies"></a>

### Init.installDependencies([repoName]) ⇒ <code>Promise.&lt;boolean&gt;</code>
initiates npm project and then
takes care of loading the pre-configured dependency list
from the boilerplate directory to them as dev-dependencies

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| [repoName] | <code>string</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init._getDefaultPackageJson"></a>

### Init.\_getDefaultPackageJson([currentContent]) ⇒ <code>Promise.&lt;{script: object, author: string, license: string}&gt;</code>
ensure we have certain default values in our config

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{script: object, author: string, license: string}&gt;</code> - extended currentContent  

| Param | Type | Description |
| --- | --- | --- |
| [currentContent] | <code>object</code> | what was read from existing package.json file |

<a name="Init"></a>

## Init
CLI helper class

**Kind**: global constant  

* [Init](#Init)
    * [.fixMcdevConfig(properties)](#Init.fixMcdevConfig) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.createIdeConfigFiles(versionBeforeUpgrade)](#Init.createIdeConfigFiles) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [._updateLeaf(propertiersCur, defaultPropsCur, fieldName)](#Init._updateLeaf) ⇒ <code>void</code>
    * [._getForcedUpdateList(projectVersion)](#Init._getForcedUpdateList) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
    * [._createIdeConfigFile(fileNameArr, relevantForcedUpdates, [boilerplateFileContent])](#Init._createIdeConfigFile) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.upgradeAuthFile()](#Init.upgradeAuthFile) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.initGitRepo()](#Init.initGitRepo) ⇒ <code>Promise.&lt;{status: string, repoName: string}&gt;</code>
    * [.gitPush()](#Init.gitPush) ⇒ <code>void</code>
    * [._addGitRemote()](#Init._addGitRemote) ⇒ <code>string</code>
    * [._updateGitConfigUser()](#Init._updateGitConfigUser) ⇒ <code>void</code>
    * [._getGitConfigUser()](#Init._getGitConfigUser) ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: string, &#x27;user.email&#x27;: string}&gt;</code>
    * [.initProject(properties, credentialName)](#Init.initProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.joinProject()](#Init.joinProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._initMarkets()](#Init._initMarkets)
    * [._downloadAllBUs(bu, gitStatus)](#Init._downloadAllBUs) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.upgradeProject(properties, [initial], [repoName])](#Init.upgradeProject) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.installDependencies([repoName])](#Init.installDependencies) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [._getDefaultPackageJson([currentContent])](#Init._getDefaultPackageJson) ⇒ <code>Promise.&lt;{script: object, author: string, license: string}&gt;</code>

<a name="Init.fixMcdevConfig"></a>

### Init.fixMcdevConfig(properties) ⇒ <code>Promise.&lt;boolean&gt;</code>
helper method for this.upgradeProject that upgrades project config if needed

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - returns true if worked without errors  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |

<a name="Init.createIdeConfigFiles"></a>

### Init.createIdeConfigFiles(versionBeforeUpgrade) ⇒ <code>Promise.&lt;boolean&gt;</code>
handles creation/update of all config file from the boilerplate

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - status of config file creation  

| Param | Type | Description |
| --- | --- | --- |
| versionBeforeUpgrade | <code>string</code> | 'x.y.z' |

<a name="Init._updateLeaf"></a>

### Init.\_updateLeaf(propertiersCur, defaultPropsCur, fieldName) ⇒ <code>void</code>
recursive helper for [fixMcdevConfig](#Init.fixMcdevConfig) that adds missing settings

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| propertiersCur | <code>object</code> | current sub-object of project settings |
| defaultPropsCur | <code>object</code> | current sub-object of default settings |
| fieldName | <code>string</code> | dot-concatenated object-path that needs adding |

<a name="Init._getForcedUpdateList"></a>

### Init.\_getForcedUpdateList(projectVersion) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
returns list of files that need to be updated

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - relevant files with path that need to be updated  

| Param | Type | Description |
| --- | --- | --- |
| projectVersion | <code>string</code> | version found in config file of the current project |

<a name="Init._createIdeConfigFile"></a>

### Init.\_createIdeConfigFile(fileNameArr, relevantForcedUpdates, [boilerplateFileContent]) ⇒ <code>Promise.&lt;boolean&gt;</code>
handles creation/update of one config file from the boilerplate at a time

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| fileNameArr | <code>Array.&lt;string&gt;</code> | 0: path, 1: filename, 2: extension with dot |
| relevantForcedUpdates | <code>Array.&lt;string&gt;</code> | if fileNameArr is in this list we require an override |
| [boilerplateFileContent] | <code>string</code> | in case we cannot copy files 1:1 this can be used to pass in content |

<a name="Init.upgradeAuthFile"></a>

### Init.upgradeAuthFile() ⇒ <code>Promise.&lt;boolean&gt;</code>
helper method for this.upgradeProject that upgrades project config if needed

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - returns true if worked without errors  
<a name="Init.initGitRepo"></a>

### Init.initGitRepo() ⇒ <code>Promise.&lt;{status: string, repoName: string}&gt;</code>
check if git repo exists and otherwise create one

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{status: string, repoName: string}&gt;</code> - success flag  
<a name="Init.gitPush"></a>

### Init.gitPush() ⇒ <code>void</code>
offer to push the new repo straight to the server

**Kind**: static method of [<code>Init</code>](#Init)  
<a name="Init._addGitRemote"></a>

### Init.\_addGitRemote() ⇒ <code>string</code>
offers to add the git remote origin

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>string</code> - repo name (optionally)  
<a name="Init._updateGitConfigUser"></a>

### Init.\_updateGitConfigUser() ⇒ <code>void</code>
checks global config and ask to config the user info and then store it locally

**Kind**: static method of [<code>Init</code>](#Init)  
<a name="Init._getGitConfigUser"></a>

### Init.\_getGitConfigUser() ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: string, &#x27;user.email&#x27;: string}&gt;</code>
retrieves the global user.name and user.email values

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{&#x27;user.name&#x27;: string, &#x27;user.email&#x27;: string}&gt;</code> - user.name and user.email  
<a name="Init.initProject"></a>

### Init.initProject(properties, credentialName) ⇒ <code>Promise.&lt;void&gt;</code>
Creates template file for properties.json

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |
| credentialName | <code>string</code> | identifying name of the installed package / project |

<a name="Init.joinProject"></a>

### Init.joinProject() ⇒ <code>Promise.&lt;void&gt;</code>
Creates template file for properties.json

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  
<a name="Init._initMarkets"></a>

### Init.\_initMarkets()
helper for @initProject that optionally creates markets and market lists for all BUs

**Kind**: static method of [<code>Init</code>](#Init)  
<a name="Init._downloadAllBUs"></a>

### Init.\_downloadAllBUs(bu, gitStatus) ⇒ <code>Promise.&lt;void&gt;</code>
helper for [initProject](#Init.initProject)

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| bu | <code>string</code> | cred/bu or cred/* or * |
| gitStatus | <code>string</code> | signals what state the git repo is in |

<a name="Init.upgradeProject"></a>

### Init.upgradeProject(properties, [initial], [repoName]) ⇒ <code>Promise.&lt;boolean&gt;</code>
wrapper around npm dependency & configuration file setup

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - success flag  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |
| [initial] | <code>boolean</code> | print message if not part of initial setup |
| [repoName] | <code>string</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init.installDependencies"></a>

### Init.installDependencies([repoName]) ⇒ <code>Promise.&lt;boolean&gt;</code>
initiates npm project and then
takes care of loading the pre-configured dependency list
from the boilerplate directory to them as dev-dependencies

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| [repoName] | <code>string</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init._getDefaultPackageJson"></a>

### Init.\_getDefaultPackageJson([currentContent]) ⇒ <code>Promise.&lt;{script: object, author: string, license: string}&gt;</code>
ensure we have certain default values in our config

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{script: object, author: string, license: string}&gt;</code> - extended currentContent  

| Param | Type | Description |
| --- | --- | --- |
| [currentContent] | <code>object</code> | what was read from existing package.json file |

<a name="Init"></a>

## Init
CLI helper class

**Kind**: global constant  

* [Init](#Init)
    * [.fixMcdevConfig(properties)](#Init.fixMcdevConfig) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.createIdeConfigFiles(versionBeforeUpgrade)](#Init.createIdeConfigFiles) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [._updateLeaf(propertiersCur, defaultPropsCur, fieldName)](#Init._updateLeaf) ⇒ <code>void</code>
    * [._getForcedUpdateList(projectVersion)](#Init._getForcedUpdateList) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
    * [._createIdeConfigFile(fileNameArr, relevantForcedUpdates, [boilerplateFileContent])](#Init._createIdeConfigFile) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.upgradeAuthFile()](#Init.upgradeAuthFile) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.initGitRepo()](#Init.initGitRepo) ⇒ <code>Promise.&lt;{status: string, repoName: string}&gt;</code>
    * [.gitPush()](#Init.gitPush) ⇒ <code>void</code>
    * [._addGitRemote()](#Init._addGitRemote) ⇒ <code>string</code>
    * [._updateGitConfigUser()](#Init._updateGitConfigUser) ⇒ <code>void</code>
    * [._getGitConfigUser()](#Init._getGitConfigUser) ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: string, &#x27;user.email&#x27;: string}&gt;</code>
    * [.initProject(properties, credentialName)](#Init.initProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.joinProject()](#Init.joinProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._initMarkets()](#Init._initMarkets)
    * [._downloadAllBUs(bu, gitStatus)](#Init._downloadAllBUs) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.upgradeProject(properties, [initial], [repoName])](#Init.upgradeProject) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.installDependencies([repoName])](#Init.installDependencies) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [._getDefaultPackageJson([currentContent])](#Init._getDefaultPackageJson) ⇒ <code>Promise.&lt;{script: object, author: string, license: string}&gt;</code>

<a name="Init.fixMcdevConfig"></a>

### Init.fixMcdevConfig(properties) ⇒ <code>Promise.&lt;boolean&gt;</code>
helper method for this.upgradeProject that upgrades project config if needed

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - returns true if worked without errors  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |

<a name="Init.createIdeConfigFiles"></a>

### Init.createIdeConfigFiles(versionBeforeUpgrade) ⇒ <code>Promise.&lt;boolean&gt;</code>
handles creation/update of all config file from the boilerplate

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - status of config file creation  

| Param | Type | Description |
| --- | --- | --- |
| versionBeforeUpgrade | <code>string</code> | 'x.y.z' |

<a name="Init._updateLeaf"></a>

### Init.\_updateLeaf(propertiersCur, defaultPropsCur, fieldName) ⇒ <code>void</code>
recursive helper for [fixMcdevConfig](#Init.fixMcdevConfig) that adds missing settings

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| propertiersCur | <code>object</code> | current sub-object of project settings |
| defaultPropsCur | <code>object</code> | current sub-object of default settings |
| fieldName | <code>string</code> | dot-concatenated object-path that needs adding |

<a name="Init._getForcedUpdateList"></a>

### Init.\_getForcedUpdateList(projectVersion) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
returns list of files that need to be updated

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - relevant files with path that need to be updated  

| Param | Type | Description |
| --- | --- | --- |
| projectVersion | <code>string</code> | version found in config file of the current project |

<a name="Init._createIdeConfigFile"></a>

### Init.\_createIdeConfigFile(fileNameArr, relevantForcedUpdates, [boilerplateFileContent]) ⇒ <code>Promise.&lt;boolean&gt;</code>
handles creation/update of one config file from the boilerplate at a time

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| fileNameArr | <code>Array.&lt;string&gt;</code> | 0: path, 1: filename, 2: extension with dot |
| relevantForcedUpdates | <code>Array.&lt;string&gt;</code> | if fileNameArr is in this list we require an override |
| [boilerplateFileContent] | <code>string</code> | in case we cannot copy files 1:1 this can be used to pass in content |

<a name="Init.upgradeAuthFile"></a>

### Init.upgradeAuthFile() ⇒ <code>Promise.&lt;boolean&gt;</code>
helper method for this.upgradeProject that upgrades project config if needed

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - returns true if worked without errors  
<a name="Init.initGitRepo"></a>

### Init.initGitRepo() ⇒ <code>Promise.&lt;{status: string, repoName: string}&gt;</code>
check if git repo exists and otherwise create one

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{status: string, repoName: string}&gt;</code> - success flag  
<a name="Init.gitPush"></a>

### Init.gitPush() ⇒ <code>void</code>
offer to push the new repo straight to the server

**Kind**: static method of [<code>Init</code>](#Init)  
<a name="Init._addGitRemote"></a>

### Init.\_addGitRemote() ⇒ <code>string</code>
offers to add the git remote origin

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>string</code> - repo name (optionally)  
<a name="Init._updateGitConfigUser"></a>

### Init.\_updateGitConfigUser() ⇒ <code>void</code>
checks global config and ask to config the user info and then store it locally

**Kind**: static method of [<code>Init</code>](#Init)  
<a name="Init._getGitConfigUser"></a>

### Init.\_getGitConfigUser() ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: string, &#x27;user.email&#x27;: string}&gt;</code>
retrieves the global user.name and user.email values

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{&#x27;user.name&#x27;: string, &#x27;user.email&#x27;: string}&gt;</code> - user.name and user.email  
<a name="Init.initProject"></a>

### Init.initProject(properties, credentialName) ⇒ <code>Promise.&lt;void&gt;</code>
Creates template file for properties.json

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |
| credentialName | <code>string</code> | identifying name of the installed package / project |

<a name="Init.joinProject"></a>

### Init.joinProject() ⇒ <code>Promise.&lt;void&gt;</code>
Creates template file for properties.json

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  
<a name="Init._initMarkets"></a>

### Init.\_initMarkets()
helper for @initProject that optionally creates markets and market lists for all BUs

**Kind**: static method of [<code>Init</code>](#Init)  
<a name="Init._downloadAllBUs"></a>

### Init.\_downloadAllBUs(bu, gitStatus) ⇒ <code>Promise.&lt;void&gt;</code>
helper for [initProject](#Init.initProject)

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| bu | <code>string</code> | cred/bu or cred/* or * |
| gitStatus | <code>string</code> | signals what state the git repo is in |

<a name="Init.upgradeProject"></a>

### Init.upgradeProject(properties, [initial], [repoName]) ⇒ <code>Promise.&lt;boolean&gt;</code>
wrapper around npm dependency & configuration file setup

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - success flag  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>TYPE.Mcdevrc</code> | config file's json |
| [initial] | <code>boolean</code> | print message if not part of initial setup |
| [repoName] | <code>string</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init.installDependencies"></a>

### Init.installDependencies([repoName]) ⇒ <code>Promise.&lt;boolean&gt;</code>
initiates npm project and then
takes care of loading the pre-configured dependency list
from the boilerplate directory to them as dev-dependencies

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| [repoName] | <code>string</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init._getDefaultPackageJson"></a>

### Init.\_getDefaultPackageJson([currentContent]) ⇒ <code>Promise.&lt;{script: object, author: string, license: string}&gt;</code>
ensure we have certain default values in our config

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{script: object, author: string, license: string}&gt;</code> - extended currentContent  

| Param | Type | Description |
| --- | --- | --- |
| [currentContent] | <code>object</code> | what was read from existing package.json file |

<a name="Util"></a>

## Util
Util that contains logger and simple util methods

**Kind**: global constant  

* [Util](#Util)
    * [.skipInteraction](#Util.skipInteraction) : <code>TYPE.skipInteraction</code>
    * [.logger](#Util.logger) : <code>TYPE.Logger</code>
    * [.filterObjByKeys(originalObj, [whitelistArr])](#Util.filterObjByKeys) ⇒ <code>Object.&lt;string, \*&gt;</code>
    * [.includesStartsWith(arr, search)](#Util.includesStartsWith) ⇒ <code>boolean</code>
    * [.includesStartsWithIndex(arr, search)](#Util.includesStartsWithIndex) ⇒ <code>number</code>
    * [.checkMarket(market, properties)](#Util.checkMarket) ⇒ <code>boolean</code>
    * [.verifyMarketList(mlName, properties)](#Util.verifyMarketList)
    * [.signalFatalError()](#Util.signalFatalError) ⇒ <code>void</code>
    * [.isTrue(attrValue)](#Util.isTrue) ⇒ <code>boolean</code>
    * [.isFalse(attrValue)](#Util.isFalse) ⇒ <code>boolean</code>
    * [._isValidType(selectedType, [handleOutside])](#Util._isValidType) ⇒ <code>boolean</code>
    * [.getTypeAndSubType(selectedType)](#Util.getTypeAndSubType) ⇒ <code>Array.&lt;string&gt;</code>
    * [.emailValidator(email)](#Util.emailValidator) ⇒ <code>boolean</code>
    * [.getRetrieveTypeChoices()](#Util.getRetrieveTypeChoices) ⇒ <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code>
    * [._createNewLoggerTransport([noLogFile])](#Util._createNewLoggerTransport) ⇒ <code>object</code>
    * [.startLogger([restart], [noLogFile])](#Util.startLogger) ⇒ <code>void</code>
    * [.metadataLogger(level, type, method, payload, [source])](#Util.metadataLogger) ⇒ <code>void</code>
    * [.replaceByObject(str, obj)](#Util.replaceByObject) ⇒ <code>string</code> \| <code>object</code>
    * [.inverseGet(objs, val)](#Util.inverseGet) ⇒ <code>string</code>
    * [.getDependentMetadata(fixedType)](#Util.getDependentMetadata) ⇒ <code>Array.&lt;string&gt;</code>
    * [.getMetadataHierachy(metadataTypes)](#Util.getMetadataHierachy) ⇒ <code>Object.&lt;string, Array.&lt;string&gt;&gt;</code>
    * [.resolveObjPath(path, obj)](#Util.resolveObjPath) ⇒ <code>any</code>
    * [.execSync(cmd, [args], [hideOutput])](#Util.execSync) ⇒ <code>string</code> \| <code>void</code>
    * [.templateSearchResult(results, keyToSearch, searchValue)](#Util.templateSearchResult) ⇒ <code>TYPE.MetadataTypeItem</code>
    * [.setLoggingLevel(argv)](#Util.setLoggingLevel) ⇒ <code>void</code>
    * [.logBeta(type)](#Util.logBeta)
    * [.getGrayMsg(msg)](#Util.getGrayMsg) ⇒ <code>string</code>
    * [.logSubtypes(subTypeArr)](#Util.logSubtypes) ⇒ <code>void</code>
    * [.getKeysString(keyArr, [isId])](#Util.getKeysString) ⇒ <code>string</code>
    * [.sleep(ms)](#Util.sleep) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.getSsjs(code)](#Util.getSsjs) ⇒ <code>string</code>
    * [.stringLike(testString, search)](#Util.stringLike) ⇒ <code>boolean</code>
    * [.fieldsLike(metadata, [filters])](#Util.fieldsLike) ⇒ <code>boolean</code>
    * [.capitalizeFirstLetter(str)](#Util.capitalizeFirstLetter) ⇒ <code>string</code>

<a name="Util.skipInteraction"></a>

### Util.skipInteraction : <code>TYPE.skipInteraction</code>
**Kind**: static property of [<code>Util</code>](#Util)  
<a name="Util.logger"></a>

### Util.logger : <code>TYPE.Logger</code>
Logger that creates timestamped log file in 'logs/' directory

**Kind**: static property of [<code>Util</code>](#Util)  
<a name="Util.filterObjByKeys"></a>

### Util.filterObjByKeys(originalObj, [whitelistArr]) ⇒ <code>Object.&lt;string, \*&gt;</code>
helper that allows filtering an object by its keys

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Object.&lt;string, \*&gt;</code> - filtered object that only contains keys you provided  

| Param | Type | Description |
| --- | --- | --- |
| originalObj | <code>Object.&lt;string, \*&gt;</code> | object that you want to filter |
| [whitelistArr] | <code>Array.&lt;string&gt;</code> | positive filter. if not provided, returns originalObj without filter |

<a name="Util.includesStartsWith"></a>

### Util.includesStartsWith(arr, search) ⇒ <code>boolean</code>
extended Array.includes method that allows check if an array-element starts with a certain string

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - found / not found  

| Param | Type | Description |
| --- | --- | --- |
| arr | <code>Array.&lt;string&gt;</code> | your array of strigns |
| search | <code>string</code> | the string you are looking for |

<a name="Util.includesStartsWithIndex"></a>

### Util.includesStartsWithIndex(arr, search) ⇒ <code>number</code>
extended Array.includes method that allows check if an array-element starts with a certain string

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>number</code> - array index 0..n or -1 of not found  

| Param | Type | Description |
| --- | --- | --- |
| arr | <code>Array.&lt;string&gt;</code> | your array of strigns |
| search | <code>string</code> | the string you are looking for |

<a name="Util.checkMarket"></a>

### Util.checkMarket(market, properties) ⇒ <code>boolean</code>
check if a market name exists in current mcdev config

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - found market or not  

| Param | Type | Description |
| --- | --- | --- |
| market | <code>string</code> | market localizations |
| properties | <code>TYPE.Mcdevrc</code> | local mcdev config |

<a name="Util.verifyMarketList"></a>

### Util.verifyMarketList(mlName, properties)
ensure provided MarketList exists and it's content including markets and BUs checks out

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| mlName | <code>string</code> | name of marketList |
| properties | <code>TYPE.Mcdevrc</code> | General configuration to be used in retrieve |

<a name="Util.signalFatalError"></a>

### Util.signalFatalError() ⇒ <code>void</code>
used to ensure the program tells surrounding software that an unrecoverable error occured

**Kind**: static method of [<code>Util</code>](#Util)  
<a name="Util.isTrue"></a>

### Util.isTrue(attrValue) ⇒ <code>boolean</code>
SFMC accepts multiple true values for Boolean attributes for which we are checking here.
The same problem occurs when evaluating boolean CLI flags

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - attribute value == true ? true : false  

| Param | Type | Description |
| --- | --- | --- |
| attrValue | <code>\*</code> | value |

<a name="Util.isFalse"></a>

### Util.isFalse(attrValue) ⇒ <code>boolean</code>
SFMC accepts multiple false values for Boolean attributes for which we are checking here.
The same problem occurs when evaluating boolean CLI flags

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - attribute value == false ? true : false  

| Param | Type | Description |
| --- | --- | --- |
| attrValue | <code>\*</code> | value |

<a name="Util._isValidType"></a>

### Util.\_isValidType(selectedType, [handleOutside]) ⇒ <code>boolean</code>
helper for Mcdev.retrieve, Mcdev.retrieveAsTemplate and Mcdev.deploy

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - type ok or not  

| Param | Type | Description |
| --- | --- | --- |
| selectedType | <code>TYPE.SupportedMetadataTypes</code> | type or type-subtype |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="Util.getTypeAndSubType"></a>

### Util.getTypeAndSubType(selectedType) ⇒ <code>Array.&lt;string&gt;</code>
helper that deals with extracting type and subtype

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Array.&lt;string&gt;</code> - first elem is type, second elem is subType  

| Param | Type | Description |
| --- | --- | --- |
| selectedType | <code>string</code> | "type" or "type-subtype" |

<a name="Util.emailValidator"></a>

### Util.emailValidator(email) ⇒ <code>boolean</code>
helper that validates email address

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - first elem is type, second elem is subType  

| Param | Type | Description |
| --- | --- | --- |
| email | <code>string</code> | email to validate |

<a name="Util.getRetrieveTypeChoices"></a>

### Util.getRetrieveTypeChoices() ⇒ <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code>
helper for getDefaultProperties()

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Array.&lt;TYPE.SupportedMetadataTypes&gt;</code> - type choices  
<a name="Util._createNewLoggerTransport"></a>

### Util.\_createNewLoggerTransport([noLogFile]) ⇒ <code>object</code>
wrapper around our standard winston logging to console and logfile

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>object</code> - initiated logger for console and file  

| Param | Type | Description |
| --- | --- | --- |
| [noLogFile] | <code>boolean</code> | optional flag to indicate if we should log to file; CLI logs are always on |

<a name="Util.startLogger"></a>

### Util.startLogger([restart], [noLogFile]) ⇒ <code>void</code>
initiate winston logger

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| [restart] | <code>boolean</code> | if true, logger will be restarted; otherwise, an existing logger will be used |
| [noLogFile] | <code>boolean</code> | if false, logger will log to file; otherwise, only to console |

<a name="Util.metadataLogger"></a>

### Util.metadataLogger(level, type, method, payload, [source]) ⇒ <code>void</code>
Logger helper for Metadata functions

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| level | <code>string</code> | of log (error, info, warn) |
| type | <code>string</code> | of metadata being referenced |
| method | <code>string</code> | name which log was called from |
| payload | <code>\*</code> | generic object which details the error |
| [source] | <code>string</code> | key/id of metadata which relates to error |

<a name="Util.replaceByObject"></a>

### Util.replaceByObject(str, obj) ⇒ <code>string</code> \| <code>object</code>
replaces values in a JSON object string, based on a series of
key-value pairs (obj)

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>string</code> \| <code>object</code> - replaced version of str  

| Param | Type | Description |
| --- | --- | --- |
| str | <code>string</code> \| <code>object</code> | JSON object or its stringified version, which has values to be replaced |
| obj | <code>TYPE.TemplateMap</code> | key value object which contains keys to be replaced and values to be replaced with |

<a name="Util.inverseGet"></a>

### Util.inverseGet(objs, val) ⇒ <code>string</code>
get key of an object based on the first matching value

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>string</code> - key  

| Param | Type | Description |
| --- | --- | --- |
| objs | <code>object</code> | object of objects to be searched |
| val | <code>string</code> | value to be searched for |

<a name="Util.getDependentMetadata"></a>

### Util.getDependentMetadata(fixedType) ⇒ <code>Array.&lt;string&gt;</code>
helper for Mcdev.fixKeys. Retrieve dependent metadata

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Array.&lt;string&gt;</code> - array of types that depend on the given type  

| Param | Type | Description |
| --- | --- | --- |
| fixedType | <code>string</code> | type of the metadata passed as a parameter to fixKeys function |

<a name="Util.getMetadataHierachy"></a>

### Util.getMetadataHierachy(metadataTypes) ⇒ <code>Object.&lt;string, Array.&lt;string&gt;&gt;</code>
Returns Order in which metadata needs to be retrieved/deployed

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Object.&lt;string, Array.&lt;string&gt;&gt;</code> - retrieve/deploy order as array  

| Param | Type | Description |
| --- | --- | --- |
| metadataTypes | <code>Array.&lt;string&gt;</code> | which should be retrieved/deployed |

<a name="Util.resolveObjPath"></a>

### Util.resolveObjPath(path, obj) ⇒ <code>any</code>
let's you dynamically walk down an object and get a value

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>any</code> - value of obj.path  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | 'fieldA.fieldB.fieldC' |
| obj | <code>object</code> | some parent object |

<a name="Util.execSync"></a>

### Util.execSync(cmd, [args], [hideOutput]) ⇒ <code>string</code> \| <code>void</code>
helper to run other commands as if run manually by user

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>string</code> \| <code>void</code> - output of command if hideOutput is true  

| Param | Type | Description |
| --- | --- | --- |
| cmd | <code>string</code> | to be executed command |
| [args] | <code>Array.&lt;string&gt;</code> | list of arguments |
| [hideOutput] | <code>boolean</code> | if true, output of command will be hidden from CLI |

<a name="Util.templateSearchResult"></a>

### Util.templateSearchResult(results, keyToSearch, searchValue) ⇒ <code>TYPE.MetadataTypeItem</code>
standardize check to ensure only one result is returned from template search

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>TYPE.MetadataTypeItem</code> - metadata to be used in building template  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Array.&lt;TYPE.MetadataTypeItem&gt;</code> | array of metadata |
| keyToSearch | <code>string</code> | the field which contains the searched value |
| searchValue | <code>string</code> | the value which is being looked for |

<a name="Util.setLoggingLevel"></a>

### Util.setLoggingLevel(argv) ⇒ <code>void</code>
configures what is displayed in the console

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| argv | <code>object</code> | list of command line parameters given by user |
| [argv.silent] | <code>boolean</code> | only errors printed to CLI |
| [argv.verbose] | <code>boolean</code> | chatty user CLI output |
| [argv.debug] | <code>boolean</code> | enables developer output & features |

<a name="Util.logBeta"></a>

### Util.logBeta(type)
outputs a warning that the given type is still in beta

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | api name of the type thats in beta |

<a name="Util.getGrayMsg"></a>

### Util.getGrayMsg(msg) ⇒ <code>string</code>
helper that wraps a message in the correct color codes to have them printed gray

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>string</code> - gray msg  

| Param | Type | Description |
| --- | --- | --- |
| msg | <code>string</code> | log message that should be wrapped with color codes |

<a name="Util.logSubtypes"></a>

### Util.logSubtypes(subTypeArr) ⇒ <code>void</code>
helper to print the subtypes we filtered by

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| subTypeArr | <code>Array.&lt;string&gt;</code> | list of subtypes to be printed |

<a name="Util.getKeysString"></a>

### Util.getKeysString(keyArr, [isId]) ⇒ <code>string</code>
helper to print the subtypes we filtered by

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>string</code> - string to be appended to log message  

| Param | Type | Description |
| --- | --- | --- |
| keyArr | <code>Array.&lt;string&gt;</code> \| <code>string</code> | list of subtypes to be printed |
| [isId] | <code>boolean</code> | optional flag to indicate if key is an id |

<a name="Util.sleep"></a>

### Util.sleep(ms) ⇒ <code>Promise.&lt;void&gt;</code>
pause execution of code; useful when multiple server calls are dependent on each other and might not be executed right away

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Promise.&lt;void&gt;</code> - - promise to wait for  

| Param | Type | Description |
| --- | --- | --- |
| ms | <code>number</code> | time in miliseconds to wait |

<a name="Util.getSsjs"></a>

### Util.getSsjs(code) ⇒ <code>string</code>
helper for Asset.extractCode and Script.prepExtractedCode to determine if a code block is a valid SSJS block

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>string</code> - the SSJS code if code block is a valid SSJS block, otherwise null  

| Param | Type | Description |
| --- | --- | --- |
| code | <code>string</code> | code block to check |

**Example**  
```js
the following is invalid:
<script runat="server">
      // 1
  </script>
  <script runat="server">
      // 2
  </script>

  the following is valid:
  <script runat="server">
      // 3
  </script>
```
<a name="Util.stringLike"></a>

### Util.stringLike(testString, search) ⇒ <code>boolean</code>
allows us to filter just like with SQL's LIKE operator

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - true if testString matches search  

| Param | Type | Description |
| --- | --- | --- |
| testString | <code>string</code> | field value to test |
| search | <code>string</code> | search string in SQL LIKE format |

<a name="Util.fieldsLike"></a>

### Util.fieldsLike(metadata, [filters]) ⇒ <code>boolean</code>
returns true if no LIKE filter is defined or if all filters match

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - true if no LIKE filter is defined or if all filters match  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.MetadataTypeItem</code> | a single metadata item |
| [filters] | <code>object</code> | only used in recursive calls |

<a name="Util.capitalizeFirstLetter"></a>

### Util.capitalizeFirstLetter(str) ⇒ <code>string</code>
helper used by SOAP methods to ensure the type always uses an upper-cased first letter

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>string</code> - str with first letter capitalized  

| Param | Type | Description |
| --- | --- | --- |
| str | <code>string</code> | string to capitalize |

<a name="csvToArray"></a>

## csvToArray(csv) ⇒ <code>Array.&lt;string&gt;</code>
helper to convert CSVs into an array. if only one value was given, it's also returned as an array

**Kind**: global function  
**Returns**: <code>Array.&lt;string&gt;</code> - values split into an array.  

| Param | Type | Description |
| --- | --- | --- |
| csv | <code>string</code> | potentially comma-separated value or null |

<a name="Mcdev."></a>

## Mcdev.(methodName, businessUnit, [selectedType], [keys]) ⇒ <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code>
run a method across BUs

**Kind**: global function  
**Returns**: <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code> - key: business unit name, value: list of affected item keys  

| Param | Type | Description |
| --- | --- | --- |
| methodName | <code>&#x27;execute&#x27;</code> \| <code>&#x27;pause&#x27;</code> \| <code>&#x27;fixKeys&#x27;</code> \| <code>&#x27;updateNotifications&#x27;</code> | what to run |
| businessUnit | <code>string</code> | name of BU |
| [selectedType] | <code>TYPE.SupportedMetadataTypes</code> | limit to given metadata types |
| [keys] | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="Mcdev."></a>

## Mcdev.(methodName, cred, bu, [type], keyArr) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
helper for [Mcdev.#runMethod](Mcdev.#runMethod)

**Kind**: global function  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - list of keys that were affected  

| Param | Type | Description |
| --- | --- | --- |
| methodName | <code>&#x27;execute&#x27;</code> \| <code>&#x27;pause&#x27;</code> \| <code>&#x27;fixKeys&#x27;</code> \| <code>&#x27;updateNotifications&#x27;</code> | what to run |
| cred | <code>string</code> | name of Credential |
| bu | <code>string</code> | name of BU |
| [type] | <code>TYPE.SupportedMetadataTypes</code> | limit execution to given metadata type |
| keyArr | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="Mcdev."></a>

## Mcdev.(selectedType, buObject) ⇒ <code>Array.&lt;string&gt;</code>
helper for [Mcdev.#runOnBU](Mcdev.#runOnBU)

**Kind**: global function  
**Returns**: <code>Array.&lt;string&gt;</code> - keyArr  

| Param | Type | Description |
| --- | --- | --- |
| selectedType | <code>TYPE.SupportedMetadataTypes</code> | limit execution to given metadata type |
| buObject | <code>TYPE.BuObject</code> | properties for auth |

<a name="Mcdev."></a>

## Mcdev.(cred, bu, type, [keyArr]) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
Updates the key to match the name field

**Kind**: global function  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - list of keys that were affected  

| Param | Type | Description |
| --- | --- | --- |
| cred | <code>string</code> | name of Credential |
| bu | <code>string</code> | name of BU |
| type | <code>TYPE.SupportedMetadataTypes</code> | limit execution to given metadata type |
| [keyArr] | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |

<a name="Mcdev."></a>

## Mcdev.(type, [keyArr], buObject) ⇒ <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code>
Updates notification email address field

**Kind**: global function  
**Returns**: <code>Promise.&lt;Object.&lt;string, Array.&lt;string&gt;&gt;&gt;</code> - key: business unit name, value: list of affected item keys  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>TYPE.SupportedMetadataTypes</code> | limit execution to given metadata type |
| [keyArr] | <code>Array.&lt;string&gt;</code> | customerkey of the metadata |
| buObject | <code>TYPE.BuObject</code> | properties for auth |

<a name="Automation."></a>

## Automation.(metadata) ⇒ <code>boolean</code>
helper for [postRetrieveTasks](#Automation.postRetrieveTasks) and [execute](#Automation.execute)

**Kind**: global function  
**Returns**: <code>boolean</code> - true if the automation schedule is valid  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AutomationItem</code> | a single automation |

<a name="Automation."></a>

## Automation.(metadataMap, key) ⇒ <code>Promise.&lt;{key:string, response:object}&gt;</code>
helper for [execute](#Automation.execute)

**Kind**: global function  
**Returns**: <code>Promise.&lt;{key:string, response:object}&gt;</code> - metadata key and API response  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.AutomationMap</code> | map of metadata |
| key | <code>string</code> | key of the metadata |

<a name="Automation."></a>

## Automation.(metadataEntry) ⇒ <code>Promise.&lt;{key:string, response:object}&gt;</code>
helper for [execute](#Automation.execute)

**Kind**: global function  
**Returns**: <code>Promise.&lt;{key:string, response:object}&gt;</code> - metadata key and API response  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>TYPE.AutomationItem</code> | metadata object |

<a name="Automation."></a>

## Automation.(metadata) ⇒ <code>Promise.&lt;{key:string, response:object}&gt;</code>
helper for [pause](#Automation.pause)

**Kind**: global function  
**Returns**: <code>Promise.&lt;{key:string, response:object}&gt;</code> - metadata key and API response  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AutomationItem</code> | automation metadata |

<a name="Automation."></a>

## Automation.(metadata)
helper for [preDeployTasks](#Automation.preDeployTasks) and [execute](#Automation.execute)

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>TYPE.AutomationItem</code> | metadata mapped by their keyField |

<a name="Automation."></a>

## Automation.(metadataMap, key) ⇒ <code>Promise.&lt;void&gt;</code>
helper for [postDeployTasks](#Automation.postDeployTasks)

**Kind**: global function  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.AutomationMap</code> | metadata mapped by their keyField |
| key | <code>string</code> | current customer key |

<a name="Automation."></a>

## Automation.(key, programId, notificationBody) ⇒ <code>string</code>
helper function to send POST request to update notifications

**Kind**: global function  
**Returns**: <code>string</code> - returns "OK" or "Error"  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> | current customer key |
| programId | <code>string</code> | legacy automation id |
| notificationBody | <code>string</code> | notification payload |

<a name="Automation."></a>

## Automation.(metadataMap, originalMetadataMap, key, [oldKey]) ⇒ <code>Promise.&lt;{key:string, response:object}&gt;</code>
helper for [postDeployTasks](#Automation.postDeployTasks)

**Kind**: global function  
**Returns**: <code>Promise.&lt;{key:string, response:object}&gt;</code> - metadata key and API response  

| Param | Type | Description |
| --- | --- | --- |
| metadataMap | <code>TYPE.AutomationMap</code> | metadata mapped by their keyField |
| originalMetadataMap | <code>TYPE.AutomationMap</code> | metadata to be updated (contains additioanl fields) |
| key | <code>string</code> | current customer key |
| [oldKey] | <code>string</code> | old customer key before fixKey / changeKeyValue / changeKeyField |

<a name="Automation."></a>

## Automation.() ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
helper function to retrieve data about all automations in the BU

**Kind**: global function  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - returns data about automations with the legacy key  
<a name="DataExtension."></a>

## DataExtension.(upsertedMetadata, originalMetadata, createdUpdated) ⇒ <code>void</code>
takes care of updating attribute groups on child BUs after an update to Shared DataExtensions
helper for [postDeployTasks](#DataExtension.postDeployTasks)
fixes an issue where shared data extensions are not visible in data designer on child BU; SF known issue: https://issues.salesforce.com/#q=W-11031095

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| upsertedMetadata | <code>TYPE.DataExtensionMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>TYPE.DataExtensionMap</code> | metadata to be updated (contains additioanl fields) |
| createdUpdated | <code>Object</code> | counter representing successful creates/updates |

<a name="DataExtension."></a>

## DataExtension.() ⇒ <code>Array.&lt;string&gt;</code>
helper for [DataExtension.#fixShared](DataExtension.#fixShared)

**Kind**: global function  
**Returns**: <code>Array.&lt;string&gt;</code> - list of selected BU names  
<a name="DataExtension."></a>

## DataExtension.(childBuName, buObjectParent, clientParent, sharedDataExtensionMap) ⇒ <code>Promise.&lt;Array.&lt;string&gt;&gt;</code>
helper for [DataExtension.#fixShared](DataExtension.#fixShared)

**Kind**: global function  
**Returns**: <code>Promise.&lt;Array.&lt;string&gt;&gt;</code> - updated shared DE keys on BU  

| Param | Type | Description |
| --- | --- | --- |
| childBuName | <code>string</code> | name of child BU to fix |
| buObjectParent | <code>TYPE.BuObject</code> | bu object for parent BU |
| clientParent | <code>object</code> | SDK for parent BU |
| sharedDataExtensionMap | <code>Object.&lt;string, string&gt;</code> | ID-Key relationship of shared data extensions |

<a name="DataExtension."></a>

## DataExtension.(deId, deKey, buObjectChildBu, clientChildBu, buObjectParent, clientParent) ⇒ <code>Promise.&lt;boolean&gt;</code>
method that actually takes care of triggering the update for a particular BU-sharedDe combo
helper for [DataExtension.#fixShared_onBU](DataExtension.#fixShared_onBU)

**Kind**: global function  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - flag that signals if the fix was successful  

| Param | Type | Description |
| --- | --- | --- |
| deId | <code>string</code> | data extension ObjectID |
| deKey | <code>string</code> | dataExtension key |
| buObjectChildBu | <code>TYPE.BuObject</code> | BU object for Child BU |
| clientChildBu | <code>object</code> | SDK for child BU |
| buObjectParent | <code>TYPE.BuObject</code> | BU object for Parent BU |
| clientParent | <code>object</code> | SDK for parent BU |

<a name="DataExtension."></a>

## DataExtension.(buObjectChildBu, clientChildBu, deKey, deId) ⇒ <code>Promise.&lt;string&gt;</code>
add a new field to the shared DE to trigger an update to the data model
helper for [DataExtension.#fixShared_item](DataExtension.#fixShared_item)

**Kind**: global function  
**Returns**: <code>Promise.&lt;string&gt;</code> - randomSuffix  

| Param | Type | Description |
| --- | --- | --- |
| buObjectChildBu | <code>TYPE.BuObject</code> | BU object for Child BU |
| clientChildBu | <code>object</code> | SDK for child BU |
| deKey | <code>string</code> | dataExtension key |
| deId | <code>string</code> | dataExtension ObjectID |

<a name="DataExtension."></a>

## DataExtension.(randomSuffix, buObjectParent, clientParent, deKey) ⇒ <code>Promise.&lt;string&gt;</code>
get ID of the field added by [DataExtension.#fixShared_item_addField](DataExtension.#fixShared_item_addField) on the shared DE via parent BU
helper for [DataExtension.#fixShared_item](DataExtension.#fixShared_item)

**Kind**: global function  
**Returns**: <code>Promise.&lt;string&gt;</code> - fieldObjectID  

| Param | Type | Description |
| --- | --- | --- |
| randomSuffix | <code>string</code> | - |
| buObjectParent | <code>TYPE.BuObject</code> | BU object for Parent BU |
| clientParent | <code>object</code> | SDK for parent BU |
| deKey | <code>string</code> | dataExtension key |

<a name="DataExtension."></a>

## DataExtension.(randomSuffix, buObjectChildBu, clientChildBu, deKey, fieldObjectID) ⇒ <code>Promise</code>
delete the field added by [DataExtension.#fixShared_item_addField](DataExtension.#fixShared_item_addField)
helper for [DataExtension.#fixShared_item](DataExtension.#fixShared_item)

**Kind**: global function  
**Returns**: <code>Promise</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| randomSuffix | <code>string</code> | - |
| buObjectChildBu | <code>TYPE.BuObject</code> | BU object for Child BU |
| clientChildBu | <code>object</code> | SDK for child BU |
| deKey | <code>string</code> | dataExtension key |
| fieldObjectID | <code>string</code> | field ObjectID |

<a name="getUserName"></a>

## getUserName(userList, item, fieldname) ⇒ <code>string</code>
**Kind**: global function  
**Returns**: <code>string</code> - username or user id or 'n/a'  

| Param | Type | Description |
| --- | --- | --- |
| userList | <code>Object.&lt;string, string&gt;</code> | user-id > user-name map |
| item | <code>Object.&lt;string, string&gt;</code> | single metadata item |
| fieldname | <code>string</code> | name of field containing the info |

<a name="setupSDK"></a>

## setupSDK(sessionKey, authObject) ⇒ [<code>SDK</code>](#SDK)
Returns an SDK instance to be used for API calls

**Kind**: global function  
**Returns**: [<code>SDK</code>](#SDK) - auth object  

| Param | Type | Description |
| --- | --- | --- |
| sessionKey | <code>string</code> | key for specific BU |
| authObject | <code>TYPE.AuthObject</code> | credentials for specific BU |

<a name="TypeKeyCombo"></a>

## TypeKeyCombo : <code>Object.&lt;string, string&gt;</code>
object-key=metadata type, value=array of external keys

**Kind**: global typedef  
<a name="MetadataTypeItemDiff"></a>

## MetadataTypeItemDiff : <code>Object.&lt;string, any&gt;</code>
key=customer key

**Kind**: global typedef  
<a name="CodeExtractItem"></a>

## CodeExtractItem : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| json | <code>MetadataTypeItem</code> | metadata of one item w/o code |
| codeArr | [<code>Array.&lt;CodeExtract&gt;</code>](#CodeExtract) | list of code snippets in this item |
| subFolder | <code>Array.&lt;string&gt;</code> | mostly set to null, otherwise list of subfolders |

<a name="CodeExtract"></a>

## CodeExtract : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| subFolder | <code>Array.&lt;string&gt;</code> | mostly set to null, otherwise subfolders path split into elements |
| fileName | <code>string</code> | name of file w/o extension |
| fileExt | <code>string</code> | file extension |
| content | <code>string</code> | file content |
| [encoding] | <code>&#x27;base64&#x27;</code> | optional for binary files |

<a name="CodeExtractItem"></a>

## CodeExtractItem : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | name |
| key | <code>string</code> | key |
| description | <code>string</code> | - |
| targetKey | <code>string</code> | key of target data extension |
| createdDate | <code>string</code> | e.g. "2020-09-14T01:42:03.017" |
| modifiedDate | <code>string</code> | e.g. "2020-09-14T01:42:03.017" |
| targetUpdateTypeName | <code>&#x27;Overwrite&#x27;</code> \| <code>&#x27;Update&#x27;</code> \| <code>&#x27;Append&#x27;</code> | defines how the query writes into the target data extension |
| [targetUpdateTypeId] | <code>0</code> \| <code>1</code> \| <code>2</code> | mapped to targetUpdateTypeName via this.definition.targetUpdateTypeMapping |
| [targetId] | <code>string</code> | Object ID of DE (removed before save) |
| [targetDescription] | <code>string</code> | Description DE (removed before save) |
| isFrozen | <code>boolean</code> | looks like this is always set to false |
| [queryText] | <code>string</code> | contains SQL query with line breaks converted to '\n'. The content is extracted during retrieval and written into a separate *.sql file |
| [categoryId] | <code>string</code> | holds folder ID, replaced with r__folder_Path during retrieve |
| r__folder_Path | <code>string</code> | folder path in which this DE is saved |
| json | <code>QueryItem</code> | metadata of one item w/o code |
| codeArr | [<code>Array.&lt;CodeExtract&gt;</code>](#CodeExtract) | list of code snippets in this item |
| subFolder | <code>Array.&lt;string&gt;</code> | mostly set to null, otherwise list of subfolders |

<a name="ScriptMap"></a>

## ScriptMap : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | name |
| key | <code>string</code> | key |
| description | <code>string</code> | - |
| createdDate | <code>string</code> | e.g. "2020-09-14T01:42:03.017" |
| modifiedDate | <code>string</code> | e.g. "2020-09-14T01:42:03.017" |
| [script] | <code>string</code> | contains script with line breaks converted to '\n'. The content is extracted during retrieval and written into a separate *.ssjs file |
| [categoryId] | <code>string</code> | holds folder ID, replaced with r__folder_Path during retrieve |
| r__folder_Path | <code>string</code> | folder path in which this DE is saved |

<a name="AssetSubType"></a>

## AssetSubType : <code>Object.&lt;string, any&gt;</code>
**Kind**: global typedef  
<a name="DataExtensionFieldMap"></a>

## DataExtensionFieldMap : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| [ObjectID] | <code>string</code> | id |
| [CustomerKey] | <code>string</code> | key in format [DEkey].[FieldName] |
| [DataExtension] | <code>object</code> | - |
| DataExtension.CustomerKey | <code>string</code> | key of DE |
| Name | <code>string</code> | name of field |
| [Name_new] | <code>string</code> | custom attribute that is only used when trying to rename a field from Name to Name_new |
| DefaultValue | <code>string</code> | empty string for not set |
| IsRequired | <code>true</code> \| <code>false</code> | - |
| IsPrimaryKey | <code>true</code> \| <code>false</code> | - |
| Ordinal | <code>string</code> | 1, 2, 3, ... |
| FieldType | <code>&#x27;Text&#x27;</code> \| <code>&#x27;Number&#x27;</code> \| <code>&#x27;Date&#x27;</code> \| <code>&#x27;Boolean&#x27;</code> \| <code>&#x27;Decimal&#x27;</code> \| <code>&#x27;EmailAddress&#x27;</code> \| <code>&#x27;Phone&#x27;</code> \| <code>&#x27;Locale&#x27;</code> | can only be set on create |
| Scale | <code>string</code> | the number of places after the decimal that the field can hold; example: "0","1", ... |

<a name="DataExtensionMap"></a>

## DataExtensionMap : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| CustomerKey | <code>string</code> | key |
| Name | <code>string</code> | name |
| Description | <code>string</code> | - |
| [CreatedDate] | <code>string</code> | iso format |
| [ModifiedDate] | <code>string</code> | iso format |
| IsSendable | <code>true</code> \| <code>false</code> | - |
| IsTestable | <code>true</code> \| <code>false</code> | - |
| SendableDataExtensionField | <code>object</code> | - |
| SendableDataExtensionField.Name | <code>string</code> | - |
| SendableSubscriberField | <code>object</code> | - |
| SendableSubscriberField.Name | <code>string</code> | - |
| Fields | <code>Array.&lt;DataExtensionFieldItem&gt;</code> | list of DE fields |
| r__folder_ContentType | <code>&#x27;dataextension&#x27;</code> \| <code>&#x27;salesforcedataextension&#x27;</code> \| <code>&#x27;synchronizeddataextension&#x27;</code> \| <code>&#x27;shared\_dataextension&#x27;</code> \| <code>&#x27;shared\_salesforcedataextension&#x27;</code> | retrieved from associated folder |
| r__folder_Path | <code>string</code> | folder path in which this DE is saved |
| [CategoryID] | <code>string</code> | holds folder ID, replaced with r__folder_Path during retrieve |
| [r__dataExtensionTemplate_Name] | <code>string</code> | name of optionally associated DE template |
| [Template] | <code>object</code> | - |
| [Template.CustomerKey] | <code>string</code> | key of optionally associated DE teplate |

<a name="UserDocumentMap"></a>

## UserDocumentMap : <code>object</code>
key=customer key

**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| [ID] | <code>string</code> | equal to UserID; optional in update/create calls |
| UserID | <code>string</code> | equal to ID; required in update/create calls |
| [AccountUserID] | <code>number</code> | user.AccountUserID |
| c__AccountUserID | <code>number</code> | copy of AccountUserID |
| CustomerKey | <code>string</code> | user.CustomerKey |
| Name | <code>string</code> | user.Name |
| Email | <code>string</code> | user.Email |
| NotificationEmailAddress | <code>string</code> | user.NotificationEmailAddress |
| ActiveFlag | <code>boolean</code> | user.ActiveFlag === true ? '✓' : '-' |
| IsAPIUser | <code>boolean</code> | user.IsAPIUser === true ? '✓' : '-' |
| MustChangePassword | <code>boolean</code> | user.MustChangePassword === true ? '✓' : '-' |
| DefaultBusinessUnit | <code>number</code> | defaultBUName |
| c__AssociatedBusinessUnits | <code>Array.&lt;number&gt;</code> | associatedBus |
| [Roles] | <code>object</code> | (API only) |
| [Roles.Role] | <code>Array.&lt;object&gt;</code> | roles (API only) |
| c__RoleNamesGlobal | <code>Array.&lt;string&gt;</code> | roles |
| UserPermissions | <code>Array.&lt;string&gt;</code> | userPermissions |
| LastSuccessfulLogin | <code>string</code> | this.timeSinceDate(user.LastSuccessfulLogin) |
| CreatedDate | <code>string</code> | user.CreatedDate |
| ModifiedDate | <code>string</code> | user.ModifiedDate |
| Client | <code>object</code> | - |
| [Client.ID] | <code>number</code> | EID e.g:7281698 |
| Client.ModifiedBy | <code>number</code> | AccountUserID of user who last modified this user |
| c__type | <code>&#x27;User&#x27;</code> \| <code>&#x27;Installed Package&#x27;</code> | - |
| [IsLocked] | <code>boolean</code> | (API only) |
| [Unlock] | <code>boolean</code> | used to unlock a user that has IsLocked === true |
| c__IsLocked_readOnly | <code>boolean</code> | copy of IsLocked |
| c__TimeZoneName | <code>string</code> | name of timezone |
| [TimeZone] | <code>object</code> | (API only) |
| [TimeZone.Name] | <code>string</code> | (API only) |
| [TimeZone.ID] | <code>string</code> | (API only) |
| c__LocaleCode | <code>&#x27;en-US&#x27;</code> \| <code>&#x27;fr-CA&#x27;</code> \| <code>&#x27;fr-FR&#x27;</code> \| <code>&#x27;de-DE&#x27;</code> \| <code>&#x27;it-IT&#x27;</code> \| <code>&#x27;ja-JP&#x27;</code> \| <code>&#x27;pt-BR&#x27;</code> \| <code>&#x27;es-419&#x27;</code> \| <code>&#x27;es-ES&#x27;</code> | fr-CA, en-US, ... |
| [Locale] | <code>object</code> | (API only) |
| [Locale.LocaleCode] | <code>&#x27;en-US&#x27;</code> \| <code>&#x27;fr-CA&#x27;</code> \| <code>&#x27;fr-FR&#x27;</code> \| <code>&#x27;de-DE&#x27;</code> \| <code>&#x27;it-IT&#x27;</code> \| <code>&#x27;ja-JP&#x27;</code> \| <code>&#x27;pt-BR&#x27;</code> \| <code>&#x27;es-419&#x27;</code> \| <code>&#x27;es-ES&#x27;</code> | (API only) |

<a name="BusinessUnitAssignmentConfiguration"></a>

## BusinessUnitAssignmentConfiguration : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| Client | <code>object</code> | wrapper |
| Client.ID | <code>number</code> | EID e.g:7281698 |
| [PartnerKey] | <code>string</code> | empty string |
| ID | <code>number</code> | User ID e.g:717133502 |
| [ObjectID] | <code>string</code> | empty string |
| [Delete] | <code>number</code> | 0,1 |
| BusinessUnitAssignmentConfiguration | [<code>BusinessUnitAssignmentConfiguration</code>](#BusinessUnitAssignmentConfiguration) | - |
| BusinessUnitIds | <code>object</code> | wrapper |
| BusinessUnitIds.BusinessUnitId | <code>Array.&lt;number&gt;</code> \| <code>number</code> | e.g:[518003624] |
| IsDelete | <code>boolean</code> | assign BU if false, remove assignment if true |

<a name="AutomationActivity"></a>

## AutomationActivity : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | name (not key) of activity |
| [objectTypeId] | <code>string</code> | Id of assoicated activity type; see this.definition.activityTypeMapping |
| [activityObjectId] | <code>string</code> | Object Id of assoicated metadata item |
| [displayOrder] | <code>number</code> | order within step; starts with 1 or higher number |
| r__type | <code>string</code> | see this.definition.activityTypeMapping |

<a name="AutomationStep"></a>

## AutomationStep : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | description |
| [annotation] | <code>string</code> | equals AutomationStep.name |
| [step] | <code>number</code> | step iterator; starts with 1 |
| [stepNumber] | <code>number</code> | step iterator, automatically set during deployment |
| activities | [<code>Array.&lt;AutomationActivity&gt;</code>](#AutomationActivity) | - |

<a name="AutomationSchedule"></a>

## AutomationSchedule : <code>object</code>
REST format

**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| typeId | <code>number</code> | ? |
| startDate | <code>string</code> | example: '2021-05-07T09:00:00' |
| endDate | <code>string</code> | example: '2021-05-07T09:00:00' |
| icalRecur | <code>string</code> | example: 'FREQ=DAILY;UNTIL=20790606T160000;INTERVAL=1' |
| timezoneName | <code>string</code> | example: 'W. Europe Standard Time'; see this.definition.timeZoneMapping |
| [timezoneId] | <code>number</code> | see this.definition.timeZoneMapping |

<a name="AutomationScheduleSoap"></a>

## AutomationScheduleSoap : <code>object</code>
SOAP format

**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| Recurrence | <code>object</code> | - |
| Recurrence.$ | <code>object</code> | {'xsi:type': keyStem + 'lyRecurrence'} |
| [Recurrence.YearlyRecurrencePatternType] | <code>&#x27;ByYear&#x27;</code> | * currently not supported by tool * |
| [Recurrence.MonthlyRecurrencePatternType] | <code>&#x27;ByMonth&#x27;</code> | * currently not supported by tool * |
| [Recurrence.WeeklyRecurrencePatternType] | <code>&#x27;ByWeek&#x27;</code> | * currently not supported by tool * |
| [Recurrence.DailyRecurrencePatternType] | <code>&#x27;ByDay&#x27;</code> | - |
| [Recurrence.MinutelyRecurrencePatternType] | <code>&#x27;Interval&#x27;</code> | - |
| [Recurrence.HourlyRecurrencePatternType] | <code>&#x27;Interval&#x27;</code> | - |
| [Recurrence.YearInterval] | <code>number</code> | 1..n * currently not supported by tool * |
| [Recurrence.MonthInterval] | <code>number</code> | 1..n * currently not supported by tool * |
| [Recurrence.WeekInterval] | <code>number</code> | 1..n * currently not supported by tool * |
| [Recurrence.DayInterval] | <code>number</code> | 1..n |
| [Recurrence.HourInterval] | <code>number</code> | 1..n |
| [Recurrence.MinuteInterval] | <code>number</code> | 1..n |
| _interval | <code>number</code> | internal variable for CLI output only |
| TimeZone | <code>object</code> | - |
| TimeZone.ID | <code>number</code> | AutomationSchedule.timezoneId |
| _timezoneString | <code>string</code> | internal variable for CLI output only |
| StartDateTime | <code>string</code> | AutomationSchedule.startDate |
| EndDateTime | <code>string</code> | AutomationSchedule.endDate |
| _StartDateTime | <code>string</code> | AutomationSchedule.startDate; internal variable for CLI output only |
| RecurrenceRangeType | <code>&#x27;EndOn&#x27;</code> \| <code>&#x27;EndAfter&#x27;</code> | set to 'EndOn' if AutomationSchedule.icalRecur contains 'UNTIL'; otherwise to 'EndAfter' |
| Occurrences | <code>number</code> | only exists if RecurrenceRangeType=='EndAfter' |

<a name="AutomationItem"></a>

## AutomationItem : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| [id] | <code>string</code> | Object Id |
| key | <code>string</code> | key |
| name | <code>string</code> | name |
| description | <code>string</code> | - |
| type | <code>&#x27;scheduled&#x27;</code> \| <code>&#x27;triggered&#x27;</code> | Starting Source = Schedule / File Drop |
| status | <code>&#x27;Scheduled&#x27;</code> \| <code>&#x27;Running&#x27;</code> \| <code>&#x27;Ready&#x27;</code> \| <code>&#x27;Building&#x27;</code> \| <code>&#x27;PausedSchedule&#x27;</code> \| <code>&#x27;InactiveTrigger&#x27;</code> | - |
| [schedule] | [<code>AutomationSchedule</code>](#AutomationSchedule) | only existing if type=scheduled |
| [fileTrigger] | <code>object</code> | only existing if type=triggered |
| fileTrigger.fileNamingPattern | <code>string</code> | file name with placeholders |
| fileTrigger.fileNamePatternTypeId | <code>number</code> | - |
| fileTrigger.folderLocationText | <code>string</code> | where to look for the fileNamingPattern |
| fileTrigger.isPublished | <code>boolean</code> | ? |
| fileTrigger.queueFiles | <code>boolean</code> | ? |
| fileTrigger.triggerActive | <code>boolean</code> | - |
| [startSource] | <code>object</code> | - |
| [startSource.schedule] | [<code>AutomationSchedule</code>](#AutomationSchedule) | rewritten to AutomationItem.schedule |
| [startSource.fileDrop] | <code>object</code> | rewritten to AutomationItem.fileTrigger |
| startSource.fileDrop.fileNamingPattern | <code>string</code> | file name with placeholders |
| startSource.fileDrop.fileNamePatternTypeId | <code>string</code> | - |
| startSource.fileDrop.folderLocation | <code>string</code> | - |
| startSource.fileDrop.queueFiles | <code>boolean</code> | - |
| startSource.typeId | <code>number</code> | - |
| steps | [<code>Array.&lt;AutomationStep&gt;</code>](#AutomationStep) | - |
| r__folder_Path | <code>string</code> | folder path |
| [categoryId] | <code>string</code> | holds folder ID, replaced with r__folder_Path during retrieve |

<a name="SDK"></a>

## SDK : <code>Object.&lt;string, AutomationItem&gt;</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| file | <code>string</code> | relative path to file |
| changes | <code>number</code> | changed lines |
| insertions | <code>number</code> | added lines |
| deletions | <code>number</code> | deleted lines |
| binary | <code>boolean</code> | is a binary file |
| moved | <code>boolean</code> | git thinks this file was moved |
| [fromPath] | <code>string</code> | git thinks this relative path is where the file was before |
| type | <code>SupportedMetadataTypes</code> | metadata type |
| externalKey | <code>string</code> | key |
| name | <code>string</code> | name |
| gitAction | <code>&#x27;move&#x27;</code> \| <code>&#x27;add/update&#x27;</code> \| <code>&#x27;delete&#x27;</code> | what git recognized as an action |
| _credential | <code>string</code> | mcdev credential name |
| _businessUnit | <code>string</code> | mcdev business unit name inside of _credential |

<a name="skipInteraction"></a>

## skipInteraction : <code>object</code>
signals what to insert automatically for things usually asked via wizard

**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| client_id | <code>string</code> | client id of installed package |
| client_secret | <code>string</code> | client secret of installed package |
| auth_url | <code>string</code> | tenant specific auth url of installed package |
| account_id | <code>number</code> | MID of the Parent Business Unit |
| credentialName | <code>string</code> | how you would like the credential to be named |
| gitRemoteUrl | <code>string</code> | URL of Git remote server |

<a name="AuthObject"></a>

## AuthObject : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| client_id | <code>string</code> | client_id client_id for sfmc-sdk auth |
| client_secret | <code>string</code> | client_secret for sfmc-sdk auth |
| account_id | <code>number</code> | mid of business unit to auth against |
| auth_url | <code>string</code> | authentication base url |

<a name="SoapFilter"></a>

## SoapFilter : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| [continueRequest] | <code>string</code> | request id |
| [options] | <code>object</code> | additional options (CallsInConversation, Client, ConversationID, Priority, RequestType, SaveOptions, ScheduledTime, SendResponseTo, SequenceCode) |
| clientIDs | <code>\*</code> | ? |
| [filter] | [<code>SoapFilter</code>](#SoapFilter) | simple or complex complex |
| [QueryAllAccounts] | <code>boolean</code> | all BUs or just one |
| leftOperand | <code>string</code> \| [<code>SoapFilter</code>](#SoapFilter) | string for simple or a new filter-object for complex |
| operator | <code>&#x27;AND&#x27;</code> \| <code>&#x27;OR&#x27;</code> \| <code>&#x27;equals&#x27;</code> \| <code>&#x27;notEquals&#x27;</code> \| <code>&#x27;isNull&#x27;</code> \| <code>&#x27;isNotNull&#x27;</code> \| <code>&#x27;greaterThan&#x27;</code> \| <code>&#x27;lessThan&#x27;</code> \| <code>&#x27;greaterThanOrEqual&#x27;</code> \| <code>&#x27;lessThanOrEqual&#x27;</code> \| <code>&#x27;between&#x27;</code> \| <code>&#x27;IN&#x27;</code> \| <code>&#x27;like&#x27;</code> | various options |
| [rightOperand] | <code>string</code> \| <code>number</code> \| <code>boolean</code> \| <code>Array</code> \| [<code>SoapFilter</code>](#SoapFilter) | string for simple or a new filter-object for complex; omit for isNull and isNotNull |

<a name="Mcdevrc"></a>

## Mcdevrc : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| credentials | <code>object</code> | list of credentials |
| options | <code>object</code> | configure options for mcdev |
| directories | <code>object</code> | configure directories for mcdev to read/write to |
| directories.businessUnits | <code>string</code> | "businessUnits/" |
| directories.deploy | <code>string</code> | "deploy/" |
| directories.docs | <code>string</code> | "docs/" |
| directories.retrieve | <code>string</code> | "retrieve/" |
| directories.template | <code>string</code> | "template/" |
| directories.templateBuilds | <code>string</code> | ["retrieve/", "deploy/"] |
| markets | <code>Object.&lt;string, object&gt;</code> | templating variables grouped by markets |
| marketList | <code>object</code> | combination of markets and BUs for streamlined deployments |
| metaDataTypes | <code>object</code> | templating variables grouped by markets |
| metaDataTypes.retrieve | <code>Array.&lt;string&gt;</code> | define what types shall be downloaded by default during retrieve |
| metaDataTypes.documentOnRetrieve | <code>Array.&lt;string&gt;</code> | which types should be parsed & documented after retrieve |
| version | <code>string</code> | mcdev version that last updated the config file |

<a name="Logger"></a>

## Logger : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| info | <code>function</code> | (msg) print info message |
| warn | <code>function</code> | (msg) print warning message |
| verbose | <code>function</code> | (msg) additional messages that are not important |
| debug | <code>function</code> | (msg) print debug message |
| error | <code>function</code> | (msg) print error message |
| errorStack | <code>function</code> | (ex, msg) print error with trace message |

