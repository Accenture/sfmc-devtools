'use strict';

import MetadataType from './MetadataType.js';
import TransactionalEmail from './TransactionalEmail.js';
import Event from './Event.js';
import { Util } from '../util/util.js';
import cache from '../util/cache.js';
import File from '../util/file.js';
import ReplaceCbReference from '../util/replaceContentBlockReference.js';
import Retriever from '../Retriever.js';

/**
 * @typedef {import('../../types/mcdev.d.js').BuObject} BuObject
 * @typedef {import('../../types/mcdev.d.js').CodeExtract} CodeExtract
 * @typedef {import('../../types/mcdev.d.js').CodeExtractItem} CodeExtractItem
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeItem} MetadataTypeItem
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeItemDiff} MetadataTypeItemDiff
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeItemObj} MetadataTypeItemObj
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeMap} MetadataTypeMap
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeMapObj} MetadataTypeMapObj
 * @typedef {import('../../types/mcdev.d.js').SoapRequestParams} SoapRequestParams
 * @typedef {import('../../types/mcdev.d.js').TemplateMap} TemplateMap
 */

/**
 * Journey MetadataType
 * ! BETA RELEASE of journey support (v4.3.0); it so far only resolves a limited amount of dependencies and will likely break during cross-BU deployments!
 * id: A unique id of the journey assigned by the journey’s API during its creation
 * key: A unique id of the journey within the MID. Can be generated by the developer
 * definitionId: A unique UUID provided by Salesforce Marketing Cloud. Each version of a journey has a unique DefinitionID while the Id and Key remain the same. Version 1 will have id == definitionId
 *
 * @augments MetadataType
 */
class Journey extends MetadataType {
    /**
     * Retrieves Metadata of Journey
     *
     * @param {string} retrieveDir Directory where retrieved metadata directory will be saved
     * @param {void | string[]} [_] unused parameter
     * @param {void | string[]} [__] unused parameter
     * @param {string} [key] customer key of single item to retrieve
     * @returns {Promise.<MetadataTypeMapObj>} Promise
     */
    static async retrieve(retrieveDir, _, __, key) {
        const extrasDefault = 'activities';
        if (retrieveDir) {
            // only print this during retrieve, not during retrieveForCache
            Util.logBeta(this.definition.type);
        }

        let singleKey = '';
        let mode = 'all';
        if (key) {
            if (key.startsWith('%23')) {
                // correct the format
                key = 'id:' + key.slice(3);
            }
            if (key.startsWith('id:')) {
                // ! allow selecting journeys by ID because that's what users see in the URL
                // if the key started with %23 assume an ID was copied from the URL but the user forgot to prefix it with id:

                // remove id: or %23
                singleKey = key.slice(3);
                if (singleKey.startsWith('%23')) {
                    // in the journey URL the Id is prefixed with an HTML-encoded "#" which could accidentally be copied by users
                    // despite the slicing above, this still needs testing here because users might have prefixed the ID with id: but did not know to remove the #23
                    singleKey = singleKey.slice(3);
                    // correct the format to ensure we show sth readable in the "Downloaded" log
                    key = 'id:' + singleKey;
                }
                if (singleKey.includes('/')) {
                    // in the journey URL the version is appended after the ID, separated by a forward-slash. Needs to be removed from the ID for the retrieve as we always aim to retrieve the latest version only
                    singleKey = singleKey.split('/')[0];
                }
                mode = 'id';
            } else if (key.startsWith('name:')) {
                singleKey = '?nameOrDescription=' + encodeURIComponent(key.slice(5));
                mode = 'name';
            } else {
                // assume actual key was provided
                singleKey = 'key:' + encodeURIComponent(key);
                mode = 'key';
            }
        }

        try {
            const uri = `/interaction/v1/interactions/`;
            if ((singleKey && (mode === 'key' || mode === 'id')) || !retrieveDir) {
                // full details for retrieve, only base data for caching; reduces caching time from minutes to seconds
                const extras = retrieveDir && singleKey ? extrasDefault : '';

                // caching or single retrieve
                return await super.retrieveREST(
                    retrieveDir,
                    `${uri}${singleKey}?extras=${extras}${key && key.includes('/') ? '&versionNumber=' + key.split('/')[1] : ''}`,
                    null,
                    key
                );
            } else {
                // retrieve all
                const results = this.definition.restPagination
                    ? await this.client.rest.getBulk(
                          uri + (mode === 'name' ? singleKey : ''),
                          this.definition.restPageSize || 500
                      )
                    : await this.client.rest.get(uri + (mode === 'name' ? singleKey : ''));

                if (results.items?.length) {
                    // empty results will come back without "items" defined
                    Util.logger.info(
                        Util.getGrayMsg(
                            ` - ${results.items?.length} ${this.definition.type}s found. Retrieving details...`
                        )
                    );
                }
                // full details for retrieve
                const extras = extrasDefault;
                let parsed;
                if (retrieveDir) {
                    const searchName = mode === 'name' ? key.slice(5) : null;
                    const foundKey = [];
                    // get extra details for saving this
                    const details = results.items
                        ? await Promise.all(
                              results.items.map(async (a) => {
                                  if (mode === 'name') {
                                      // when filtering by name, the API in fact does a LIKE search with placeholders left and right of the search term - and also searches the description field.
                                      if (searchName === a[this.definition.nameField]) {
                                          foundKey.push(a[this.definition.keyField]);
                                      } else {
                                          // skip because the name does not match
                                          return null;
                                      }
                                  }
                                  try {
                                      return await this.client.rest.get(
                                          `${uri}key:${a[this.definition.keyField]}?extras=${extras}` +
                                              `&versionNumber=${a.version}`
                                      );
                                  } catch (ex) {
                                      // if we do get here, we should log the error and continue instead of failing to download all automations
                                      Util.logger.warn(
                                          ` ☇ skipping ${this.definition.type} ${
                                              a[this.definition.nameField]
                                          } (${a[this.definition.keyField]}): ${ex.message} (${
                                              ex.code
                                          })${
                                              ex.endpoint
                                                  ? Util.getGrayMsg(
                                                        ' - ' +
                                                            ex.endpoint.split(
                                                                'rest.marketingcloudapis.com'
                                                            )[1]
                                                    )
                                                  : ''
                                          }`
                                      );
                                      return null;
                                  }
                              })
                          )
                        : [];
                    parsed = this.parseResponseBody({ items: details.filter(Boolean) });
                    // * retrieveDir is mandatory in this method as it is not used for caching (there is a seperate method for that)
                    const savedMetadata = await this.saveResults(parsed, retrieveDir, null, null);
                    Util.logger.info(
                        `Downloaded: ${this.definition.type} (${Object.keys(savedMetadata).length})` +
                            Util.getKeysString(
                                mode === 'name' ? `${foundKey.join(', ')} (${key})` : key
                            )
                    );
                } else {
                    // limit to main details for caching
                    parsed = this.parseResponseBody(results);
                }

                return {
                    metadata: parsed,
                    type: this.definition.type,
                };
            }
        } catch (ex) {
            // if the interaction does not exist, the API returns an error code which would otherwise bring execution to a hold
            if (
                [
                    'Journey matching key not found.',
                    'Must provide a valid ID or Key parameter',
                ].includes(ex.message)
            ) {
                Util.logger.info(
                    `Downloaded: ${this.definition.type} (0)${Util.getKeysString(
                        mode === 'id' ? singleKey : key,
                        mode === 'id'
                    )}`
                );
            } else {
                throw ex;
            }
        }
    }

    /**
     * Delete a metadata item from the specified business unit
     *
     * @param {string} key Identifier of item
     * @returns {Promise.<boolean>} deletion success status
     */
    static async deleteByKey(key) {
        let version;
        let singleKey = '';

        if (key.startsWith('id:') || key.startsWith('%23')) {
            // ! allow selecting journeys by ID because that's what users see in the URL
            // if the key started with %23 assume an ID was copied from the URL but the user forgot to prefix it with id:

            // remove id: or %23
            singleKey = key.slice(3);
            if (singleKey.startsWith('%23')) {
                // in the journey URL the Id is prefixed with an HTML-encoded "#" which could accidentally be copied by users
                // despite the slicing above, this still needs testing here because users might have prefixed the ID with id: but did not know to remove the #23
                singleKey = singleKey.slice(3);
            }
            if (singleKey.includes('/')) {
                // in the journey URL the version is appended after the ID, separated by a forward-slash.
                [singleKey, version] = singleKey.split('/');
            }
        } else {
            if (key.includes('/')) {
                // in the journey URL the version is appended after the ID, separated by a forward-slash.
                [key, version] = key.split('/');
            }

            // delete by key with specified version does not work, therefore we need to get the ID first
            const response = await this.client.rest.get(
                `/interaction/v1/interactions/key:${encodeURIComponent(key)}?extras=`
            );
            const results = this.parseResponseBody(response, key);
            singleKey = results[key].id;
            if (version && version > results[key].version) {
                Util.logger.error(
                    `The chosen version (${version}) is higher than the latest known version (${results[key].version}). Please choose a lower version.`
                );
                return false;
            }
            Util.logger.debug(`Deleting interaction ${key} via its ID ${singleKey}`);
        }
        if (!/^\d+$/.test(version)) {
            Util.logger.error(
                'Version is required for deleting interactions to avoid accidental deletion of the wrong item. Please append it at the end of the key or id, separated by forward-slash. Example for deleting version 4: ' +
                    key +
                    '/4'
            );
            return false;
        }
        Util.logger.warn(
            `Deleting Journeys via this command breaks following retrieve-by-key/id requests until you've deployed/created a new draft version! You can get still get the latest available version of your journey by retrieving all interactions on this BU.`
        );

        return super.deleteByKeyREST(
            '/interaction/v1/interactions/' + singleKey + `?versionNumber=${version}`,
            key,
            false
        );
    }

    /**
     * Deploys metadata - merely kept here to be able to print {@link Util.logBeta} once per deploy
     *
     * @param {MetadataTypeMap} metadata metadata mapped by their keyField
     * @param {string} deployDir directory where deploy metadata are saved
     * @param {string} retrieveDir directory where metadata after deploy should be saved
     * @returns {Promise.<MetadataTypeMap>} Promise of keyField => metadata map
     */
    static async deploy(metadata, deployDir, retrieveDir) {
        Util.logBeta(this.definition.type);
        return super.deploy(metadata, deployDir, retrieveDir);
    }

    /**
     * Updates a single item
     *
     * @param {MetadataTypeItem} metadata a single item
     * @returns {Promise} Promise
     */
    static update(metadata) {
        return super.updateREST(
            metadata,
            '/interaction/v1/interactions/key:' + metadata.key,
            'put'
        );
    }

    /**
     * Creates a single item
     *
     * @param {MetadataTypeItem} metadata a single item
     * @returns {Promise} Promise
     */
    static create(metadata) {
        return super.createREST(metadata, '/interaction/v1/interactions/');
    }

    /**
     * Helper for writing Metadata to disk, used for Retrieve and deploy
     *
     * @param {MetadataTypeMap} results metadata results from deploy
     * @param {string} retrieveDir directory where metadata should be stored after deploy/retrieve
     * @param {string} [overrideType] for use when there is a subtype (such as folder-queries)
     * @param {TemplateMap} [templateVariables] variables to be replaced in the metadata
     * @returns {Promise.<MetadataTypeMap>} Promise of saved metadata
     */
    static async saveResults(results, retrieveDir, overrideType, templateVariables) {
        if (Object.keys(results).length) {
            // only execute the following if records were found
            await this._postRetrieveTasksBulk(results);
        }
        return super.saveResults(results, retrieveDir, overrideType, templateVariables);
    }

    /**
     * helper for Journey's {@link Journey.saveResults}. Gets executed after retreive of metadata type and
     *
     * @param {MetadataTypeMap} metadataMap key=customer key, value=metadata
     */
    static async _postRetrieveTasksBulk(metadataMap) {
        let needTransactionalEmail = false;
        for (const key in metadataMap) {
            if (metadataMap[key].definitionType == 'Transactional') {
                needTransactionalEmail = true;
                break;
            }
        }
        if (needTransactionalEmail && !cache.getCache()?.transactionalEmail) {
            // ! interaction and transactionalEmail both link to each other. caching transactionalEmail here "manually", assuming that it's quicker than the other way round
            Util.logger.info(' - Caching dependent Metadata: transactionalEmail');
            TransactionalEmail.buObject = this.buObject;
            TransactionalEmail.client = this.client;
            TransactionalEmail.properties = this.properties;
            const result = await TransactionalEmail.retrieveForCache();
            cache.setMetadata('transactionalEmail', result.metadata);
        }
    }

    /**
     * manages post retrieve steps
     *
     * @param {MetadataTypeItem} metadata a single item
     * @returns {Promise.<MetadataTypeItem>} Array with one metadata object
     */
    static async postRetrieveTasks(metadata) {
        // folder
        super.setFolderPath(metadata);

        switch (metadata.definitionType) {
            case 'Quicksend': // Single Send Journey
            case 'Multistep': {
                // Single Send Journey
                // ~~~ TRIGGERS ~~~~
                // event && triggers[].type === 'ContactAudience'
                // Multi-Step Journey
                // ~~~ TRIGGERS ~~~~
                // event / definitionType==='Multistep' && channel==='' && triggers[].type === 'EmailAudience'|'APIEvent'
                if (metadata.triggers?.length > 0) {
                    const search = ['arguments', 'metaData'];
                    for (const area of search) {
                        const config = metadata.triggers[0][area];
                        if (config?.eventDefinitionId) {
                            // trigger found; there can only be one entry in this array
                            try {
                                const edKey = cache.searchForField(
                                    'event',
                                    config.eventDefinitionId,
                                    'id',
                                    'eventDefinitionKey'
                                );
                                if (config.eventDefinitionKey !== edKey) {
                                    Util.logger.debug(
                                        `eventDefinitionKey not matching eventDefinitionId. Overwriting '${config.eventDefinitionKey}' with the correct key '${edKey}'.`
                                    );
                                }
                                config.r__event_key = edKey;

                                delete config.eventDefinitionKey;
                                delete config.eventDefinitionId;
                            } catch (ex) {
                                Util.logger.warn(
                                    ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                                        metadata[this.definition.keyField]
                                    }): ${ex.message}.`
                                );
                            }
                        }
                        if (config?.dataExtensionId) {
                            try {
                                config.r__dataExtension_key = cache.searchForField(
                                    'dataExtension',
                                    config.dataExtensionId,
                                    'ObjectID',
                                    'CustomerKey'
                                );
                                delete config.dataExtensionId;
                            } catch (ex) {
                                Util.logger.warn(
                                    ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                                        metadata[this.definition.keyField]
                                    }): ${ex.message}.`
                                );
                            }
                        }
                    }
                    try {
                        await Event.postRetrieveTasks_SalesforceEntryEvents(
                            metadata.triggers[0].type,
                            metadata.triggers[0].configurationArguments,
                            metadata.key,
                            this.definition.type
                        );
                    } catch (ex) {
                        Util.logger.warn(
                            ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${metadata[this.definition.keyField]}): ${ex.message}`
                        );
                    }
                }
                // ~~~ ACTIVITIES ~~~~

                this._postRetrieveTasks_activities(metadata);

                // TODO: journey template id? / metaData.templateId
                break;
            }
            case 'Transactional': {
                // Transactional Send Journey
                // ~~~ TRIGGERS ~~~~
                // ! journeys so far only supports transactional EMAIL messages. SMS and Push do not create their own journey.
                // ! transactional (email) journeys only have a dummy trigger without real content.
                // transactionalEmail / definitionType==='Transactional' && channel==='email' && triggers[].type === 'transactional-api'
                // --> nothing to do here

                // ~~~ ACTIVITIES ~~~~
                // ! transactional (email) journeys only have one activity (type=EMAILV2) which links back to the transactionalEmail ()
                switch (metadata.channel) {
                    case 'email': {
                        if (metadata.activities?.length > 0) {
                            const activity = metadata.activities[0];
                            // trigger found; there can only be one entry in this array

                            if (activity.configurationArguments?.triggeredSendId) {
                                try {
                                    const tEmailKey = cache.searchForField(
                                        'transactionalEmail',
                                        activity.configurationArguments?.triggeredSendId,
                                        'definitionId',
                                        'definitionKey'
                                    );
                                    if (
                                        activity.configurationArguments?.triggeredSendKey &&
                                        tEmailKey !=
                                            activity.configurationArguments?.triggeredSendKey
                                    ) {
                                        Util.logger.debug(
                                            `triggeredSendKey not matching triggeredSendId. Overwriting '${activity.configurationArguments.triggeredSendKey}' with the correct key '${tEmailKey}'.`
                                        );
                                    }
                                    activity.configurationArguments.r__transactionalEmail_key =
                                        activity.configurationArguments.triggeredSendKey;
                                    delete activity.configurationArguments.triggeredSendKey;
                                    delete activity.configurationArguments.triggeredSendId;
                                } catch (ex) {
                                    Util.logger.warn(
                                        ` - ${this.definition.type} ${
                                            metadata[this.definition.nameField]
                                        } (${metadata[this.definition.keyField]}): ${ex.message}.`
                                    );
                                }
                            }
                            if (
                                activity.metaData?.highThroughput?.definitionKey &&
                                activity.configurationArguments?.r__transactionalEmail_key &&
                                activity.metaData?.highThroughput?.definitionKey !=
                                    activity.configurationArguments.r__transactionalEmail_key
                            ) {
                                Util.logger.warn(
                                    ` - ${this.definition.type} ${
                                        metadata[this.definition.nameField]
                                    } (${metadata[this.definition.keyField]}): activities[0].metaData.highThroughput.definitionKey not matching key in activities[0].configurationArguments.r__transactionalEmail_key.`
                                );
                            } else if (
                                activity.configurationArguments?.r__transactionalEmail_key &&
                                metadata.status === 'Published'
                            ) {
                                // as long as status is Draft, we wont have r__transactionalEmail_key set as that record will not have been created
                                delete activity.metaData.highThroughput.definitionKey;
                            }

                            if (activity.metaData?.highThroughput?.dataExtensionId) {
                                try {
                                    activity.metaData.highThroughput.r__dataExtension_key =
                                        cache.searchForField(
                                            'dataExtension',
                                            activity.metaData.highThroughput.dataExtensionId,
                                            'ObjectID',
                                            'CustomerKey'
                                        );
                                    delete activity.metaData.highThroughput.dataExtensionId;
                                } catch (ex) {
                                    Util.logger.warn(
                                        ` - ${this.definition.type} ${
                                            metadata[this.definition.nameField]
                                        } (${metadata[this.definition.keyField]}): ${ex.message}.`
                                    );
                                }
                            }
                        }
                        // ~~~ ACTIVITIES ~~~~

                        this._postRetrieveTasks_activities(metadata);

                        break;
                    }
                    default: {
                        // it is expected that we'll see 'sms' and 'push' here in the future
                        Util.logger.warn(
                            ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                                metadata[this.definition.keyField]
                            }): channel ${
                                metadata.channel
                            } is not supported yet. Please open a ticket at https://github.com/Accenture/sfmc-devtools/issues/new/choose to request it`
                        );
                    }
                }

                break;
            }
            default: {
                Util.logger.warn(
                    ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                        metadata[this.definition.keyField]
                    }): definitionType ${
                        metadata.definitionType
                    } is not supported yet. Please open a ticket at https://github.com/Accenture/sfmc-devtools/issues/new/choose to request it`
                );
            }
        }

        return metadata;
    }

    /**
     * helper for {@link Journey.postRetrieveTasks}
     *
     * @private
     * @param {MetadataTypeItem} metadata a single item
     */
    static _postRetrieveTasks_activities(metadata) {
        for (const activity of metadata.activities) {
            switch (activity.type) {
                case 'EMAILV2': {
                    // triggeredSend + email+asset
                    // TODO email / asset
                    const configurationArguments = activity.configurationArguments;
                    if (configurationArguments) {
                        try {
                            // configurationArguments.triggeredSendKey && configurationArguments.triggeredSendId are only set on a running journey; if a journey is new, they do not exist
                            if (configurationArguments.triggeredSendId) {
                                // triggeredSendKey is not always set but triggeredSendId is
                                const tsKey = cache.searchForField(
                                    'triggeredSend',
                                    configurationArguments.triggeredSendId,
                                    'ObjectID',
                                    'CustomerKey'
                                );
                                if (configurationArguments.triggeredSendKey != tsKey) {
                                    Util.logger.debug(
                                        `triggeredSendKey not matching triggeredSendId. Overwriting '${configurationArguments.triggeredSendKey}' with the correct key '${tsKey}'.`
                                    );
                                    configurationArguments.triggeredSendKey = tsKey;
                                }
                                configurationArguments.r__triggeredSend_key =
                                    configurationArguments.triggeredSendKey;
                                delete configurationArguments.triggeredSendKey;
                                delete configurationArguments.triggeredSendId;
                            } else if (configurationArguments.triggeredSendKey) {
                                // very rare case but it's been seen that no triggeredSendId was saved
                                Util.logger.debug(
                                    `triggeredSendKey found on activity but no triggeredSendId present on journey. Checking key directly...`
                                );
                                configurationArguments.r__triggeredSend_key = cache.searchForField(
                                    'triggeredSend',
                                    configurationArguments.triggeredSendKey,
                                    'CustomerKey',
                                    'CustomerKey'
                                );
                                delete configurationArguments.triggeredSendKey;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }
                    }
                    if (
                        configurationArguments?.triggeredSend &&
                        'string' === typeof configurationArguments?.triggeredSend
                    ) {
                        // sometimes, the API returns this object as a string for unknown reasons. Good job, product team!
                        configurationArguments.triggeredSend = JSON.parse(
                            configurationArguments?.triggeredSend
                        );
                    }
                    const triggeredSend = configurationArguments?.triggeredSend;
                    if (triggeredSend) {
                        // this section is likely only relevant for QuickSends and not for Multi-Step Journeys

                        // triggeredSend key
                        if (configurationArguments.r__triggeredSend_key) {
                            // if we have a key set outside of this detailed triggeredSend config then lets overwrite what we've got here with what we cached from the related TS as it will be more current; but we cannot retrieve all info unfortunately
                            triggeredSend.r__triggeredSend_key =
                                configurationArguments.r__triggeredSend_key;
                            delete triggeredSend.id;
                            delete triggeredSend.key;
                            const linkedTS = cache.getByKey(
                                'triggeredSend',
                                triggeredSend.r__triggeredSend_key
                            );
                            triggeredSend.emailId = linkedTS?.Email?.ID;
                            triggeredSend.dynamicEmailSubject = linkedTS.DynamicEmailSubject;
                            triggeredSend.emailSubject = linkedTS.EmailSubject;
                            triggeredSend.bccEmail = linkedTS.BccEmail;
                            triggeredSend.isMultipart = linkedTS.IsMultipart;
                            triggeredSend.autoAddSubscribers = linkedTS.AutoAddSubscribers;
                            triggeredSend.autoUpdateSubscribers = linkedTS.AutoUpdateSubscribers;
                            triggeredSend.isTrackingClicks = !linkedTS.SuppressTracking;
                            // from name & email are set in the senderProfile, not in the triggeredSend
                            // triggeredSend.fromName = linkedTS.FromName;
                            // triggeredSend.fromAddress = linkedTS.FromAddress;

                            if (linkedTS.SenderProfile?.CustomerKey) {
                                try {
                                    cache.searchForField(
                                        'senderProfile',
                                        linkedTS.SenderProfile.CustomerKey,
                                        'CustomerKey',
                                        'CustomerKey'
                                    );
                                    triggeredSend.r__senderProfile_key =
                                        linkedTS.SenderProfile.CustomerKey;
                                    delete triggeredSend.senderProfileId;
                                } catch (ex) {
                                    Util.logger.warn(
                                        ` - ${this.definition.type} ${linkedTS.CustomerKey}: ${ex.message}`
                                    );
                                }
                            }
                            // send classification
                            if (linkedTS.SendClassification?.CustomerKey) {
                                try {
                                    cache.searchForField(
                                        'sendClassification',
                                        linkedTS.SendClassification.CustomerKey,
                                        'CustomerKey',
                                        'CustomerKey'
                                    );
                                    triggeredSend.r__sendClassification_key =
                                        linkedTS.SendClassification.CustomerKey;
                                    delete triggeredSend.sendClassificationId;
                                } catch (ex) {
                                    Util.logger.warn(
                                        ` - ${this.definition.type} ${linkedTS.CustomerKey}: ${ex.message}`
                                    );
                                }
                            }
                        } else if (triggeredSend.id) {
                            // triggeredSendKey is not always set but id is
                            const tsKey = cache.searchForField(
                                'triggeredSend',
                                triggeredSend.id,
                                'ObjectID',
                                'CustomerKey'
                            );
                            if (triggeredSend.key != tsKey) {
                                Util.logger.debug(
                                    `key not matching id. Overwriting '${triggeredSend.key}' with the correct key '${tsKey}'.`
                                );
                                triggeredSend.key = tsKey;
                            }
                            triggeredSend.r__triggeredSend_key = triggeredSend.key;
                            delete triggeredSend.key;
                            delete triggeredSend.id;
                        } else if (triggeredSend.key) {
                            // very rare case but it's been seen that no id was saved
                            Util.logger.debug(
                                `key found on triggeredSend but no id present on journey activity. Checking key directly...`
                            );
                            triggeredSend.r__triggeredSend_key = cache.searchForField(
                                'triggeredSend',
                                triggeredSend.key,
                                'CustomerKey',
                                'CustomerKey'
                            );
                            delete triggeredSend.key;
                        }

                        // List (optional)
                        triggeredSend.r__list_PathName = {};
                        if (triggeredSend.publicationListId) {
                            try {
                                triggeredSend.r__list_PathName.publicationList =
                                    cache.getListPathName(triggeredSend.publicationListId, 'ID');
                                delete triggeredSend.publicationListId;
                            } catch (ex) {
                                Util.logger.warn(
                                    ` - ${this.definition.typeName} '${metadata.name}'/'${metadata.key}': ${ex.message}`
                                );
                                // save this TSD because it could be fixed by the user
                            }
                        }
                        if (
                            triggeredSend.suppressionLists &&
                            Array.isArray(triggeredSend.suppressionLists) &&
                            triggeredSend.suppressionLists.length
                        ) {
                            triggeredSend.r__list_PathName.suppressionLists =
                                triggeredSend.suppressionLists.map((sList) => {
                                    try {
                                        return cache.getListPathName(sList.id, 'ID');
                                    } catch (ex) {
                                        Util.logger.warn(
                                            ` - ${this.definition.typeName} '${metadata.name}'/'${metadata.key}': ${ex.message}`
                                        );
                                        // save this TSD because it could be fixed by the user
                                    }
                                });
                            delete triggeredSend.suppressionLists;
                        }
                        if (!Object.keys(triggeredSend.r__list_PathName).length) {
                            // in case we found no linked lists, remove this empty shell
                            delete triggeredSend.r__list_PathName;
                        }

                        // DataExtension (optional)
                        triggeredSend.r__dataExtension_key = {};
                        if (
                            triggeredSend.domainExclusions &&
                            Array.isArray(triggeredSend.domainExclusions) &&
                            triggeredSend.domainExclusions.length
                        ) {
                            let errors = 0;
                            triggeredSend.r__dataExtension_key.domainExclusions =
                                triggeredSend.domainExclusions.map((de) => {
                                    try {
                                        return cache.searchForField(
                                            'dataExtension',
                                            de.id,
                                            'ObjectID',
                                            'CustomerKey'
                                        );
                                    } catch (ex) {
                                        errors++;
                                        Util.logger.warn(
                                            ` - ${this.definition.typeName} '${metadata.name}'/'${metadata.key}': ${ex.message}`
                                        );
                                        // save this TSD because it could be fixed by the user
                                    }
                                });
                            if (!errors) {
                                delete triggeredSend.domainExclusions; // array with id & name of DE
                            }
                        }
                        if (!Object.keys(triggeredSend.r__dataExtension_key).length) {
                            // in case we found no linked dataExtensions, remove this empty shell
                            delete triggeredSend.r__dataExtension_key;
                        }

                        // sender profile
                        if (triggeredSend.senderProfileId) {
                            try {
                                triggeredSend.r__senderProfile_key = cache.searchForField(
                                    'senderProfile',
                                    triggeredSend.senderProfileId,
                                    'ObjectID',
                                    'CustomerKey'
                                );
                                delete triggeredSend.senderProfileId;
                            } catch (ex) {
                                Util.logger.warn(
                                    ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                        metadata[this.definition.keyField]
                                    }): ${ex.message}`
                                );
                            }
                        }
                        // send classification
                        if (triggeredSend.sendClassificationId) {
                            try {
                                triggeredSend.r__sendClassification_key = cache.searchForField(
                                    'sendClassification',
                                    triggeredSend.sendClassificationId,
                                    'ObjectID',
                                    'CustomerKey'
                                );
                                delete triggeredSend.sendClassificationId;
                            } catch (ex) {
                                Util.logger.warn(
                                    ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                        metadata[this.definition.keyField]
                                    }): ${ex.message}`
                                );
                            }
                        }
                        // delivery profile
                        if (triggeredSend.deliveryProfileId) {
                            // remove it because we cannot resolve it and it should be set by selecting the sendClassification
                            delete triggeredSend.deliveryProfileId;
                        }
                        // message priority
                        if (triggeredSend.priority) {
                            triggeredSend.c__priority = Util.inverseGet(
                                this.definition.priorityMapping,
                                triggeredSend.priority
                            );
                            delete triggeredSend.priority;
                        }
                        // email
                        try {
                            // content builder
                            triggeredSend.r__asset_name_readOnly = cache.searchForField(
                                'asset',
                                triggeredSend.emailId,
                                'legacyData.legacyId',
                                'name'
                            );
                            triggeredSend.r__asset_key = cache.searchForField(
                                'asset',
                                triggeredSend.emailId,
                                'legacyData.legacyId',
                                'customerKey'
                            );
                            delete triggeredSend.emailId;
                        } catch {
                            try {
                                // classic
                                triggeredSend.r__email_name = cache.searchForField(
                                    'email',
                                    triggeredSend.emailId,
                                    'ID',
                                    'Name'
                                );
                                delete triggeredSend.emailId;
                            } catch {
                                Util.logger.warn(
                                    ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                        metadata[this.definition.keyField]
                                    }): Could not find email with ID ${triggeredSend.emailId} in Classic nor in Content Builder.`
                                );
                            }
                        }
                    }
                    break;
                }
                case 'SMSSYNC': {
                    const configurationArguments = activity.configurationArguments;
                    if (configurationArguments) {
                        // mobileMessage
                        try {
                            if (configurationArguments.messageId) {
                                configurationArguments.r__mobileMessage_key = cache.searchForField(
                                    'mobileMessage',
                                    configurationArguments.messageId,
                                    'id',
                                    'id'
                                );
                                delete configurationArguments.messageId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }
                        // mobileKeyword
                        configurationArguments.r__mobileKeyword_key = {};
                        try {
                            if (configurationArguments.keywordId) {
                                configurationArguments.r__mobileKeyword_key.current =
                                    cache.searchForField(
                                        'mobileKeyword',
                                        configurationArguments.keywordId,
                                        'id',
                                        'c__codeKeyword'
                                    );
                                delete configurationArguments.keywordId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }
                        try {
                            if (configurationArguments.nextKeywordId) {
                                configurationArguments.r__mobileKeyword_key.next =
                                    cache.searchForField(
                                        'mobileKeyword',
                                        configurationArguments.nextKeywordId,
                                        'id',
                                        'c__codeKeyword'
                                    );
                                delete configurationArguments.nextKeywordId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }
                        if (!Object.keys(configurationArguments.r__mobileKeyword_key).length) {
                            // in case we found no linked dataExtensions, remove this empty shell
                            delete configurationArguments.r__mobileKeyword_key;
                        }
                        // mobileCode
                        try {
                            if (configurationArguments.codeId) {
                                configurationArguments.r__mobileCode_key = cache.searchForField(
                                    'mobileCode',
                                    configurationArguments.codeId,
                                    'id',
                                    'code'
                                );
                                delete configurationArguments.codeId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }

                        try {
                            // asset-asset: jsonmessage
                            if (configurationArguments.assetId) {
                                configurationArguments.r__asset_name_readOnly =
                                    cache.searchForField(
                                        'asset',
                                        configurationArguments.assetId,
                                        'id',
                                        'name'
                                    );

                                configurationArguments.r__asset_key = cache.searchForField(
                                    'asset',
                                    configurationArguments.assetId,
                                    'id',
                                    'customerKey'
                                );
                                delete configurationArguments.assetId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }

                        // applicationExtensionId always equal "00000000-0000-0000-0000-000000000000"
                        delete configurationArguments.applicationExtensionId;
                    }
                    break;
                }
            }
            // TODO: Filters / activities[].type === 'MULTICRITERIADECISION'
            // - activities[].arguments.filterResult
            // - activities[].arguments.configurationArguments.criteria

            // TODO: wait activity / activities[].type === 'WAIT'
        }
    }

    /**
     * prepares a TSD for deployment
     * ! BETA RELEASE of journey support (v4.3.0); it so far only resolves a limited amount of dependencies and will likely break during cross-BU deployments!
     *
     * @param {MetadataTypeItem} metadata of a single TSD
     * @returns {Promise.<MetadataTypeItem>} metadata object
     */
    static async preDeployTasks(metadata) {
        if (metadata.status !== 'Draft') {
            metadata.status = 'Draft';
        }

        // folder
        super.setFolderId(metadata);

        switch (metadata.definitionType) {
            case 'Quicksend':
            case 'Multistep': {
                // Multi-Step Journey
                // ~~~ TRIGGERS ~~~~

                // event / definitionType==='Multistep' && channel==='' && triggers[].type === 'EmailAudience'|'APIEvent'

                if (metadata.triggers?.length > 0) {
                    const search = ['arguments', 'metaData'];
                    for (const area of search) {
                        const config = metadata.triggers[0][area];
                        if (config?.r__event_key) {
                            // trigger found; there can only be one entry in this array
                            config.eventDefinitionId = cache.searchForField(
                                'event',
                                config.r__event_key,
                                'eventDefinitionKey',
                                'id'
                            );
                            config.eventDefinitionKey = config.r__event_key;
                            delete config.r__event_key;
                        }
                        if (config?.r__dataExtension_key) {
                            // trigger found; there can only be one entry in this array
                            config.dataExtensionId = cache.searchForField(
                                'dataExtension',
                                config.r__dataExtension_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            delete config.r__dataExtension_key;
                        }
                    }
                    Event.preDeployTasks_SalesforceEntryEvents(
                        metadata.triggers[0].type,
                        metadata.triggers[0].configurationArguments
                    );
                }

                // transactionalEmail / definitionType==='Transactional' && channel==='email' && triggers[].type === 'transactional-api'

                // ~~~ ACTIVITIES ~~~~

                this._preDeployTasks_activities(metadata);

                break;
            }
            case 'Transactional': {
                // Transactional Send Journey
                // ~~~ TRIGGERS ~~~~
                // ! journeys so far transactional EMAIL messages. SMS and Push do not create their own journey.
                // ! transactional (email) journeys only have a dummy trigger without real content.

                // transactionalEmail / definitionType==='Transactional' && channel==='email' && triggers[].type === 'transactional-api'
                // --> nothing to do here

                // ~~~ ACTIVITIES ~~~~
                // ! transactional (email) journeys only have one activity (type=EMAILV2) which links back to the transactionalEmail ()
                switch (metadata.channel) {
                    case 'email': {
                        const activity = metadata.activities[0];
                        if (activity.configurationArguments?.r__transactionalEmail_key) {
                            // trigger found; there can only be one entry in this array
                            try {
                                activity.configurationArguments.triggeredSendId =
                                    cache.searchForField(
                                        'transactionalEmail',
                                        activity.configurationArguments.r__transactionalEmail_key,
                                        'definitionKey',
                                        'definitionId'
                                    );
                                activity.configurationArguments.triggeredSendKey =
                                    activity.configurationArguments.r__transactionalEmail_key;
                            } catch (ex) {
                                const isCreateMode = !cache.getByKey('journey', metadata.key);
                                if (isCreateMode && !Util.OPTIONS.publish) {
                                    // no need to add a log entry if the publish-option was provided
                                    Util.logger.info(
                                        ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                                            metadata[this.definition.keyField]
                                        }): To activate this transactional journey (and create the associated transactionalEmail record), please run 'mcdev publish ${this.buObject.credential}/${this.buObject.businessUnit} journey ${metadata.key}' or click on "Activate" in the GUI.`
                                    );
                                } else if (!isCreateMode) {
                                    // block deployment if we are in update mode
                                    throw ex;
                                }
                            }
                            if (activity.metaData?.highThroughput) {
                                // this is crucial for pinging the /interaction/v1/interactions/transactional/create endpoint that creates the transactionalEmail
                                activity.metaData.highThroughput.definitionKey =
                                    activity.configurationArguments.r__transactionalEmail_key;
                            }
                            delete activity.configurationArguments.r__transactionalEmail_key;
                        }

                        if (activity.metaData?.highThroughput?.r__dataExtension_key) {
                            activity.metaData.highThroughput.dataExtensionId = cache.searchForField(
                                'dataExtension',
                                activity.metaData.highThroughput.r__dataExtension_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            delete activity.metaData.highThroughput.r__dataExtension_key;
                        }

                        break;
                    }
                    default: {
                        // it is expected that we'll see 'sms' and 'push' here in the future
                        throw new Error(
                            ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                                metadata[this.definition.keyField]
                            }): channel ${
                                metadata.channel
                            } is not supported yet. Please open a ticket at https://github.com/Accenture/sfmc-devtools/issues/new/choose to request it`
                        );
                    }
                }

                break;
            }
            default: {
                throw new Error(
                    ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                        metadata[this.definition.keyField]
                    }): definitionType ${
                        metadata.definitionType
                    } is not supported yet. Please open a ticket at https://github.com/Accenture/sfmc-devtools/issues/new/choose to request it`
                );
            }
        }
        return metadata;
    }

    /**
     * helper for {@link Journey.preDeployTasks}
     *
     * @private
     * @param {MetadataTypeItem} metadata a single item
     */
    static _preDeployTasks_activities(metadata) {
        for (const activity of metadata.activities) {
            switch (activity.type) {
                case 'EMAILV2': {
                    // triggeredSend + email+asset
                    const configurationArguments = activity.configurationArguments;
                    if (configurationArguments?.r__triggeredSend_key) {
                        // triggeredSendKey is not always set but triggeredSendId is
                        try {
                            configurationArguments.triggeredSendId = cache.searchForField(
                                'triggeredSend',
                                configurationArguments.r__triggeredSend_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            configurationArguments.triggeredSendKey =
                                configurationArguments.r__triggeredSend_key;
                            delete configurationArguments.r__triggeredSend_key;
                        } catch {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${metadata[this.definition.keyField]}): Could not find triggeredSend with key ${configurationArguments.r__triggeredSend_key}. Attempting to let the API auto-create it`
                            );
                        }
                    }
                    const triggeredSend = configurationArguments?.triggeredSend;
                    if (triggeredSend) {
                        // triggeredSend key
                        if (
                            !configurationArguments.r__triggeredSend_key &&
                            triggeredSend.r__triggeredSend_key
                        ) {
                            try {
                                // key is not always set but id is
                                triggeredSend.id = cache.searchForField(
                                    'triggeredSend',
                                    triggeredSend.r__triggeredSend_key,
                                    'CustomerKey',
                                    'ObjectID'
                                );
                                triggeredSend.key = triggeredSend.r__triggeredSend_key;
                            } catch {
                                Util.logger.warn(
                                    ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${metadata[this.definition.keyField]}): Could not find triggeredSend with key ${triggeredSend.r__triggeredSend_key}. Attempting to let the API auto-create it`
                                );
                            }
                            delete triggeredSend.r__triggeredSend_key;
                        }

                        // List (optional)
                        if (triggeredSend.r__list_PathName) {
                            if (triggeredSend.r__list_PathName.publicationList) {
                                triggeredSend.publicationListId = cache.getListObjectId(
                                    triggeredSend.r__list_PathName.publicationList,
                                    'ID'
                                );
                            }
                            if (triggeredSend.r__list_PathName.suppressionLists?.length) {
                                triggeredSend.suppressionLists =
                                    triggeredSend.r__list_PathName.suppressionLists.map(
                                        (listPathName) => {
                                            const id = cache.getListObjectId(listPathName, 'ID');
                                            const name = cache.getListObjectId(
                                                listPathName,
                                                'ListName'
                                            );
                                            return { id, name };
                                        }
                                    );
                            }
                            delete triggeredSend.r__list_PathName;
                        }
                        // DataExtension (optional)
                        if (triggeredSend.r__dataExtension_key?.length) {
                            triggeredSend.domainExclusions = triggeredSend.r__dataExtension_key.map(
                                (key) => {
                                    const id = cache.searchForField(
                                        'dataExtension',
                                        key,
                                        'CustomerKey',
                                        'ObjectID'
                                    );
                                    const name = cache.searchForField(
                                        'dataExtension',
                                        key,
                                        'CustomerKey',
                                        'Name'
                                    );
                                    return { id, name };
                                }
                            );
                        }

                        // sender profile
                        if (triggeredSend.r__senderProfile_key) {
                            triggeredSend.senderProfileId = cache.searchForField(
                                'senderProfile',
                                triggeredSend.r__senderProfile_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            delete triggeredSend.r__senderProfile_key;
                        }
                        // send classification
                        if (triggeredSend.r__sendClassification_key) {
                            triggeredSend.sendClassificationId = cache.searchForField(
                                'sendClassification',
                                triggeredSend.r__sendClassification_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            delete triggeredSend.r__sendClassification_key;
                        }
                        // message priority
                        if (triggeredSend.c__priority) {
                            triggeredSend.priority =
                                this.definition.priorityMapping[triggeredSend.c__priority];
                            delete triggeredSend.c__priority;
                        }

                        // email
                        if (triggeredSend.r__asset_key) {
                            triggeredSend.emailId = cache.searchForField(
                                'asset',
                                triggeredSend.r__asset_key,
                                'customerKey',
                                'legacyData.legacyId'
                            );
                            delete triggeredSend.r__asset_key;
                            delete triggeredSend.r__asset_name_readOnly;
                        } else if (triggeredSend.r__email_name) {
                            // classic
                            triggeredSend.emailId = cache.searchForField(
                                'email',
                                triggeredSend.r__email_name,
                                'Name',
                                'ID'
                            );
                            delete triggeredSend.r__email_name;
                        }
                    }

                    break;
                }
                case 'SMSSYNC': {
                    const configurationArguments = activity.configurationArguments;
                    if (configurationArguments) {
                        // mobileMessage
                        if (configurationArguments.r__mobileMessage_key) {
                            configurationArguments.messageId = cache.searchForField(
                                'mobileMessage',
                                configurationArguments.r__mobileMessage_key,
                                'id',
                                'id'
                            );
                            delete configurationArguments.r__mobileMessage_key;
                        }
                        // mobileKeyword
                        if (configurationArguments.r__mobileKeyword_key?.current) {
                            configurationArguments.keywordId = cache.searchForField(
                                'mobileKeyword',
                                configurationArguments.r__mobileKeyword_key.current,
                                'c__codeKeyword',
                                'id'
                            );
                        }
                        if (configurationArguments.r__mobileKeyword_key?.next) {
                            configurationArguments.nextKeywordId = cache.searchForField(
                                'mobileKeyword',
                                configurationArguments.r__mobileKeyword_key.next,
                                'c__codeKeyword',
                                'id'
                            );
                        }
                        delete configurationArguments.r__mobileKeyword_key;
                        // mobileCode
                        if (configurationArguments.r__mobileCode_key) {
                            configurationArguments.codeId = cache.searchForField(
                                'mobileCode',
                                configurationArguments.r__mobileCode_key,
                                'code',
                                'id'
                            );
                            delete configurationArguments.r__mobileCode_key;
                        }
                        // asset-asset: jsonmessage
                        if (configurationArguments.r__asset_key) {
                            configurationArguments.assetId = cache.searchForField(
                                'asset',
                                configurationArguments.r__asset_key,
                                'customerKey',
                                'id'
                            );
                            delete configurationArguments.r__asset_key;
                            delete configurationArguments.r__asset_name_readOnly;
                        }

                        // applicationExtensionId always equal "00000000-0000-0000-0000-000000000000"
                        configurationArguments.applicationExtensionId =
                            '00000000-0000-0000-0000-000000000000';
                    }

                    break;
                }
            }
        }
    }

    /**
     * helper for {@link MetadataType.upsert}
     *
     * @param {MetadataTypeMap} metadataMap list of metadata
     * @param {string} metadataKey key of item we are looking at
     * @param {boolean} hasError error flag from previous code
     * @param {MetadataTypeItemDiff[]} metadataToUpdate list of items to update
     * @param {MetadataTypeItem[]} metadataToCreate list of items to create
     * @returns {Promise.<'create'|'update'|'skip'>} action to take
     */
    static async createOrUpdate(
        metadataMap,
        metadataKey,
        hasError,
        metadataToUpdate,
        metadataToCreate
    ) {
        const action = await super.createOrUpdate(
            metadataMap,
            metadataKey,
            hasError,
            metadataToUpdate,
            metadataToCreate
        );
        if (action === 'update') {
            const normalizedKey = File.reverseFilterIllegalFilenames(
                metadataMap[metadataKey][this.definition.keyField]
            );
            const cachedVersion = cache.getByKey(this.definition.type, normalizedKey);
            if (cachedVersion) {
                if (cachedVersion.status === 'Draft') {
                    // add version to ensure we update the correct one
                    metadataMap[metadataKey].version = cachedVersion.version;
                    // update modifiedDate field to bypass API-error "Another user recently modified this journey. Refresh to edit the latest version."
                    metadataMap[metadataKey].modifiedDate = cachedVersion.modifiedDate;
                } else {
                    // remove last entry from metadataToUpdate again
                    metadataToUpdate.pop();
                    Util.logger.info(
                        ` - Found ${this.definition.type} ${
                            metadataMap[metadataKey][this.definition.nameField]
                        } (${
                            metadataMap[metadataKey][this.definition.keyField]
                        }) on BU, but it is not in Draft status. Will create new version.`
                    );
                    metadataToCreate.push(metadataMap[metadataKey]);
                    return 'create';
                }
            }
        }
        return action;
    }

    /**
     *
     * @param {MetadataTypeItem} item single metadata item
     * @param {string} [_] parameter not used
     * @param {Set.<string>} [findAssetKeys] list of keys that were found referenced via ContentBlockByX; if set, method only gets keys and runs no updates
     * @returns {Promise.<MetadataTypeItem>} key of the item that was updated
     */
    static async replaceCbReference(item, _, findAssetKeys) {
        const parentName = `${this.definition.type} ${item[this.definition.keyField]}`;
        let changes = false;
        let error;

        // *** type specific logic **

        // find email activities with triggeredSend configurationArguments
        const activities = item.activities.filter((activity) => activity.type === 'EMAILV2');
        if (!activities) {
            const ex = new Error('No changes made to the code.');
            // @ts-expect-error custom error object
            ex.code = 200;
            throw ex;
        }

        for (const activity of activities) {
            if (activity.arguments) {
                try {
                    activity.arguments.emailSubjectDataBound = ReplaceCbReference.replaceReference(
                        activity.arguments.emailSubjectDataBound,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
            }
            const triggeredSend = activity.configurationArguments?.triggeredSend;
            if (triggeredSend) {
                // the following is very similar but not equal to the variables in TriggeredSend.js
                try {
                    triggeredSend.bccEmail = ReplaceCbReference.replaceReference(
                        triggeredSend.bccEmail,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
                try {
                    triggeredSend.ccEmail = ReplaceCbReference.replaceReference(
                        triggeredSend.ccEmail,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
                try {
                    triggeredSend.dynamicEmailSubject = ReplaceCbReference.replaceReference(
                        triggeredSend.dynamicEmailSubject,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
                try {
                    triggeredSend.emailSubject = ReplaceCbReference.replaceReference(
                        triggeredSend.emailSubject,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
                try {
                    triggeredSend.preHeader = ReplaceCbReference.replaceReference(
                        triggeredSend.preHeader,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
                try {
                    triggeredSend.exclusionFilter = ReplaceCbReference.replaceReference(
                        triggeredSend.exclusionFilter,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
            }
        }

        if (error) {
            throw error;
        }

        if (!changes) {
            const ex = new Error('No changes made to the code.');
            // @ts-expect-error custom error object
            ex.code = 200;
            throw ex;
        }

        // *** finish ***
        // replaceReference will throw an error if nothing was updated which will end execution here
        // no error means we have a new item to deploy and need to update the item in our retrieve folder
        return item;
    }

    /**
     * Gets executed after deployment of metadata type
     *
     * @param {MetadataTypeMap} upsertResults metadata mapped by their keyField as returned by update/create
     */
    static async postDeployTasks(upsertResults) {
        if (Util.OPTIONS.publish) {
            Util.logger.info(`Publishing: ${this.definition.type}`);
            // pubslih
            const idArr = Object.values(upsertResults).map(
                (item) => 'id:' + item.id + '/' + item.version
            );
            await this.publish(idArr);
        }
    }

    /**
     * a function to publish the journey via API
     *
     * @param {string[]} keyArr keys or ids of the metadata
     * @returns {Promise.<string[]>} Returns list of updated keys/ids that were published. Success could only be seen with a delay in the UI because the publish-endpoint is async
     */
    static async publish(keyArr) {
        const resultsJourney = [];
        const resultsTransactional = [];
        // works only with objectId
        const statusUrls = [];
        const executedKeyArr = [];
        const metadataMap = await this.retrieveForCache();

        for (let key of keyArr) {
            let objectId;
            let version;
            let journey;
            if (!key) {
                continue;
            }
            if (key.startsWith('%23')) {
                // if the key started with %23 assume an ID was copied from the URL but the user forgot to prefix it with id:
                // correct the format
                key = 'id:' + key.slice(3);
            }
            if (key.startsWith('id:')) {
                // ! allow selecting journeys by ID because that's what users see in the URL
                // remove id
                objectId = key.slice(3);
                if (objectId.startsWith('%23')) {
                    // in the journey URL the Id is prefixed with an HTML-encoded "#" which could accidentally be copied by users
                    // despite the slicing above, this still needs testing here because users might have prefixed the ID with id: but did not know to remove the #23
                    objectId = objectId.slice(3);
                    // correct the format to ensure we show sth readable in the "Downloaded" log
                    // objectId =  objectId;
                    // update this here to show it in the log
                    key = 'id:' + objectId;
                }
                if (objectId.includes('/')) {
                    version = objectId.split('/')[1];
                    // in the journey URL the version is appended after the ID, separated by a forward-slash. Needs to be removed from the ID for caching as we always aim to retrieve the latest version only
                    objectId = objectId.split('/')[0];
                } else {
                    // if we didn't find a version we need to cache this from the API after all
                    if (key.includes('/')) {
                        // in the journey URL the version is appended after the ID, separated by a forward-slash. Needs to be removed from the key for caching as we always aim to retrieve the latest version only
                        key = key.split('/')[0];
                    }
                }
                journey = Object.values(metadataMap.metadata).find((el) => el.id === objectId);
                if (!journey) {
                    Util.logger.info(
                        ` ☇ skipping ${this.definition.type} ${key}: not found on server (1)`
                    );
                    continue;
                }
            } else {
                // key assumed
                journey = metadataMap.metadata[key];
            }

            if (!journey) {
                Util.logger.info(
                    ` ☇ skipping ${this.definition.type} ${key}: not found on server (2)`
                );
                continue;
            }
            if (!version) {
                version = journey.version;
            }
            if (journey.status === 'Published') {
                // api would return error code 30000 and ask to open a support case when in fact we simply already have a transactionalEmail created based on this status
                Util.logger.error(
                    ` ☇ skipping ${this.definition.type} ${
                        journey[this.definition.nameField]
                    } (${journey[this.definition.keyField]}): already published`
                );
                continue;
            }

            switch (journey.definitionType) {
                case 'Transactional': {
                    resultsTransactional.push(
                        (async () => {
                            try {
                                const response = await this.client.rest.post(
                                    `/interaction/v1/interactions/transactional/create`,
                                    { definitionId: journey.id }
                                );
                                if (response.errors?.length) {
                                    throw new Error(JSON.stringify(response));
                                } else {
                                    Util.logger.info(
                                        ` - published ${this.definition.type}: ${
                                            journey[this.definition.nameField]
                                        } (${journey[this.definition.keyField]} by creating the matching transactionalEmail`
                                    );
                                    statusUrls.push({ key, statusUrl: response.statusUrl });
                                }
                                return key;
                            } catch (ex) {
                                if (
                                    ex.response.status === 400 &&
                                    ex.response?.data?.errors?.length === 1 &&
                                    ex.response?.data?.errors?.[0]?.errorCode === '121500'
                                ) {
                                    Util.logger.error(
                                        `Failed to publish ${
                                            journey[this.definition.nameField]
                                        } (${journey[this.definition.keyField]}): Make sure the Event Definition Key, Data Extension and E-Mail are saved to the journey`
                                    );
                                } else {
                                    Util.logger.error(
                                        `Failed to publish ${
                                            journey[this.definition.nameField]
                                        } (${journey[this.definition.keyField]}): ${ex.message}`
                                    );
                                    if (ex.response?.data?.errors?.length) {
                                        Util.logger.error(
                                            JSON.stringify(ex.response?.data?.errors, null, 2)
                                        );
                                    }
                                }
                            }
                        })()
                    );
                    break;
                }
                case 'Multistep':
                case 'Quicksend': {
                    resultsJourney.push(
                        (async () => {
                            try {
                                const response = await this.client.rest.post(
                                    `/interaction/v1/interactions/publishAsync/${journey.id}?versionNumber=${version}`,
                                    {}
                                ); // payload is empty for this request
                                if (response.statusUrl && response.statusId) {
                                    Util.logger.info(
                                        ` - queued for publishing ${this.definition.type}: ${key}`
                                    );
                                    statusUrls.push({ key, statusUrl: response.statusUrl });
                                } else {
                                    throw new Error(response);
                                }
                                return journey.key;
                            } catch (ex) {
                                if (
                                    ex.message === 'Cannot publish interaction in Published status.'
                                ) {
                                    Util.logger.info(
                                        ` - ${this.definition.type} ${key} is already published`
                                    );
                                } else if (
                                    ex.message === 'Cannot publish interaction in Stopped status.'
                                ) {
                                    Util.logger.warn(
                                        ` - ${this.definition.type} ${key} is already published but stopped. Please resume it manually.`
                                    );
                                } else {
                                    Util.logger.error(
                                        `Failed to publish ${this.definition.type} ${key}: ${ex.message}`
                                    );
                                }
                            }
                        })()
                    );
                }
            }
        } // for loop
        if (resultsJourney.length) {
            Util.logger.info(`Found ${resultsJourney.length} journey results`);
            executedKeyArr.push(...(await Promise.all(resultsJourney)).filter(Boolean));

            if (!Util.OPTIONS.skipStatusCheck && statusUrls.length) {
                Util.logger.info(
                    `Checking status of ${statusUrls.length} published item${statusUrls.length === 1 ? '' : 's'}`
                );
                executedKeyArr.length = 0;
                await Util.sleep(5000);
                for (const item of statusUrls) {
                    executedKeyArr.push(await this._checkPublishStatus(item.statusUrl, item.key));
                }
            }
        }
        if (resultsTransactional.length) {
            Util.logger.info(`Found ${resultsTransactional.length} journey results`);
            const transactionalKeyArr = (await Promise.all(resultsTransactional)).filter(Boolean);
            executedKeyArr.push(...transactionalKeyArr);

            Util.logger.info('Retrieving relevant journeys');
            const retriever = new Retriever(this.properties, this.buObject);

            try {
                const updatedJourneyRetrieve = await retriever.retrieve(
                    ['journey'],
                    transactionalKeyArr
                );

                /** @type {MetadataTypeItem[]} */
                const updatedJourneys = Object.values(updatedJourneyRetrieve?.journey[0]);
                if (updatedJourneys) {
                    const updatedTransactionalEmails = [];
                    for (const journey of updatedJourneys) {
                        updatedTransactionalEmails.push(
                            journey.activities?.[0]?.configurationArguments
                                ?.r__transactionalEmail_key
                        );
                    }
                    if (updatedTransactionalEmails.filter(Boolean).length) {
                        Util.logger.info('Retrieving relevant transactionalEmails');
                        await retriever.retrieve(
                            ['transactionalEmail'],
                            updatedTransactionalEmails.filter(Boolean)
                        );
                    } else {
                        Util.logger.error(
                            `Could not find transactional Emails for the published journeys`
                        );
                    }
                }
            } catch (ex) {
                Util.logger.errorStack(ex, 'retrieve failed');
            }
        }
        Util.logger.info(
            `Published ${executedKeyArr.filter(Boolean).length} of ${keyArr.length} items`
        );
        return executedKeyArr.filter(Boolean);
    }

    /**
     * helper for {@link Journey.publish}
     *
     * @param {string} statusUrl URL to check the status of the publish request
     * @param {string} key key or id for log messages
     * @param {number} [tries] number of tries used to check the status
     * @returns {Promise.<string>} key of the item that was published successfully
     */
    static async _checkPublishStatus(statusUrl, key, tries = 1) {
        try {
            const response = await this.client.rest.get(statusUrl);
            switch (response.status) {
                case 'PublishCompleted': {
                    Util.logger.info(` - ${this.definition.type} ${key}: publishing succeeded`);
                    this._showPublishStatusDetails(response);
                    return key;
                }
                case 'PublishInProcess': {
                    Util.logger.info(
                        ` - ${this.definition.type} ${key}: publishing still in progress`
                    );
                    if (tries < 50) {
                        await (tries < 10 ? Util.sleep(2000) : Util.sleep(5000));
                        return await this._checkPublishStatus(statusUrl, key, tries + 1);
                    } else {
                        return;
                    }
                }
                case 'Error': {
                    Util.logger.error(` - ${this.definition.type} ${key}: publishing failed.`);
                    this._showPublishStatusDetails(response);
                    return;
                }
                // No default
            }
        } catch (ex) {
            Util.logger.error(`Failed to check status of ${key}: ${ex.message}`);
        }
    }

    /**
     * helper for {@link Journey._checkPublishStatus}
     *
     * @param {{status:string, errors:Array, warnings:Array}} response publishStatus response
     */
    static _showPublishStatusDetails(response) {
        const types = { errors: 'Errors', warnings: 'Warnings' };
        const messages = { errors: [], warnings: [] };
        for (const type in types) {
            let counter = 1;
            if (response[type] && response[type].length) {
                messages[type].push(`   ${types[type]}:`);
                for (const msg of response[type]) {
                    messages[type].push(
                        `     #${counter++}`,
                        `     Code: ${msg.errorCode}`,
                        `     Details: ${msg.errorDetail.split(' EmailID: ').join('\n       EmailID: ').split(' Personalization error: ').join('\n       Personalization error: ')}`
                    );
                    if (msg.additionalInfo && Object.keys(msg.additionalInfo).length) {
                        messages[type].push(`     Additional Info:`);
                        for (const key in msg.additionalInfo) {
                            messages[type].push(`       ${key}: ${msg.additionalInfo[key]}`);
                        }
                    }
                    // add spacer line
                    messages[type].push('');
                }
            }
        }
        for (const msg of messages.errors) {
            Util.logger.error(msg);
        }
        for (const msg of messages.warnings) {
            Util.logger.warn(' ' + msg);
        }
    }
}

// Assign definition to static attributes
import MetadataTypeDefinitions from '../MetadataTypeDefinitions.js';
Journey.definition = MetadataTypeDefinitions.journey;

export default Journey;
