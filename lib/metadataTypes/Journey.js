'use strict';

import MetadataType from './MetadataType.js';
import TransactionalEmail from './TransactionalEmail.js';
import Event from './Event.js';
import { Util } from '../util/util.js';
import cache from '../util/cache.js';
import File from '../util/file.js';
import ReplaceCbReference from '../util/replaceContentBlockReference.js';
import Retriever from '../Retriever.js';
import pLimit from 'p-limit';
import yoctoSpinner from 'yocto-spinner';

/**
 * @typedef {import('../../types/mcdev.d.js').BuObject} BuObject
 * @typedef {import('../../types/mcdev.d.js').CodeExtract} CodeExtract
 * @typedef {import('../../types/mcdev.d.js').CodeExtractItem} CodeExtractItem
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeItem} MetadataTypeItem
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeItemDiff} MetadataTypeItemDiff
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeItemObj} MetadataTypeItemObj
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeMap} MetadataTypeMap
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeMapObj} MetadataTypeMapObj
 * @typedef {import('../../types/mcdev.d.js').SoapRequestParams} SoapRequestParams
 * @typedef {import('../../types/mcdev.d.js').TemplateMap} TemplateMap
 */

/**
 * Journey MetadataType
 * ! BETA RELEASE of journey support (v4.3.0); it so far only resolves a limited amount of dependencies and will likely break during cross-BU deployments!
 * id: A unique id of the journey assigned by the journey’s API during its creation
 * key: A unique id of the journey within the MID. Can be generated by the developer
 * definitionId: A unique UUID provided by Salesforce Marketing Cloud. Each version of a journey has a unique DefinitionID while the Id and Key remain the same. Version 1 will have id == definitionId
 *
 * @augments MetadataType
 */
class Journey extends MetadataType {
    /**
     * Retrieves Metadata of Journey
     *
     * @param {string} retrieveDir Directory where retrieved metadata directory will be saved
     * @param {void | string[]} [_] unused parameter
     * @param {void | string[]} [__] unused parameter
     * @param {string} [key] customer key of single item to retrieve
     * @returns {Promise.<MetadataTypeMapObj>} Promise
     */
    static async retrieve(retrieveDir, _, __, key) {
        const extrasDefault = 'activities';
        if (retrieveDir) {
            // only print this during retrieve, not during retrieveForCache
            Util.logBeta(this.definition.type);
        }

        let singleKey = '';
        let mode = 'all';
        if (key) {
            if (key.startsWith('%23')) {
                // correct the format
                key = 'id:' + key.slice(3);
            }
            if (key.startsWith('id:')) {
                // ! allow selecting journeys by ID because that's what users see in the URL
                // if the key started with %23 assume an ID was copied from the URL but the user forgot to prefix it with id:

                // remove id: or %23
                singleKey = key.slice(3);
                if (singleKey.startsWith('%23')) {
                    // in the journey URL the Id is prefixed with an HTML-encoded "#" which could accidentally be copied by users
                    // despite the slicing above, this still needs testing here because users might have prefixed the ID with id: but did not know to remove the #23
                    singleKey = singleKey.slice(3);
                    // correct the format to ensure we show sth readable in the "Downloaded" log
                    key = 'id:' + singleKey;
                }
                if (singleKey.includes('/')) {
                    // in the journey URL the version is appended after the ID, separated by a forward-slash. Needs to be removed from the ID for the retrieve as we always aim to retrieve the latest version only
                    singleKey = singleKey.split('/')[0];
                }
                mode = 'id';
            } else if (key.startsWith('name:')) {
                singleKey = '?nameOrDescription=' + encodeURIComponent(key.slice(5));
                mode = 'name';
            } else {
                // assume actual key was provided
                singleKey = 'key:' + encodeURIComponent(key);
                mode = 'key';
            }
        }

        try {
            const uri = `/interaction/v1/interactions/`;
            if ((singleKey && (mode === 'key' || mode === 'id')) || !retrieveDir) {
                // full details for retrieve, only base data for caching; reduces caching time from minutes to seconds
                const extras = retrieveDir && singleKey ? extrasDefault : '';

                // caching or single retrieve
                return await super.retrieveREST(
                    retrieveDir,
                    `${uri}${singleKey}?extras=${extras}${key && key.includes('/') ? '&versionNumber=' + key.split('/')[1] : ''}`,
                    null,
                    key
                );
            } else {
                // retrieve all
                const results = this.definition.restPagination
                    ? await this.client.rest.getBulk(
                          uri + (mode === 'name' ? singleKey : ''),
                          this.definition.restPageSize || 500
                      )
                    : await this.client.rest.get(uri + (mode === 'name' ? singleKey : ''));

                if (results.items?.length) {
                    // empty results will come back without "items" defined
                    Util.logger.info(
                        Util.getGrayMsg(
                            ` - ${results.items?.length} ${this.definition.type}s found. Retrieving details...`
                        )
                    );
                }
                // full details for retrieve
                const extras = extrasDefault;
                let parsed;
                if (retrieveDir) {
                    const searchName = mode === 'name' ? key.slice(5) : null;
                    const foundKey = [];
                    // get extra details for saving this
                    const details = results.items
                        ? await Promise.all(
                              results.items.map(async (a) => {
                                  if (mode === 'name') {
                                      // when filtering by name, the API in fact does a LIKE search with placeholders left and right of the search term - and also searches the description field.
                                      if (searchName === a[this.definition.nameField]) {
                                          foundKey.push(a[this.definition.keyField]);
                                      } else {
                                          // skip because the name does not match
                                          return null;
                                      }
                                  }
                                  try {
                                      return await this.client.rest.get(
                                          `${uri}key:${a[this.definition.keyField]}?extras=${extras}` +
                                              `&versionNumber=${a.version}`
                                      );
                                  } catch (ex) {
                                      // if we do get here, we should log the error and continue instead of failing to download all automations
                                      Util.logger.warn(
                                          ` ☇ skipping ${this.definition.type} ${
                                              a[this.definition.nameField]
                                          } (${a[this.definition.keyField]}): ${ex.message} (${
                                              ex.code
                                          })${
                                              ex.endpoint
                                                  ? Util.getGrayMsg(
                                                        ' - ' +
                                                            ex.endpoint.split(
                                                                'rest.marketingcloudapis.com'
                                                            )[1]
                                                    )
                                                  : ''
                                          }`
                                      );
                                      return null;
                                  }
                              })
                          )
                        : [];
                    parsed = this.parseResponseBody({ items: details.filter(Boolean) });
                    // * retrieveDir is mandatory in this method as it is not used for caching (there is a seperate method for that)
                    const savedMetadata = await this.saveResults(parsed, retrieveDir, null, null);
                    Util.logger.info(
                        `Downloaded: ${this.definition.type} (${Object.keys(savedMetadata).length})` +
                            Util.getKeysString(
                                mode === 'name' ? `${foundKey.join(', ')} (${key})` : key
                            )
                    );
                } else {
                    // limit to main details for caching
                    parsed = this.parseResponseBody(results);
                }

                return {
                    metadata: parsed,
                    type: this.definition.type,
                };
            }
        } catch (ex) {
            // if the interaction does not exist, the API returns an error code which would otherwise bring execution to a hold
            if (
                [
                    'Interaction matching key not found.',
                    'Must provide a valid ID or Key parameter',
                ].includes(ex.message)
            ) {
                Util.logger.info(
                    `Downloaded: ${this.definition.type} (0)${Util.getKeysString(
                        mode === 'id' ? singleKey : key,
                        mode === 'id'
                    )}`
                );
            } else {
                throw ex;
            }
        }
    }

    /**
     * Delete a metadata item from the specified business unit
     *
     * @param {string} key Identifier of item
     * @returns {Promise.<boolean>} deletion success status
     */
    static async deleteByKey(key) {
        let version;
        let singleKey = '';

        if (key.startsWith('id:') || key.startsWith('%23')) {
            // ! allow selecting journeys by ID because that's what users see in the URL
            // if the key started with %23 assume an ID was copied from the URL but the user forgot to prefix it with id:

            // remove id: or %23
            singleKey = key.slice(3);
            if (singleKey.startsWith('%23')) {
                // in the journey URL the Id is prefixed with an HTML-encoded "#" which could accidentally be copied by users
                // despite the slicing above, this still needs testing here because users might have prefixed the ID with id: but did not know to remove the #23
                singleKey = singleKey.slice(3);
            }
            if (singleKey.includes('/')) {
                // in the journey URL the version is appended after the ID, separated by a forward-slash.
                [singleKey, version] = singleKey.split('/');
            }
        } else {
            if (key.includes('/')) {
                // in the journey URL the version is appended after the ID, separated by a forward-slash.
                [key, version] = key.split('/');
            }

            // delete by key with specified version does not work, therefore we need to get the ID first
            const response = await this.client.rest.get(
                `/interaction/v1/interactions/key:${encodeURIComponent(key)}?extras=`
            );
            const results = this.parseResponseBody(response, key);
            singleKey = results[key].id;
            if (version && version !== '*' && version > results[key].version) {
                Util.logger.error(
                    `The chosen version (${version}) is higher than the latest known version (${results[key].version}). Please choose a lower version.`
                );
                return false;
            }
            Util.logger.debug(`Deleting interaction ${key} via its ID ${singleKey}`);
        }
        if (version !== '*') {
            if (!/^\d+$/.test(version)) {
                Util.logger.error(
                    'Version is required for deleting interactions to avoid accidental deletion of the wrong item. Please append it at the end of the key or id, separated by forward-slash. Example for deleting version 4: ' +
                        key +
                        '/4'
                );
                return false;
            }
            Util.logger.warn(
                `Deleting Journeys via this command breaks following retrieve-by-key/id requests until you've deployed/created a new draft version! You can get still get the latest available version of your journey by retrieving all interactions on this BU.`
            );
        }

        return super.deleteByKeyREST(
            '/interaction/v1/interactions/' +
                singleKey +
                (version === '*' ? '' : `?versionNumber=${version}`),
            key,
            false
        );
    }

    /**
     * Deploys metadata - merely kept here to be able to print {@link Util.logBeta} once per deploy
     *
     * @param {MetadataTypeMap} metadataMap metadata mapped by their keyField
     * @param {string} deployDir directory where deploy metadata are saved
     * @param {string} retrieveDir directory where metadata after deploy should be saved
     * @returns {Promise.<MetadataTypeMap>} Promise of keyField => metadata map
     */
    static async deploy(metadataMap, deployDir, retrieveDir) {
        Util.logBeta(this.definition.type);

        let needTransactionalEmail = false;
        for (const key in metadataMap) {
            if (metadataMap[key].definitionType == 'Transactional') {
                needTransactionalEmail = true;
                break;
            }
        }
        if (needTransactionalEmail && !cache.getCache()?.transactionalEmail) {
            // ! interaction and transactionalEmail both link to each other. caching transactionalEmail here "manually", assuming that it's quicker than the other way round
            Util.logger.info(' - Caching dependent Metadata: transactionalEmail');
            TransactionalEmail.buObject = this.buObject;
            TransactionalEmail.client = this.client;
            TransactionalEmail.properties = this.properties;
            const result = await TransactionalEmail.retrieveForCache();
            cache.setMetadata('transactionalEmail', result.metadata);
        }
        return super.deploy(metadataMap, deployDir, retrieveDir);
    }

    /**
     * Updates a single item
     *
     * @param {MetadataTypeItem} metadata a single item
     * @returns {Promise} Promise
     */
    static update(metadata) {
        return super.updateREST(
            metadata,
            '/interaction/v1/interactions/key:' + metadata.key,
            'put'
        );
    }

    /**
     * Creates a single item
     *
     * @param {MetadataTypeItem} metadata a single item
     * @returns {Promise} Promise
     */
    static create(metadata) {
        return super.createREST(metadata, '/interaction/v1/interactions/');
    }

    /**
     * Helper for writing Metadata to disk, used for Retrieve and deploy
     *
     * @param {MetadataTypeMap} results metadata results from deploy
     * @param {string} retrieveDir directory where metadata should be stored after deploy/retrieve
     * @param {string} [overrideType] for use when there is a subtype (such as folder-queries)
     * @param {TemplateMap} [templateVariables] variables to be replaced in the metadata
     * @returns {Promise.<MetadataTypeMap>} Promise of saved metadata
     */
    static async saveResults(results, retrieveDir, overrideType, templateVariables) {
        if (Object.keys(results).length) {
            // only execute the following if records were found
            await this._postRetrieveTasksBulk(results);
        }
        return super.saveResults(results, retrieveDir, overrideType, templateVariables);
    }

    /**
     * helper for Journey's {@link Journey.saveResults}. Gets executed after retreive of metadata type and
     *
     * @param {MetadataTypeMap} metadataMap key=customer key, value=metadata
     */
    static async _postRetrieveTasksBulk(metadataMap) {
        let needTransactionalEmail = false;
        for (const key in metadataMap) {
            if (metadataMap[key].definitionType == 'Transactional') {
                needTransactionalEmail = true;
                break;
            }
        }
        if (needTransactionalEmail && !cache.getCache()?.transactionalEmail) {
            // ! interaction and transactionalEmail both link to each other. caching transactionalEmail here "manually", assuming that it's quicker than the other way round
            Util.logger.info(' - Caching dependent Metadata: transactionalEmail');
            TransactionalEmail.buObject = this.buObject;
            TransactionalEmail.client = this.client;
            TransactionalEmail.properties = this.properties;
            const result = await TransactionalEmail.retrieveForCache();
            cache.setMetadata('transactionalEmail', result.metadata);
        }
    }

    /**
     * manages post retrieve steps
     *
     * @param {MetadataTypeItem} metadata a single item
     * @returns {Promise.<MetadataTypeItem>} Array with one metadata object
     */
    static async postRetrieveTasks(metadata) {
        // folder
        super.setFolderPath(metadata);

        switch (metadata.definitionType) {
            case 'Quicksend': // Single Send Journey
            case 'Multistep': {
                // Single Send Journey
                // ~~~ TRIGGERS ~~~~
                // event && triggers[].type === 'ContactAudience'
                // Multi-Step Journey
                // ~~~ TRIGGERS ~~~~
                // event / definitionType==='Multistep' && channel==='' && triggers[].type === 'EmailAudience'|'APIEvent'
                if (metadata.triggers?.length > 0) {
                    const search = ['arguments', 'metaData'];
                    for (const area of search) {
                        const config = metadata.triggers[0][area];
                        if (config?.eventDefinitionId) {
                            // trigger found; there can only be one entry in this array
                            try {
                                const edKey = cache.searchForField(
                                    'event',
                                    config.eventDefinitionId,
                                    'id',
                                    'eventDefinitionKey'
                                );
                                if (config.eventDefinitionKey !== edKey) {
                                    Util.logger.debug(
                                        `eventDefinitionKey not matching eventDefinitionId. Overwriting '${config.eventDefinitionKey}' with the correct key '${edKey}'.`
                                    );
                                }
                                config.r__event_key = edKey;

                                delete config.eventDefinitionKey;
                                delete config.eventDefinitionId;
                            } catch (ex) {
                                Util.logger.warn(
                                    ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                                        metadata[this.definition.keyField]
                                    }): ${ex.message}.`
                                );
                            }
                        }
                        if (config?.dataExtensionId) {
                            try {
                                config.r__dataExtension_key = cache.searchForField(
                                    'dataExtension',
                                    config.dataExtensionId,
                                    'ObjectID',
                                    'CustomerKey'
                                );
                                delete config.dataExtensionId;
                            } catch (ex) {
                                Util.logger.warn(
                                    ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                                        metadata[this.definition.keyField]
                                    }): ${ex.message}.`
                                );
                            }
                        }
                    }
                    try {
                        await Event.postRetrieveTasks_SalesforceEntryEvents(
                            metadata.triggers[0].type,
                            metadata.triggers[0].configurationArguments,
                            metadata.key,
                            metadata.status === 'Published',
                            this.definition.type
                        );
                    } catch (ex) {
                        Util.logger.warn(
                            ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${metadata[this.definition.keyField]}): ${ex.message}`
                        );
                    }
                }
                // ~~~ ACTIVITIES ~~~~

                this._postRetrieveTasks_activities(metadata);

                // TODO: journey template id? / metaData.templateId
                break;
            }
            case 'Transactional': {
                // Transactional Send Journey
                // ~~~ TRIGGERS ~~~~
                // ! journeys so far only supports transactional EMAIL messages. SMS and Push do not create their own journey.
                // ! transactional (email) journeys only have a dummy trigger without real content.
                // transactionalEmail / definitionType==='Transactional' && channel==='email' && triggers[].type === 'transactional-api'
                // --> nothing to do here

                // ~~~ ACTIVITIES ~~~~
                // ! transactional (email) journeys only have one activity (type=EMAILV2) which links back to the transactionalEmail ()
                switch (metadata.channel) {
                    case 'email': {
                        if (metadata.activities?.length > 0) {
                            const activity = metadata.activities[0];
                            // trigger found; there can only be one entry in this array

                            if (activity.configurationArguments?.triggeredSendId) {
                                try {
                                    const tEmailKey = cache.searchForField(
                                        'transactionalEmail',
                                        activity.configurationArguments?.triggeredSendId,
                                        'definitionId',
                                        'definitionKey'
                                    );
                                    if (
                                        activity.configurationArguments?.triggeredSendKey &&
                                        tEmailKey !=
                                            activity.configurationArguments?.triggeredSendKey
                                    ) {
                                        Util.logger.debug(
                                            `triggeredSendKey not matching triggeredSendId. Overwriting '${activity.configurationArguments.triggeredSendKey}' with the correct key '${tEmailKey}'.`
                                        );
                                    }
                                    activity.configurationArguments.r__transactionalEmail_key =
                                        activity.configurationArguments.triggeredSendKey;
                                    delete activity.configurationArguments.triggeredSendKey;
                                    delete activity.configurationArguments.triggeredSendId;
                                } catch (ex) {
                                    Util.logger.warn(
                                        ` - ${this.definition.type} ${
                                            metadata[this.definition.nameField]
                                        } (${metadata[this.definition.keyField]}): ${ex.message}.`
                                    );
                                }
                            }
                            if (
                                activity.metaData?.highThroughput?.definitionKey &&
                                activity.configurationArguments?.r__transactionalEmail_key &&
                                activity.metaData?.highThroughput?.definitionKey !=
                                    activity.configurationArguments.r__transactionalEmail_key
                            ) {
                                Util.logger.warn(
                                    ` - ${this.definition.type} ${
                                        metadata[this.definition.nameField]
                                    } (${metadata[this.definition.keyField]}): activities[0].metaData.highThroughput.definitionKey not matching key in activities[0].configurationArguments.r__transactionalEmail_key.`
                                );
                            } else if (
                                activity.configurationArguments?.r__transactionalEmail_key &&
                                metadata.status === 'Published'
                            ) {
                                // as long as status is Draft, we wont have r__transactionalEmail_key set as that record will not have been created
                                delete activity.metaData.highThroughput.definitionKey;
                            }

                            this._postRetrieveTasks_activities(metadata);

                            if (activity.metaData?.highThroughput?.dataExtensionId) {
                                try {
                                    activity.metaData.highThroughput.r__dataExtension_key =
                                        cache.searchForField(
                                            'dataExtension',
                                            activity.metaData.highThroughput.dataExtensionId,
                                            'ObjectID',
                                            'CustomerKey'
                                        );
                                    delete activity.metaData.highThroughput.dataExtensionId;
                                } catch (ex) {
                                    Util.logger.warn(
                                        ` - ${this.definition.type} ${
                                            metadata[this.definition.nameField]
                                        } (${metadata[this.definition.keyField]}): ${ex.message}.`
                                    );
                                }
                            }
                        }

                        break;
                    }
                    default: {
                        // it is expected that we'll see 'sms' and 'push' here in the future
                        Util.logger.warn(
                            ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                                metadata[this.definition.keyField]
                            }): channel ${
                                metadata.channel
                            } is not supported yet. Please open a ticket at https://github.com/Accenture/sfmc-devtools/issues/new/choose to request it`
                        );
                    }
                }

                break;
            }
            default: {
                Util.logger.warn(
                    ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                        metadata[this.definition.keyField]
                    }): definitionType ${
                        metadata.definitionType
                    } is not supported yet. Please open a ticket at https://github.com/Accenture/sfmc-devtools/issues/new/choose to request it`
                );
            }
        }

        return metadata;
    }

    /**
     * helper for {@link Journey.postRetrieveTasks}
     *
     * @private
     * @param {MetadataTypeItem} metadata a single item
     */
    static _postRetrieveTasks_activities(metadata) {
        for (const activity of metadata.activities) {
            switch (activity.type) {
                case 'EMAILV2': {
                    // triggeredSend + email+asset
                    const configurationArguments = activity.configurationArguments;
                    if (configurationArguments) {
                        try {
                            // configurationArguments.triggeredSendKey && configurationArguments.triggeredSendId are only set on a running journey; if a journey is new, they do not exist
                            if (configurationArguments.triggeredSendId) {
                                // triggeredSendKey is not always set but triggeredSendId is
                                const tsKey = cache.searchForField(
                                    'triggeredSend',
                                    configurationArguments.triggeredSendId,
                                    'ObjectID',
                                    'CustomerKey'
                                );
                                if (configurationArguments.triggeredSendKey != tsKey) {
                                    Util.logger.debug(
                                        `triggeredSendKey not matching triggeredSendId. Overwriting '${configurationArguments.triggeredSendKey}' with the correct key '${tsKey}'.`
                                    );
                                    configurationArguments.triggeredSendKey = tsKey;
                                }
                                configurationArguments.r__triggeredSend_key =
                                    configurationArguments.triggeredSendKey;
                                delete configurationArguments.triggeredSendKey;
                                delete configurationArguments.triggeredSendId;
                            } else if (configurationArguments.triggeredSendKey) {
                                // very rare case but it's been seen that no triggeredSendId was saved
                                Util.logger.debug(
                                    `triggeredSendKey found on activity but no triggeredSendId present on journey. Checking key directly...`
                                );
                                configurationArguments.r__triggeredSend_key = cache.searchForField(
                                    'triggeredSend',
                                    configurationArguments.triggeredSendKey,
                                    'CustomerKey',
                                    'CustomerKey'
                                );
                                delete configurationArguments.triggeredSendKey;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }
                    }
                    if (
                        configurationArguments?.triggeredSend &&
                        'string' === typeof configurationArguments?.triggeredSend
                    ) {
                        // sometimes, the API returns this object as a string for unknown reasons. Good job, product team!
                        configurationArguments.triggeredSend = JSON.parse(
                            configurationArguments?.triggeredSend
                        );
                    }
                    const triggeredSend = configurationArguments?.triggeredSend;
                    if (triggeredSend) {
                        // this section is likely only relevant for QuickSends and not for Multi-Step Journeys
                        // triggeredSend key
                        if (configurationArguments.r__transactionalEmail_key) {
                            const linkedTE = cache.getByKey(
                                'transactionalEmail',
                                configurationArguments.r__transactionalEmail_key
                            );
                            if (linkedTE) {
                                if (linkedTE.subscriptions) {
                                    triggeredSend.autoAddSubscribers =
                                        linkedTE.subscriptions.autoAddSubscriber;
                                    triggeredSend.autoUpdateSubscribers =
                                        linkedTE.subscriptions.updateSubscriber;

                                    // List
                                    if (linkedTE.subscriptions?.list) {
                                        triggeredSend.publicationListId = cache.searchForField(
                                            'list',
                                            linkedTE.subscriptions.list,
                                            'CustomerKey',
                                            'ID'
                                        );
                                    } else if (linkedTE.subscriptions.r__list_PathName) {
                                        delete triggeredSend.publicationListId;
                                        triggeredSend.r__list_PathName = {
                                            publicationList:
                                                linkedTE.subscriptions.r__list_PathName,
                                        };
                                    }

                                    // dataExtension
                                    if (linkedTE.subscriptions.dataExtension) {
                                        try {
                                            activity.metaData.highThroughput.r__dataExtension_key =
                                                cache.searchForField(
                                                    'dataExtension',
                                                    linkedTE.subscriptions.dataExtension,
                                                    'CustomerKey',
                                                    'CustomerKey'
                                                );
                                            delete activity.metaData.highThroughput.dataExtensionId;
                                        } catch (ex) {
                                            Util.logger.warn(
                                                ` - ${this.definition.type} ${
                                                    metadata[this.definition.nameField]
                                                } (${metadata[this.definition.keyField]}): ${ex.message}.`
                                            );
                                        }
                                    } else if (linkedTE.subscriptions.r__dataExtension_key) {
                                        activity.metaData.highThroughput.r__dataExtension_key =
                                            linkedTE.subscriptions.r__dataExtension_key;
                                        delete activity.metaData.highThroughput.dataExtensionId;
                                    }
                                }
                                if (linkedTE.options) {
                                    triggeredSend.isTrackingClicks = linkedTE.options.trackLinks;
                                }

                                // send classification
                                if (linkedTE.classification) {
                                    try {
                                        const scKey = cache.searchForField(
                                            'sendClassification',
                                            linkedTE.classification,
                                            'CustomerKey',
                                            'CustomerKey'
                                        );
                                        triggeredSend.r__sendClassification_key = scKey;
                                        delete triggeredSend.sendClassificationId;
                                    } catch (ex) {
                                        Util.logger.warn(
                                            ` - transactionalEmail ${linkedTE.definitionKey}: ${ex.message} (sendClassification key ${linkedTE.classification})`
                                        );
                                    }
                                } else if (linkedTE.r__sendClassification_key) {
                                    triggeredSend.r__sendClassification_key =
                                        linkedTE.r__sendClassification_key;
                                }

                                // senderProfile + deliveryProfile from sendClassification
                                if (triggeredSend.r__sendClassification_key) {
                                    const sc = cache.getByKey(
                                        'sendClassification',
                                        triggeredSend.r__sendClassification_key
                                    );

                                    if (sc.SenderProfile?.ObjectID) {
                                        triggeredSend.r__senderProfile_key = cache.searchForField(
                                            'senderProfile',
                                            sc.SenderProfile.ObjectID,
                                            'ObjectID',
                                            'CustomerKey'
                                        );
                                        delete triggeredSend.senderProfileId;
                                    } else if (sc.r__senderProfile_key) {
                                        triggeredSend.r__senderProfile_key =
                                            sc.r__senderProfile_key;
                                        delete triggeredSend.senderProfileId;
                                    }
                                    if (sc.DeliveryProfile?.ObjectID) {
                                        triggeredSend.r__deliveryProfile_key = cache.searchForField(
                                            'deliveryProfile',
                                            sc.DeliveryProfile.ObjectID,
                                            'ObjectID',
                                            'key'
                                        );
                                        delete triggeredSend.deliveryProfileId;
                                    } else if (sc.r__deliveryProfile_key) {
                                        triggeredSend.r__deliveryProfile_key =
                                            sc.r__deliveryProfile_key;
                                        delete triggeredSend.deliveryProfileId;
                                    }
                                }
                            }
                        } else if (configurationArguments.r__triggeredSend_key) {
                            // if we have a key set outside of this detailed triggeredSend config then lets overwrite what we've got here with what we cached from the related TS as it will be more current; but we cannot retrieve all info unfortunately
                            triggeredSend.r__triggeredSend_key =
                                configurationArguments.r__triggeredSend_key;
                            delete triggeredSend.id;
                            delete triggeredSend.key;
                            const linkedTS = cache.getByKey(
                                'triggeredSend',
                                configurationArguments.r__triggeredSend_key
                            );
                            if (linkedTS) {
                                triggeredSend.emailId = linkedTS.Email?.ID;
                                triggeredSend.dynamicEmailSubject = linkedTS.DynamicEmailSubject;
                                triggeredSend.emailSubject = linkedTS.EmailSubject;
                                // only the bccEmail field can be retrieved for triggeredSends, not the ccEmail field; for some reason BccEmail can be retrieved but does not return a value even if stored correctly in the journey.
                                // triggeredSend.bccEmail = linkedTS.BccEmail;
                                triggeredSend.isMultipart = linkedTS.IsMultipart;
                                triggeredSend.autoAddSubscribers = linkedTS.AutoAddSubscribers;
                                triggeredSend.autoUpdateSubscribers =
                                    linkedTS.AutoUpdateSubscribers;
                                triggeredSend.isTrackingClicks = !linkedTS.SuppressTracking;
                                triggeredSend.suppressTracking = linkedTS.SuppressTracking;
                                triggeredSend.triggeredSendStatus = linkedTS.TriggeredSendStatus;
                                // from name & email are set in the senderProfile, not in the triggeredSend
                                // triggeredSend.fromName = linkedTS.FromName;
                                // triggeredSend.fromAddress = linkedTS.FromAddress;

                                // List
                                if (linkedTS.List?.ID) {
                                    triggeredSend.publicationListId = linkedTS.List.ID;
                                } else if (linkedTS.r__list_PathName) {
                                    delete triggeredSend.publicationListId;
                                    triggeredSend.r__list_PathName = {
                                        publicationList: linkedTS.r__list_PathName,
                                    };
                                }
                                if (linkedTS.SenderProfile?.CustomerKey) {
                                    try {
                                        const spKey = cache.searchForField(
                                            'senderProfile',
                                            linkedTS.SenderProfile.ObjectID,
                                            'ObjectID',
                                            'CustomerKey'
                                        );
                                        triggeredSend.r__senderProfile_key = spKey;
                                        delete triggeredSend.senderProfileId;
                                    } catch (ex) {
                                        Util.logger.warn(
                                            ` - triggeredSend ${linkedTS.CustomerKey}: ${ex.message} (senderProfile key ${linkedTS.SenderProfile.CustomerKey})`
                                        );
                                    }
                                } else if (linkedTS.r__senderProfile_key) {
                                    triggeredSend.r__senderProfile_key =
                                        linkedTS.r__senderProfile_key;
                                }
                                // send classification
                                if (linkedTS.SendClassification?.CustomerKey) {
                                    try {
                                        const scKey = cache.searchForField(
                                            'sendClassification',
                                            linkedTS.SendClassification.ObjectID,
                                            'ObjectID',
                                            'CustomerKey'
                                        );
                                        triggeredSend.r__sendClassification_key = scKey;
                                        delete triggeredSend.sendClassificationId;
                                    } catch (ex) {
                                        Util.logger.warn(
                                            ` - triggeredSend ${linkedTS.CustomerKey}: ${ex.message} (sendClassification key ${linkedTS.SendClassification.CustomerKey})`
                                        );
                                    }
                                } else if (linkedTS.r__sendClassification_key) {
                                    triggeredSend.r__sendClassification_key =
                                        linkedTS.r__sendClassification_key;
                                }
                                if (linkedTS.c__priority) {
                                    delete triggeredSend.priority;
                                    triggeredSend.c__priority = linkedTS.c__priority;
                                }
                                if (linkedTS.Email?.ID) {
                                    triggeredSend.emailId = linkedTS.Email.ID;
                                } else if (linkedTS.r__asset_key) {
                                    delete triggeredSend.emailId;
                                    triggeredSend.r__asset_name_readOnly =
                                        linkedTS.r__asset_name_readOnly;
                                    triggeredSend.r__asset_key = linkedTS.r__asset_key;
                                }
                            }
                        } else if (triggeredSend.id) {
                            // triggeredSendKey is not always set but id is
                            const tsKey = cache.searchForField(
                                'triggeredSend',
                                triggeredSend.id,
                                'ObjectID',
                                'CustomerKey'
                            );
                            if (triggeredSend.key != tsKey) {
                                Util.logger.debug(
                                    `key not matching id. Overwriting '${triggeredSend.key}' with the correct key '${tsKey}'.`
                                );
                                triggeredSend.key = tsKey;
                            }
                            triggeredSend.r__triggeredSend_key = triggeredSend.key;
                            delete triggeredSend.key;
                            delete triggeredSend.id;
                        } else if (triggeredSend.key) {
                            // very rare case but it's been seen that no id was saved
                            Util.logger.debug(
                                `key found on triggeredSend but no id present on journey activity. Checking key directly...`
                            );
                            triggeredSend.r__triggeredSend_key = cache.searchForField(
                                'triggeredSend',
                                triggeredSend.key,
                                'CustomerKey',
                                'CustomerKey'
                            );
                            delete triggeredSend.key;
                        }

                        triggeredSend.ccEmail = triggeredSend.ccEmail
                            .split(';')
                            .filter((el) => el !== '');
                        triggeredSend.bccEmail = triggeredSend.bccEmail
                            .split(';')
                            .filter((el) => el !== '');

                        // List (optional)
                        triggeredSend.r__list_PathName ||= {};
                        if (triggeredSend.publicationListId) {
                            try {
                                triggeredSend.r__list_PathName.publicationList =
                                    cache.getListPathName(triggeredSend.publicationListId, 'ID');
                                delete triggeredSend.publicationListId;
                            } catch (ex) {
                                Util.logger.warn(
                                    ` - ${this.definition.typeName} '${metadata.name}'/'${metadata.key}': ${ex.message}`
                                );
                                // save this TSD because it could be fixed by the user
                            }
                        }
                        if (
                            triggeredSend.suppressionLists &&
                            Array.isArray(triggeredSend.suppressionLists) &&
                            triggeredSend.suppressionLists.length
                        ) {
                            triggeredSend.r__list_PathName.suppressionLists =
                                triggeredSend.suppressionLists.map((sList) => {
                                    try {
                                        return cache.getListPathName(sList.id, 'ID');
                                    } catch (ex) {
                                        Util.logger.warn(
                                            ` - ${this.definition.typeName} '${metadata.name}'/'${metadata.key}': ${ex.message}`
                                        );
                                        // save this TSD because it could be fixed by the user
                                    }
                                });
                            delete triggeredSend.suppressionLists;
                        }
                        if (!Object.keys(triggeredSend.r__list_PathName).length) {
                            // in case we found no linked lists, remove this empty shell
                            delete triggeredSend.r__list_PathName;
                        }

                        // DataExtension (optional)
                        triggeredSend.r__dataExtension_key = {};
                        if (
                            triggeredSend.domainExclusions &&
                            Array.isArray(triggeredSend.domainExclusions) &&
                            triggeredSend.domainExclusions.length
                        ) {
                            let errors = 0;
                            triggeredSend.r__dataExtension_key.domainExclusions =
                                triggeredSend.domainExclusions.map((de) => {
                                    try {
                                        return cache.searchForField(
                                            'dataExtension',
                                            de.id,
                                            'ObjectID',
                                            'CustomerKey'
                                        );
                                    } catch (ex) {
                                        errors++;
                                        Util.logger.warn(
                                            ` - ${this.definition.typeName} '${metadata.name}'/'${metadata.key}': ${ex.message}`
                                        );
                                        // save this TSD because it could be fixed by the user
                                    }
                                });
                            if (!errors) {
                                delete triggeredSend.domainExclusions; // array with id & name of DE
                            }
                        }
                        if (!Object.keys(triggeredSend.r__dataExtension_key).length) {
                            // in case we found no linked dataExtensions, remove this empty shell
                            delete triggeredSend.r__dataExtension_key;
                        }

                        // sender profile
                        if (triggeredSend.senderProfileId) {
                            try {
                                triggeredSend.r__senderProfile_key = cache.searchForField(
                                    'senderProfile',
                                    triggeredSend.senderProfileId,
                                    'ObjectID',
                                    'CustomerKey'
                                );
                                delete triggeredSend.senderProfileId;
                            } catch (ex) {
                                Util.logger.warn(
                                    ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                        metadata[this.definition.keyField]
                                    }): ${ex.message}`
                                );
                            }
                        }
                        // send classification
                        if (triggeredSend.sendClassificationId) {
                            try {
                                triggeredSend.r__sendClassification_key = cache.searchForField(
                                    'sendClassification',
                                    triggeredSend.sendClassificationId,
                                    'ObjectID',
                                    'CustomerKey'
                                );
                                delete triggeredSend.sendClassificationId;
                            } catch (ex) {
                                Util.logger.warn(
                                    ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                        metadata[this.definition.keyField]
                                    }): ${ex.message}`
                                );
                            }
                        }
                        // delivery profile
                        if (triggeredSend.deliveryProfileId) {
                            try {
                                triggeredSend.r__deliveryProfile_key = cache.searchForField(
                                    'deliveryProfile',
                                    triggeredSend.deliveryProfileId,
                                    'ObjectID',
                                    'key'
                                );
                                delete triggeredSend.deliveryProfileId;
                            } catch {
                                Util.logger.warn(
                                    ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                        metadata[this.definition.keyField]
                                    }): Dependent deliveryProfile was not found. Please note that this can only be resolved if you have at least ONE Send Classification set up on the target BU that uses this Delivery Profile.`
                                );
                            }
                        }
                        // message priority
                        if (triggeredSend.priority) {
                            triggeredSend.c__priority = Util.inverseGet(
                                this.definition.priorityMapping,
                                triggeredSend.priority
                            );
                            delete triggeredSend.priority;
                        }
                        // email
                        if (triggeredSend.emailId) {
                            try {
                                // content builder
                                triggeredSend.r__asset_name_readOnly = cache.searchForField(
                                    'asset',
                                    triggeredSend.emailId,
                                    'legacyData.legacyId',
                                    'name'
                                );
                                triggeredSend.r__asset_key = cache.searchForField(
                                    'asset',
                                    triggeredSend.emailId,
                                    'legacyData.legacyId',
                                    'customerKey'
                                );
                                delete triggeredSend.emailId;
                            } catch {
                                try {
                                    // classic
                                    triggeredSend.r__email_name = cache.searchForField(
                                        'email',
                                        triggeredSend.emailId,
                                        'ID',
                                        'Name'
                                    );
                                    delete triggeredSend.emailId;
                                } catch {
                                    Util.logger.warn(
                                        ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                            metadata[this.definition.keyField]
                                        }): Could not find email with ID ${triggeredSend.emailId} in Classic nor in Content Builder.`
                                    );
                                }
                            }
                        }

                        // sort attributes of triggeredSend alphabetically to allow for easier pull request reviews
                        configurationArguments.triggeredSend =
                            Util.sortObjectAttributes(triggeredSend);
                    }
                    break;
                }
                case 'SMSSYNC': {
                    const configurationArguments = activity.configurationArguments;
                    if (configurationArguments) {
                        // mobileMessage
                        try {
                            if (configurationArguments.messageId) {
                                configurationArguments.r__mobileMessage_key = cache.searchForField(
                                    'mobileMessage',
                                    configurationArguments.messageId,
                                    'id',
                                    'id'
                                );
                                delete configurationArguments.messageId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }
                        // mobileKeyword
                        configurationArguments.r__mobileKeyword_key = {};
                        try {
                            if (configurationArguments.keywordId) {
                                configurationArguments.r__mobileKeyword_key.current =
                                    cache.searchForField(
                                        'mobileKeyword',
                                        configurationArguments.keywordId,
                                        'id',
                                        'c__codeKeyword'
                                    );
                                delete configurationArguments.keywordId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }
                        try {
                            if (configurationArguments.nextKeywordId) {
                                configurationArguments.r__mobileKeyword_key.next =
                                    cache.searchForField(
                                        'mobileKeyword',
                                        configurationArguments.nextKeywordId,
                                        'id',
                                        'c__codeKeyword'
                                    );
                                delete configurationArguments.nextKeywordId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }
                        if (!Object.keys(configurationArguments.r__mobileKeyword_key).length) {
                            // in case we found no linked dataExtensions, remove this empty shell
                            delete configurationArguments.r__mobileKeyword_key;
                        }
                        // mobileCode
                        try {
                            if (configurationArguments.codeId) {
                                configurationArguments.r__mobileCode_key = cache.searchForField(
                                    'mobileCode',
                                    configurationArguments.codeId,
                                    'id',
                                    'code'
                                );
                                delete configurationArguments.codeId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }

                        try {
                            // asset-asset: jsonmessage
                            if (configurationArguments.assetId) {
                                configurationArguments.r__asset_name_readOnly =
                                    cache.searchForField(
                                        'asset',
                                        configurationArguments.assetId,
                                        'id',
                                        'name'
                                    );

                                configurationArguments.r__asset_key = cache.searchForField(
                                    'asset',
                                    configurationArguments.assetId,
                                    'id',
                                    'customerKey'
                                );
                                delete configurationArguments.assetId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }

                        // applicationExtensionId always equal "00000000-0000-0000-0000-000000000000"
                        delete configurationArguments.applicationExtensionId;
                    }
                    break;
                }
            }
        }

        // apply sorting by activity key to work around the API shuffling activities around
        metadata.activities = metadata.activities.sort((a, b) => a.key.localeCompare(b.key));
    }

    /**
     * prepares a TSD for deployment
     * ! BETA RELEASE of journey support (v4.3.0); it so far only resolves a limited amount of dependencies and will likely break during cross-BU deployments!
     *
     * @param {MetadataTypeItem} metadata of a single TSD
     * @returns {Promise.<MetadataTypeItem>} metadata object
     */
    static async preDeployTasks(metadata) {
        if (metadata.status !== 'Draft') {
            metadata.status = 'Draft';
        }

        // folder
        super.setFolderId(metadata);

        switch (metadata.definitionType) {
            case 'Quicksend':
            case 'Multistep': {
                // Multi-Step Journey
                // ~~~ TRIGGERS ~~~~

                // event / definitionType==='Multistep' && channel==='' && triggers[].type === 'EmailAudience'|'APIEvent'

                if (metadata.triggers?.length > 0) {
                    const search = ['arguments', 'metaData'];
                    for (const area of search) {
                        const config = metadata.triggers[0][area];
                        if (config?.r__event_key) {
                            // trigger found; there can only be one entry in this array
                            config.eventDefinitionId = cache.searchForField(
                                'event',
                                config.r__event_key,
                                'eventDefinitionKey',
                                'id'
                            );
                            config.eventDefinitionKey = config.r__event_key;
                            delete config.r__event_key;
                        }
                        if (config?.r__dataExtension_key) {
                            // trigger found; there can only be one entry in this array
                            config.dataExtensionId = cache.searchForField(
                                'dataExtension',
                                config.r__dataExtension_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            delete config.r__dataExtension_key;
                        }
                    }
                    await Event.preDeployTasks_SalesforceEntryEvents(
                        metadata.triggers[0].type,
                        metadata.triggers[0].configurationArguments
                    );
                }

                // transactionalEmail / definitionType==='Transactional' && channel==='email' && triggers[].type === 'transactional-api'

                // ~~~ ACTIVITIES ~~~~

                this._preDeployTasks_activities(metadata);

                break;
            }
            case 'Transactional': {
                // Transactional Send Journey
                // ~~~ TRIGGERS ~~~~
                // ! journeys so far transactional EMAIL messages. SMS and Push do not create their own journey.
                // ! transactional (email) journeys only have a dummy trigger without real content.

                // transactionalEmail / definitionType==='Transactional' && channel==='email' && triggers[].type === 'transactional-api'
                // --> nothing to do here

                // ~~~ ACTIVITIES ~~~~
                // ! transactional (email) journeys only have one activity (type=EMAILV2) which links back to the transactionalEmail ()
                switch (metadata.channel) {
                    case 'email': {
                        const activity = metadata.activities[0];
                        if (activity.configurationArguments?.r__transactionalEmail_key) {
                            // trigger found; there can only be one entry in this array
                            try {
                                activity.configurationArguments.triggeredSendId =
                                    cache.searchForField(
                                        'transactionalEmail',
                                        activity.configurationArguments.r__transactionalEmail_key,
                                        'definitionKey',
                                        'definitionId'
                                    );
                                activity.configurationArguments.triggeredSendKey =
                                    activity.configurationArguments.r__transactionalEmail_key;
                            } catch (ex) {
                                const isCreateMode = !cache.getByKey('journey', metadata.key);
                                if (isCreateMode && !Util.OPTIONS.publish) {
                                    // no need to add a log entry if the publish-option was provided
                                    Util.logger.info(
                                        ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                                            metadata[this.definition.keyField]
                                        }): To activate this transactional journey (and create the associated transactionalEmail record), please run 'mcdev publish ${this.buObject.credential}/${this.buObject.businessUnit} journey ${metadata.key}' or click on "Activate" in the GUI.`
                                    );
                                } else if (!isCreateMode) {
                                    // block deployment if we are in update mode
                                    throw ex;
                                }
                            }
                            if (activity.metaData?.highThroughput) {
                                // this is crucial for pinging the /interaction/v1/interactions/transactional/create endpoint that creates the transactionalEmail
                                activity.metaData.highThroughput.definitionKey =
                                    activity.configurationArguments.r__transactionalEmail_key;
                            }
                            delete activity.configurationArguments.r__transactionalEmail_key;
                        }

                        if (activity.metaData?.highThroughput?.r__dataExtension_key) {
                            activity.metaData.highThroughput.dataExtensionId = cache.searchForField(
                                'dataExtension',
                                activity.metaData.highThroughput.r__dataExtension_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            delete activity.metaData.highThroughput.r__dataExtension_key;
                        }

                        this._preDeployTasks_activities(metadata);

                        break;
                    }
                    default: {
                        // it is expected that we'll see 'sms' and 'push' here in the future
                        throw new Error(
                            ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                                metadata[this.definition.keyField]
                            }): channel ${
                                metadata.channel
                            } is not supported yet. Please open a ticket at https://github.com/Accenture/sfmc-devtools/issues/new/choose to request it`
                        );
                    }
                }

                break;
            }
            default: {
                throw new Error(
                    ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                        metadata[this.definition.keyField]
                    }): definitionType ${
                        metadata.definitionType
                    } is not supported yet. Please open a ticket at https://github.com/Accenture/sfmc-devtools/issues/new/choose to request it`
                );
            }
        }
        return metadata;
    }

    /**
     * helper for {@link Journey.preDeployTasks}
     *
     * @private
     * @param {MetadataTypeItem} metadata a single item
     */
    static _preDeployTasks_activities(metadata) {
        for (const activity of metadata.activities) {
            switch (activity.type) {
                case 'EMAILV2': {
                    // triggeredSend + email+asset
                    const configurationArguments = activity.configurationArguments;
                    if (configurationArguments?.r__triggeredSend_key) {
                        // triggeredSendKey is not always set but triggeredSendId is
                        try {
                            configurationArguments.triggeredSendId = cache.searchForField(
                                'triggeredSend',
                                configurationArguments.r__triggeredSend_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            configurationArguments.triggeredSendKey =
                                configurationArguments.r__triggeredSend_key;
                            delete configurationArguments.r__triggeredSend_key;
                        } catch {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${metadata[this.definition.keyField]}): Could not find triggeredSend with key ${configurationArguments.r__triggeredSend_key}. Attempting to let the API auto-create it`
                            );
                        }
                    }
                    const triggeredSend = configurationArguments?.triggeredSend;
                    if (triggeredSend) {
                        // triggeredSend key
                        if (
                            !configurationArguments.r__triggeredSend_key &&
                            triggeredSend.r__triggeredSend_key
                        ) {
                            try {
                                // key is not always set but id is
                                triggeredSend.id = cache.searchForField(
                                    'triggeredSend',
                                    triggeredSend.r__triggeredSend_key,
                                    'CustomerKey',
                                    'ObjectID'
                                );
                                triggeredSend.key = triggeredSend.r__triggeredSend_key;
                            } catch {
                                Util.logger.warn(
                                    ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${metadata[this.definition.keyField]}): Could not find triggeredSend with key ${triggeredSend.r__triggeredSend_key}. Attempting to let the API auto-create it`
                                );
                            }
                            delete triggeredSend.r__triggeredSend_key;
                        }

                        triggeredSend.ccEmail =
                            typeof triggeredSend.ccEmail === 'string'
                                ? triggeredSend.ccEmail
                                : triggeredSend.ccEmail.join(';');
                        triggeredSend.bccEmail =
                            typeof triggeredSend.bccEmail === 'string'
                                ? triggeredSend.bccEmail
                                : triggeredSend.bccEmail.join(';');

                        // List (optional)
                        if (triggeredSend.r__list_PathName) {
                            if (triggeredSend.r__list_PathName.publicationList) {
                                triggeredSend.publicationListId = cache.getListObjectId(
                                    triggeredSend.r__list_PathName.publicationList,
                                    'ID'
                                );
                            }
                            if (triggeredSend.r__list_PathName.suppressionLists?.length) {
                                triggeredSend.suppressionLists =
                                    triggeredSend.r__list_PathName.suppressionLists.map(
                                        (listPathName) => {
                                            const id = cache.getListObjectId(listPathName, 'ID');
                                            const name = cache.getListObjectId(
                                                listPathName,
                                                'ListName'
                                            );
                                            return { id, name };
                                        }
                                    );
                            }
                            delete triggeredSend.r__list_PathName;
                        }
                        // DataExtension (optional)
                        if (triggeredSend.r__dataExtension_key?.length) {
                            triggeredSend.domainExclusions = triggeredSend.r__dataExtension_key.map(
                                (key) => {
                                    const id = cache.searchForField(
                                        'dataExtension',
                                        key,
                                        'CustomerKey',
                                        'ObjectID'
                                    );
                                    const name = cache.searchForField(
                                        'dataExtension',
                                        key,
                                        'CustomerKey',
                                        'Name'
                                    );
                                    return { id, name };
                                }
                            );
                        }

                        // sender profile
                        if (triggeredSend.r__senderProfile_key) {
                            triggeredSend.senderProfileId = cache.searchForField(
                                'senderProfile',
                                triggeredSend.r__senderProfile_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            delete triggeredSend.r__senderProfile_key;
                        }
                        // send classification
                        if (triggeredSend.r__sendClassification_key) {
                            triggeredSend.sendClassificationId = cache.searchForField(
                                'sendClassification',
                                triggeredSend.r__sendClassification_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            delete triggeredSend.r__sendClassification_key;
                        }
                        // delivery profile
                        if (triggeredSend.r__deliveryProfile_key) {
                            // remove it because we cannot resolve it and it should be set by selecting the sendClassification
                            try {
                                triggeredSend.deliveryProfileId = cache.searchForField(
                                    'deliveryProfile',
                                    triggeredSend.r__deliveryProfile_key,
                                    'key',
                                    'ObjectID'
                                );
                                delete triggeredSend.r__deliveryProfile_key;
                            } catch (ex) {
                                Util.logger.error(
                                    `Could not find the ID for Delivery Profile '${triggeredSend.r__deliveryProfile_key}'. Please note that this can only be resolved if you have at least ONE Send Classification set up on the target BU that uses a Delivery Profile with this key.`
                                );
                                throw ex;
                            }
                        }

                        // message priority
                        if (triggeredSend.c__priority) {
                            triggeredSend.priority =
                                this.definition.priorityMapping[triggeredSend.c__priority];
                            delete triggeredSend.c__priority;
                        }

                        // email
                        if (triggeredSend.r__asset_key) {
                            triggeredSend.emailId = cache.searchForField(
                                'asset',
                                triggeredSend.r__asset_key,
                                'customerKey',
                                'legacyData.legacyId'
                            );
                            delete triggeredSend.r__asset_key;
                            delete triggeredSend.r__asset_name_readOnly;
                        } else if (triggeredSend.r__email_name) {
                            // classic
                            triggeredSend.emailId = cache.searchForField(
                                'email',
                                triggeredSend.r__email_name,
                                'Name',
                                'ID'
                            );
                            delete triggeredSend.r__email_name;
                        }
                    }

                    break;
                }
                case 'SMSSYNC': {
                    const configurationArguments = activity.configurationArguments;
                    if (configurationArguments) {
                        // mobileMessage
                        if (configurationArguments.r__mobileMessage_key) {
                            configurationArguments.messageId = cache.searchForField(
                                'mobileMessage',
                                configurationArguments.r__mobileMessage_key,
                                'id',
                                'id'
                            );
                            delete configurationArguments.r__mobileMessage_key;
                        }
                        // mobileKeyword
                        if (configurationArguments.r__mobileKeyword_key?.current) {
                            configurationArguments.keywordId = cache.searchForField(
                                'mobileKeyword',
                                configurationArguments.r__mobileKeyword_key.current,
                                'c__codeKeyword',
                                'id'
                            );
                        }
                        if (configurationArguments.r__mobileKeyword_key?.next) {
                            configurationArguments.nextKeywordId = cache.searchForField(
                                'mobileKeyword',
                                configurationArguments.r__mobileKeyword_key.next,
                                'c__codeKeyword',
                                'id'
                            );
                        }
                        delete configurationArguments.r__mobileKeyword_key;
                        // mobileCode
                        if (configurationArguments.r__mobileCode_key) {
                            configurationArguments.codeId = cache.searchForField(
                                'mobileCode',
                                configurationArguments.r__mobileCode_key,
                                'code',
                                'id'
                            );
                            delete configurationArguments.r__mobileCode_key;
                        }
                        // asset-asset: jsonmessage
                        if (configurationArguments.r__asset_key) {
                            configurationArguments.assetId = cache.searchForField(
                                'asset',
                                configurationArguments.r__asset_key,
                                'customerKey',
                                'id'
                            );
                            delete configurationArguments.r__asset_key;
                            delete configurationArguments.r__asset_name_readOnly;
                        }

                        // applicationExtensionId always equal "00000000-0000-0000-0000-000000000000"
                        configurationArguments.applicationExtensionId =
                            '00000000-0000-0000-0000-000000000000';
                    }

                    break;
                }
            }
        }
    }

    /**
     * helper for {@link MetadataType.upsert}
     *
     * @param {MetadataTypeMap} metadataMap list of metadata
     * @param {string} metadataKey key of item we are looking at
     * @param {boolean} hasError error flag from previous code
     * @param {MetadataTypeItemDiff[]} metadataToUpdate list of items to update
     * @param {MetadataTypeItem[]} metadataToCreate list of items to create
     * @returns {Promise.<'create'|'update'|'skip'>} action to take
     */
    static async createOrUpdate(
        metadataMap,
        metadataKey,
        hasError,
        metadataToUpdate,
        metadataToCreate
    ) {
        const action = await super.createOrUpdate(
            metadataMap,
            metadataKey,
            hasError,
            metadataToUpdate,
            metadataToCreate
        );
        if (action === 'update') {
            const normalizedKey = File.reverseFilterIllegalFilenames(
                metadataMap[metadataKey][this.definition.keyField]
            );
            const cachedVersion = cache.getByKey(this.definition.type, normalizedKey);
            if (cachedVersion) {
                if (cachedVersion.status === 'Draft') {
                    // add version to ensure we update the correct one
                    metadataMap[metadataKey].version = cachedVersion.version;
                    // update modifiedDate field to bypass API-error "Another user recently modified this journey. Refresh to edit the latest version."
                    metadataMap[metadataKey].modifiedDate = cachedVersion.modifiedDate;
                } else {
                    // remove last entry from metadataToUpdate again
                    metadataToUpdate.pop();
                    Util.logger.info(
                        ` - Found ${this.definition.type} ${
                            metadataMap[metadataKey][this.definition.nameField]
                        } (${
                            metadataMap[metadataKey][this.definition.keyField]
                        }) on BU, but it is not in Draft status. Will create new version.`
                    );
                    metadataToCreate.push(metadataMap[metadataKey]);
                    return 'create';
                }
            }
        }
        return action;
    }

    /**
     *
     * @param {MetadataTypeItem} item single metadata item
     * @param {string} [_] parameter not used
     * @param {Set.<string>} [findAssetKeys] list of keys that were found referenced via ContentBlockByX; if set, method only gets keys and runs no updates
     * @returns {Promise.<MetadataTypeItem>} key of the item that was updated
     */
    static async replaceCbReference(item, _, findAssetKeys) {
        const parentName = `${this.definition.type} ${item[this.definition.keyField]}`;
        let changes = false;
        let error;

        // *** type specific logic **

        // find email activities with triggeredSend configurationArguments
        const activities = item.activities.filter((activity) => activity.type === 'EMAILV2');
        if (!activities) {
            const ex = new Error('No changes made to the code.');
            // @ts-expect-error custom error object
            ex.code = 200;
            throw ex;
        }

        for (const activity of activities) {
            if (activity.arguments) {
                try {
                    activity.arguments.emailSubjectDataBound = ReplaceCbReference.replaceReference(
                        activity.arguments.emailSubjectDataBound,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
            }
            const triggeredSend = activity.configurationArguments?.triggeredSend;
            if (triggeredSend) {
                // the following is very similar but not equal to the variables in TriggeredSend.js
                try {
                    let bccEmail =
                        typeof triggeredSend.bccEmail === 'string'
                            ? triggeredSend.bccEmail
                            : triggeredSend.bccEmail.join(';');
                    bccEmail = ReplaceCbReference.replaceReference(
                        bccEmail,
                        parentName,
                        findAssetKeys
                    );
                    triggeredSend.bccEmail = bccEmail.split(';').filter((el) => el !== '');
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
                try {
                    let ccEmail =
                        typeof triggeredSend.ccEmail === 'string'
                            ? triggeredSend.ccEmail
                            : triggeredSend.ccEmail.join(';');
                    ccEmail = ReplaceCbReference.replaceReference(
                        ccEmail,
                        parentName,
                        findAssetKeys
                    );
                    triggeredSend.ccEmail = ccEmail.split(';').filter((el) => el !== '');
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
                try {
                    triggeredSend.dynamicEmailSubject = ReplaceCbReference.replaceReference(
                        triggeredSend.dynamicEmailSubject,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
                try {
                    triggeredSend.emailSubject = ReplaceCbReference.replaceReference(
                        triggeredSend.emailSubject,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
                try {
                    triggeredSend.preHeader = ReplaceCbReference.replaceReference(
                        triggeredSend.preHeader,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
                try {
                    triggeredSend.exclusionFilter = ReplaceCbReference.replaceReference(
                        triggeredSend.exclusionFilter,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
            }
        }

        if (error) {
            throw error;
        }

        if (!changes) {
            const ex = new Error('No changes made to the code.');
            // @ts-expect-error custom error object
            ex.code = 200;
            throw ex;
        }

        // *** finish ***
        // replaceReference will throw an error if nothing was updated which will end execution here
        // no error means we have a new item to deploy and need to update the item in our retrieve folder
        return item;
    }

    /**
     * Gets executed after deployment of metadata type
     *
     * @param {MetadataTypeMap} upsertResults metadata mapped by their keyField as returned by update/create
     */
    static async postDeployTasks(upsertResults) {
        if (Util.OPTIONS.publish) {
            Util.logger.info(`Publishing: ${this.definition.type}`);
            // pubslih
            const idArr = Object.values(upsertResults).map(
                (item) => 'id:' + item.id + '/' + item.version
            );
            await this.publish(idArr);
        }
    }

    /**
     * a function to publish the journey via API
     *
     * @param {string[]} keyArr keys or ids of the metadata
     * @returns {Promise.<string[]>} Returns list of updated keys/ids that were published. Success could only be seen with a delay in the UI because the publish-endpoint is async
     */
    static async publish(keyArr) {
        const resultsTransactional = [];
        // works only with objectId
        const statusUrls = [];
        const executedKeyArr = [];
        const metadataMap = await this.retrieveForCache();

        for (let key of keyArr) {
            let objectId;
            let version;
            let journey;
            if (!key) {
                continue;
            }
            if (key.startsWith('%23')) {
                // if the key started with %23 assume an ID was copied from the URL but the user forgot to prefix it with id:
                // correct the format
                key = 'id:' + key.slice(3);
            }
            if (key.startsWith('id:')) {
                // ! allow selecting journeys by ID because that's what users see in the URL
                // remove id
                objectId = key.slice(3);
                if (objectId.startsWith('%23')) {
                    // in the journey URL the Id is prefixed with an HTML-encoded "#" which could accidentally be copied by users
                    // despite the slicing above, this still needs testing here because users might have prefixed the ID with id: but did not know to remove the #23
                    objectId = objectId.slice(3);
                    // correct the format to ensure we show sth readable in the "Downloaded" log
                    // objectId =  objectId;
                    // update this here to show it in the log
                    key = 'id:' + objectId;
                }
                if (objectId.includes('/')) {
                    version = objectId.split('/')[1];
                    // in the journey URL the version is appended after the ID, separated by a forward-slash. Needs to be removed from the ID for caching as we always aim to retrieve the latest version only
                    objectId = objectId.split('/')[0];
                } else {
                    // if we didn't find a version we need to cache this from the API after all
                    if (key.includes('/')) {
                        // in the journey URL the version is appended after the ID, separated by a forward-slash. Needs to be removed from the key for caching as we always aim to retrieve the latest version only
                        key = key.split('/')[0];
                    }
                }
                journey = Object.values(metadataMap.metadata).find((el) => el.id === objectId);
                if (!journey) {
                    Util.logger.info(
                        ` ☇ skipping ${this.definition.type} ${key}: not found on server (1)`
                    );
                    continue;
                }
            } else {
                // key assumed
                journey = metadataMap.metadata[key];
            }

            if (!journey) {
                Util.logger.info(
                    ` ☇ skipping ${this.definition.type} ${key}: not found on server (2)`
                );
                continue;
            }
            if (!version) {
                version = journey.version;
            }
            if (journey.status === 'Published') {
                // api would return error code 30000 and ask to open a support case when in fact we simply already have a transactionalEmail created based on this status
                Util.logger.error(
                    ` ☇ skipping ${this.definition.type} ${
                        journey[this.definition.nameField]
                    } (${journey[this.definition.keyField]}): already published`
                );
                continue;
            }

            switch (journey.definitionType) {
                case 'Transactional': {
                    resultsTransactional.push(
                        (async () => {
                            try {
                                const response = await this.client.rest.post(
                                    `/interaction/v1/interactions/transactional/create`,
                                    { definitionId: journey.id }
                                );
                                if (response.errors?.length) {
                                    throw new Error(JSON.stringify(response));
                                } else {
                                    Util.logger.info(
                                        ` - published ${this.definition.type}: ${
                                            journey[this.definition.nameField]
                                        } (${journey[this.definition.keyField]}) by creating the matching transactionalEmail`
                                    );
                                    statusUrls.push({ key, statusUrl: response.statusUrl });
                                }
                                return key;
                            } catch (ex) {
                                if (
                                    ex.response.status === 400 &&
                                    ex.response?.data?.errors?.length === 1 &&
                                    ex.response?.data?.errors?.[0]?.errorCode === '121500'
                                ) {
                                    Util.logger.error(
                                        `Failed to publish ${
                                            journey[this.definition.nameField]
                                        } (${journey[this.definition.keyField]}): Make sure the Event Definition Key, Data Extension and E-Mail are saved to the journey`
                                    );
                                } else {
                                    Util.logger.error(
                                        `Failed to publish ${
                                            journey[this.definition.nameField]
                                        } (${journey[this.definition.keyField]}): ${ex.message}`
                                    );
                                    if (ex.response?.data?.errors?.length) {
                                        Util.logger.error(
                                            JSON.stringify(ex.response?.data?.errors, null, 2)
                                        );
                                    }
                                }
                            }
                        })()
                    );
                    break;
                }
                case 'Multistep': {
                    // SF Event, Api Event Journeys
                    // ! for SF-triggered journeys this cannot be asynchronous or it will cause a race-condition (see #1627 for details); the requests are accepted but then processed sequentually anyways, eliminating potential speed gains.
                    // It is unknown if the same would happen for API-event journeys but given that it's the same endpoint, lets not risk it and run this sequentially
                    let statusUrl;
                    try {
                        const response = await this.client.rest.post(
                            `/interaction/v1/interactions/publishAsync/${journey.id}?versionNumber=${version}`,
                            {}
                        ); // payload is empty for this request
                        if (response.statusUrl && response.statusId) {
                            Util.logger.info(
                                ` - ${this.definition.type} queued for publishing: ${journey[this.definition.keyField]}/${version} / ${journey[this.definition.nameField]}`
                            );
                            statusUrl = response.statusUrl;
                        } else {
                            throw new Error(response);
                        }
                        if (!Util.OPTIONS.skipStatusCheck && statusUrl) {
                            const spinner = yoctoSpinner({
                                text: `Publishing journey…`,
                            }).start();

                            await Util.sleep(1000);
                            executedKeyArr.push(
                                await this._checkPublishStatus(
                                    statusUrl,
                                    journey[this.definition.keyField],
                                    journey[this.definition.nameField],
                                    spinner
                                )
                            );
                        } else {
                            // no guarantees if the journey was actually published
                            executedKeyArr.push(key);
                        }
                    } catch (ex) {
                        switch (ex.message) {
                            case 'Cannot publish interaction in Published status.': {
                                Util.logger.info(
                                    ` - ${this.definition.type} ${key}/${version} is already published.`
                                );

                                break;
                            }
                            case 'Cannot publish interaction in Stopped status.': {
                                Util.logger.warn(
                                    ` - ${this.definition.type} ${key}/${version} is stopped. Please create a new version and publish that.`
                                );

                                break;
                            }
                            case 'Cannot publish interaction in Paused status.': {
                                Util.logger.warn(
                                    ` - ${this.definition.type} ${key}/${version} is already published but currently paused. Run 'mcdev resume' instead.`
                                );

                                break;
                            }
                            default: {
                                Util.logger.error(
                                    `Failed to publish ${this.definition.type} ${key}: ${ex.message}`
                                );
                            }
                        }
                    }
                    break;
                }
                default: {
                    throw new Error(
                        `${this.definition.type} type ${journey.definitionType} not supported yet by publish method`
                    );
                }
            }
        } // for loop

        // Transactional Send Journeys
        if (resultsTransactional.length) {
            const spinner = yoctoSpinner({
                text: `Publishing ${resultsTransactional.length} transactional journey${resultsTransactional.length === 1 ? '' : 's'}…`,
            }).start();
            const transactionalKeyArr = (await Promise.all(resultsTransactional)).filter(Boolean);
            spinner.success('done.');

            // if all publish actions failed, we don't need to re-retrieve anything here
            if (transactionalKeyArr.length) {
                executedKeyArr.push(...transactionalKeyArr);

                Util.logger.info('Retrieving relevant journeys');
                const retriever = new Retriever(this.properties, this.buObject);

                try {
                    const updatedJourneyRetrieve = await retriever.retrieve(
                        ['journey'],
                        transactionalKeyArr
                    );

                    /** @type {MetadataTypeItem[]} */
                    const updatedJourneys =
                        updatedJourneyRetrieve?.journey?.length > 1
                            ? Object.values(
                                  updatedJourneyRetrieve?.journey.reduce(
                                      (previousValue, currentValue) =>
                                          Object.assign(previousValue, currentValue),
                                      {}
                                  )
                              )
                            : Object.values(updatedJourneyRetrieve?.journey[0]);
                    if (updatedJourneys) {
                        const updatedTransactionalEmails = [];
                        for (const journey of updatedJourneys) {
                            updatedTransactionalEmails.push(
                                journey.activities?.[0]?.configurationArguments
                                    ?.r__transactionalEmail_key
                            );
                        }
                        if (updatedTransactionalEmails.filter(Boolean).length) {
                            Util.logger.info('Retrieving relevant transactionalEmails');
                            await retriever.retrieve(
                                ['transactionalEmail'],
                                updatedTransactionalEmails.filter(Boolean)
                            );
                        } else {
                            Util.logger.error(
                                `Could not find transactional Emails for the published journeys`
                            );
                        }
                    }
                } catch (ex) {
                    Util.logger.errorStack(ex, 'retrieve failed');
                }
            }
        }
        Util.logger.info(
            `Published ${executedKeyArr.filter(Boolean).length} of ${keyArr.length} items`
        );
        return executedKeyArr.filter(Boolean);
    }

    /**
     * helper for {@link Journey.publish}
     *
     * @param {string} statusUrl URL to check the status of the publish request
     * @param {string} key journey-key or id for log messages
     * @param {string} name journey-name for log messages
     * @param {import('yocto-spinner').Spinner} spinner reference to spinner to allow stopping it when done
     * @param {number} [tries] number of tries used to check the status
     * @returns {Promise.<string>} key of the item that was published successfully
     */
    static async _checkPublishStatus(statusUrl, key, name, spinner, tries = 1) {
        try {
            const response = await this.client.rest.get(statusUrl);
            switch (response.status) {
                case 'PublishCompleted': {
                    spinner.success('done.');
                    Util.logger.info(` - published ${this.definition.type}: ${key} / ${name}`);
                    this._showPublishStatusDetails(response);
                    return key;
                }
                case 'PublishInProcess': {
                    Util.logger.debug(
                        ` - publishing ${this.definition.type} still in progress: ${key} / ${name}`
                    );
                    if (tries < 50) {
                        await (tries < 10 ? Util.sleep(2000) : Util.sleep(5000));
                        return await this._checkPublishStatus(
                            statusUrl,
                            key,
                            name,
                            spinner,
                            tries + 1
                        );
                    } else {
                        return;
                    }
                }
                case 'Error': {
                    spinner.success('failed.');
                    Util.logger.error(
                        ` - publishing ${this.definition.type} failed: ${key} / ${name}`
                    );
                    this._showPublishStatusDetails(response);
                    return;
                }
                // No default
            }
        } catch (ex) {
            Util.logger.error(`Failed to check status of ${key}: ${ex.message}`);
        }
    }

    /**
     * helper for {@link Journey._checkPublishStatus}
     *
     * @param {{status:string, errors:Array, warnings:Array}} response publishStatus response
     */
    static _showPublishStatusDetails(response) {
        const types = { errors: 'Errors', warnings: 'Warnings' };
        const messages = { errors: [], warnings: [] };
        for (const type in types) {
            let counter = 1;
            if (response[type] && response[type].length) {
                messages[type].push(`   ${types[type]}:`);
                for (const msg of response[type]) {
                    messages[type].push(
                        `     #${counter++}`,
                        `     Code: ${msg.errorCode}`,
                        `     Details: ${msg.errorDetail.split(' EmailID: ').join('\n       EmailID: ').split(' Personalization error: ').join('\n       Personalization error: ')}`
                    );
                    if (msg.additionalInfo && Object.keys(msg.additionalInfo).length) {
                        messages[type].push(`     Additional Info:`);
                        for (const key in msg.additionalInfo) {
                            messages[type].push(`       ${key}: ${msg.additionalInfo[key]}`);
                        }
                    }
                    // add spacer line
                    messages[type].push('');
                }
            }
        }
        for (const msg of messages.errors) {
            Util.logger.error(msg);
        }
        for (const msg of messages.warnings) {
            Util.logger.warn(' ' + msg);
        }
    }
    /**
     * stops latest journey version
     *
     * @param {string[]} keyArr customerkey of the metadata
     * @returns {Promise.<string[]>} Returns list of keys that were paused
     */
    static async stop(keyArr) {
        let version;
        const endpoint = '/interaction/v1/interactions/stop/';
        const stoppedKeyArr = [];
        const apiLimit = pLimit(20);
        const journeyCache = await this.retrieveForCache();

        await Promise.allSettled(
            keyArr.map((key) =>
                apiLimit(async () => {
                    [key, version] = key.split('/');
                    if (journeyCache.metadata[key]) {
                        version ||= journeyCache.metadata[key].version;
                        if (version === '*') {
                            Util.logger.warn(
                                ` ☇ skipping ${this.definition.type} ${key}: Cannot stop all versions at once. The highest version is ${journeyCache.metadata[key].version}`
                            );
                            return;
                        }
                        try {
                            await this.client.rest.post(
                                endpoint +
                                    journeyCache.metadata[key].id +
                                    `?versionNumber=${version}`,
                                {}
                            );
                            Util.logger.info(
                                ` - Stopped ${this.definition.type} ${key}/${version}`
                            );
                            stoppedKeyArr.push(key);
                        } catch (ex) {
                            Util.logger.error(
                                ` - Stopping ${this.definition.type} ${key} failed: ${ex.message}`
                            );
                        }
                    }
                })
            )
        );

        return stoppedKeyArr;
    }
    /**
     * pauses selected journey versions
     *
     * @param {string[]} keyArr customerkey of the metadata
     * @returns {Promise.<string[]>} Returns list of keys that were paused
     */
    static async pause(keyArr) {
        let version;
        const stoppedKeyArr = [];
        const apiLimit = pLimit(20);
        const journeyCache = await this.retrieveForCache();

        await Promise.allSettled(
            keyArr.map((key) =>
                apiLimit(async () => {
                    [key, version] = key.split('/');
                    if (journeyCache.metadata[key]) {
                        switch (journeyCache.metadata[key].definitionType) {
                            case 'Transactional': {
                                try {
                                    const response = await this.client.rest.post(
                                        '/interaction/v1/interactions/transactional/pause',
                                        { definitionId: journeyCache.metadata[key].id }
                                    );
                                    if (response.errors?.length) {
                                        throw new Error(JSON.stringify(response));
                                    } else {
                                        Util.logger.info(
                                            ` - Paused ${this.definition.type} ${key} / ${journeyCache.metadata[key].name}`
                                        );
                                        stoppedKeyArr.push(key);
                                    }
                                } catch (ex) {
                                    Util.logger.error(
                                        ` - Pausing ${this.definition.type} ${key} / ${journeyCache.metadata[key].name} failed: ${ex.message}`
                                    );
                                }
                                break;
                            }
                            case 'Multistep': {
                                version ||= journeyCache.metadata[key].version;
                                try {
                                    await this.client.rest.post(
                                        '/interaction/v1/interactions/pause/' +
                                            journeyCache.metadata[key].id +
                                            (version === '*'
                                                ? '?allVersions=true'
                                                : `?versionNumber=${version}`),
                                        {}
                                    );
                                    Util.logger.info(
                                        ` - Paused ${this.definition.type} ${key}/${version} / ${journeyCache.metadata[key].name}`
                                    );
                                    stoppedKeyArr.push(key);
                                } catch (ex) {
                                    Util.logger.error(
                                        ` - Pausing ${this.definition.type} ${key} / ${journeyCache.metadata[key].name} failed: ${ex.message}`
                                    );
                                }
                                break;
                            }
                            default: {
                                Util.logger.error(
                                    ` - Pausing ${this.definition.type} ${key} failed: Unknown definitionType '${journeyCache.metadata[key].definitionType}'`
                                );
                            }
                        }
                    }
                })
            )
        );

        return stoppedKeyArr;
    }
    /**
     * resumes selected journey versions
     *
     * @param {string[]} keyArr customerkey of the metadata
     * @returns {Promise.<string[]>} Returns list of keys that were paused
     */
    static async execute(keyArr) {
        let version;
        const endpoint = '/interaction/v1/interactions/resume/';
        const resumedKeyArr = [];
        const apiLimit = pLimit(20);
        const journeyCache = await this.retrieveForCache();

        await Promise.allSettled(
            keyArr.map((key) =>
                apiLimit(async () => {
                    [key, version] = key.split('/');
                    if (journeyCache.metadata[key]) {
                        version ||= journeyCache.metadata[key].version;
                        try {
                            await this.client.rest.post(
                                endpoint +
                                    journeyCache.metadata[key].id +
                                    (version === '*'
                                        ? '?allVersions=true'
                                        : `?versionNumber=${version}`),
                                {}
                            );
                            Util.logger.info(
                                ` - Resumed ${this.definition.type} ${key}/${version}`
                            );
                            resumedKeyArr.push(key);
                        } catch (ex) {
                            Util.logger.error(
                                ` - Resuming ${this.definition.type} ${key} failed: ${ex.message}`
                            );
                        }
                    }
                })
            )
        );

        return resumedKeyArr;
    }
}

// Assign definition to static attributes
import MetadataTypeDefinitions from '../MetadataTypeDefinitions.js';
Journey.definition = MetadataTypeDefinitions.journey;

export default Journey;
