'use strict';

import MetadataType from './MetadataType.js';
import TransactionalEmail from './TransactionalEmail.js';
import TriggeredSend from './TriggeredSend.js';
import Event from './Event.js';
import { Util } from '../util/util.js';
import cache from '../util/cache.js';
import File from '../util/file.js';
import ReplaceCbReference from '../util/replaceContentBlockReference.js';
import Retriever from '../Retriever.js';
import pLimit from 'p-limit';
import yoctoSpinner from 'yocto-spinner';

/**
 * @typedef {import('../../types/mcdev.d.js').BuObject} BuObject
 * @typedef {import('../../types/mcdev.d.js').CodeExtract} CodeExtract
 * @typedef {import('../../types/mcdev.d.js').CodeExtractItem} CodeExtractItem
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeItem} MetadataTypeItem
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeItemDiff} MetadataTypeItemDiff
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeItemObj} MetadataTypeItemObj
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeMap} MetadataTypeMap
 * @typedef {import('../../types/mcdev.d.js').MetadataTypeMapObj} MetadataTypeMapObj
 * @typedef {import('../../types/mcdev.d.js').SoapRequestParams} SoapRequestParams
 * @typedef {import('../../types/mcdev.d.js').TemplateMap} TemplateMap
 * @typedef {import('../../types/mcdev.d.js').TypeKeyCombo} TypeKeyCombo
 */

/**
 * Journey MetadataType
 * ! BETA RELEASE of journey support (v4.3.0); it so far only resolves a limited amount of dependencies and will likely break during cross-BU deployments!
 * id: A unique id of the journey assigned by the journey’s API during its creation
 * key: A unique id of the journey within the MID. Can be generated by the developer
 * definitionId: A unique UUID provided by Salesforce Marketing Cloud. Each version of a journey has a unique DefinitionID while the Id and Key remain the same. Version 1 will have id == definitionId
 *
 * @augments MetadataType
 */
class Journey extends MetadataType {
    /**
     * Retrieves Metadata of Journey
     *
     * @param {string} retrieveDir Directory where retrieved metadata directory will be saved
     * @param {void | string[]} [_] unused parameter
     * @param {void | string[]} [__] unused parameter
     * @param {string} [key] customer key of single item to retrieve
     * @returns {Promise.<MetadataTypeMapObj>} Promise
     */
    static async retrieve(retrieveDir, _, __, key) {
        const extrasDefault = 'activities';
        if (retrieveDir) {
            // only print this during retrieve, not during retrieveForCache
            Util.logBeta(this.definition.type);
        }

        let singleKey = '';
        let mode = 'all';
        if (key) {
            if (key.startsWith('%23')) {
                // correct the format
                key = 'id:' + key.slice(3);
            }
            if (key.startsWith('id:')) {
                // ! allow selecting journeys by ID because that's what users see in the URL
                // if the key started with %23 assume an ID was copied from the URL but the user forgot to prefix it with id:

                // remove id: or %23
                singleKey = key.slice(3);
                if (singleKey.startsWith('%23')) {
                    // in the journey URL the Id is prefixed with an HTML-encoded "#" which could accidentally be copied by users
                    // despite the slicing above, this still needs testing here because users might have prefixed the ID with id: but did not know to remove the #23
                    singleKey = singleKey.slice(3);
                    // correct the format to ensure we show sth readable in the "Downloaded" log
                    key = 'id:' + singleKey;
                }
                if (singleKey.includes('/')) {
                    // in the journey URL the version is appended after the ID, separated by a forward-slash. Needs to be removed from the ID for the retrieve as we always aim to retrieve the latest version only
                    singleKey = singleKey.split('/')[0];
                }
                mode = 'id';
            } else if (key.startsWith('name:')) {
                singleKey = '?nameOrDescription=' + encodeURIComponent(key.slice(5));
                mode = 'name';
            } else {
                // assume actual key was provided
                singleKey = 'key:' + encodeURIComponent(key);
                mode = 'key';
            }
        }

        try {
            const uri = `/interaction/v1/interactions/`;
            if ((singleKey && (mode === 'key' || mode === 'id')) || !retrieveDir) {
                // full details for retrieve, only base data for caching; reduces caching time from minutes to seconds
                const extras = retrieveDir && singleKey ? extrasDefault : '';

                // caching or single retrieve
                return await super.retrieveREST(
                    retrieveDir,
                    `${uri}${singleKey}?extras=${extras}${key && key.includes('/') ? '&versionNumber=' + key.split('/')[1] : ''}`,
                    null,
                    key
                );
            } else {
                // retrieve all
                const results = this.definition.restPagination
                    ? await this.client.rest.getBulk(
                          uri + (mode === 'name' ? singleKey : ''),
                          this.definition.restPageSize || 500
                      )
                    : await this.client.rest.get(uri + (mode === 'name' ? singleKey : ''));

                if (results.items?.length) {
                    // empty results will come back without "items" defined
                    Util.logger.info(
                        Util.getGrayMsg(
                            ` - ${results.items?.length} ${this.definition.type}s found. Retrieving details...`
                        )
                    );
                }
                // full details for retrieve
                const extras = extrasDefault;
                let parsed;
                if (retrieveDir) {
                    const searchName = mode === 'name' ? key.slice(5) : null;
                    const foundKey = [];
                    // get extra details for saving this
                    const details = results.items
                        ? await Promise.all(
                              results.items.map(async (a) => {
                                  if (mode === 'name') {
                                      // when filtering by name, the API in fact does a LIKE search with placeholders left and right of the search term - and also searches the description field.
                                      if (searchName === a[this.definition.nameField]) {
                                          foundKey.push(a[this.definition.keyField]);
                                      } else {
                                          // skip because the name does not match
                                          return null;
                                      }
                                  }
                                  try {
                                      return await this.client.rest.get(
                                          `${uri}key:${a[this.definition.keyField]}?extras=${extras}` +
                                              `&versionNumber=${a.version}`
                                      );
                                  } catch (ex) {
                                      // if we do get here, we should log the error and continue instead of failing to download all automations
                                      Util.logger.warn(
                                          ` ☇ skipping ${this.definition.type} ${
                                              a[this.definition.nameField]
                                          } (${a[this.definition.keyField]}): ${ex.message} (${
                                              ex.code
                                          })${
                                              ex.endpoint
                                                  ? Util.getGrayMsg(
                                                        ' - ' +
                                                            ex.endpoint.split(
                                                                'rest.marketingcloudapis.com'
                                                            )[1]
                                                    )
                                                  : ''
                                          }`
                                      );
                                      return null;
                                  }
                              })
                          )
                        : [];
                    parsed = this.parseResponseBody({ items: details.filter(Boolean) });
                    // * retrieveDir is mandatory in this method as it is not used for caching (there is a seperate method for that)
                    const savedMetadata = await this.saveResults(parsed, retrieveDir, null, null);
                    Util.logger.info(
                        `Downloaded: ${this.definition.type} (${Object.keys(savedMetadata).length})` +
                            Util.getKeysString(
                                mode === 'name' ? `${foundKey.join(', ')} (${key})` : key
                            )
                    );
                } else {
                    // limit to main details for caching
                    parsed = this.parseResponseBody(results);
                }

                return {
                    metadata: parsed,
                    type: this.definition.type,
                };
            }
        } catch (ex) {
            // if the interaction does not exist, the API returns an error code which would otherwise bring execution to a hold
            if (
                [
                    'Interaction matching key not found.',
                    'Must provide a valid ID or Key parameter',
                ].includes(ex.message) ||
                (key && ex.code === 'ERR_BAD_REQUEST')
            ) {
                Util.logger.info(
                    `Downloaded: ${this.definition.type} (0)${Util.getKeysString(
                        mode === 'id' ? singleKey : key,
                        mode === 'id'
                    )}`
                );
            } else {
                throw ex;
            }
        }
    }

    /**
     * Delete a metadata item from the specified business unit
     *
     * @param {string} key Identifier of item
     * @returns {Promise.<boolean>} deletion success status
     */
    static async deleteByKey(key) {
        let version;
        let id;
        let cachedJourney;

        if (key.startsWith('id:') || key.startsWith('%23')) {
            // ! allow selecting journeys by ID because that's what users see in the URL
            // if the key started with %23 assume an ID was copied from the URL but the user forgot to prefix it with id:

            // remove id: or %23
            id = key.slice(3);
            if (id.startsWith('%23')) {
                // in the journey URL the Id is prefixed with an HTML-encoded "#" which could accidentally be copied by users
                // despite the slicing above, this still needs testing here because users might have prefixed the ID with id: but did not know to remove the #23
                id = id.slice(3);
            }
            if (id.includes('/')) {
                // in the journey URL the version is appended after the ID, separated by a forward-slash.
                [id, version] = id.split('/');
            }
            try {
                const response = await this.client.rest.get(
                    `/interaction/v1/interactions/${encodeURIComponent(id)}?extras=activities`
                );
                const results = this.parseResponseBody(response, key);
                cachedJourney = results[key];
            } catch {
                // handle below
            }
        } else {
            if (key.includes('/')) {
                // in the journey URL the version is appended after the ID, separated by a forward-slash.
                [key, version] = key.split('/');
            }

            // delete by key with specified version does not work, therefore we need to get the ID first
            try {
                const response = await this.client.rest.get(
                    `/interaction/v1/interactions/key:${encodeURIComponent(key)}?extras=activities`
                );
                const results = this.parseResponseBody(response, key);
                cachedJourney = results[key];
                id = cachedJourney?.id;
            } catch {
                // handle below
            }
        }
        if (!cachedJourney?.key) {
            Util.logger.warn(
                ` ☇ skipping deletion of ${this.definition.type} ${key}: not found on server`
            );
            return false;
        }
        switch (cachedJourney.definitionType) {
            case 'Multistep': {
                if (version && version !== '*' && version > cachedJourney.version) {
                    Util.logger.error(
                        `The chosen version (${version}) is higher than the latest known version (${cachedJourney.version}). Please choose a lower version.`
                    );
                    return false;
                }
                if (version !== '*') {
                    if (!/^\d+$/.test(version)) {
                        Util.logger.error(
                            'Version is required for deleting interactions to avoid accidental deletion of the wrong item. Please append it at the end of the key or id, separated by forward-slash. Example for deleting version 4: ' +
                                key +
                                '/4'
                        );
                        return false;
                    }
                    Util.logger.warn(
                        `Deleting Journeys via this command breaks following retrieve-by-key/id requests until you've deployed/created a new draft version! You can get still get the latest available version of your journey by retrieving all interactions on this BU.`
                    );
                }

                return super.deleteByKeyREST(
                    '/interaction/v1/interactions/' +
                        id +
                        (version === '*' ? '' : `?versionNumber=${version}`),
                    key,
                    false
                );
                // break;
            }
            default: {
                // Quicksend, Transactional dont have versions
                const response = await super.deleteByKeyREST(
                    '/interaction/v1/interactions/' + id,
                    key,
                    false
                );
                if (response && cachedJourney.definitionType === 'Transactional') {
                    const msg = [];
                    if (cachedJourney.activities[0]?.configurationArguments?.triggeredSendKey) {
                        msg.push(
                            `transactionalEmail "${cachedJourney.activities[0].configurationArguments.triggeredSendKey}"`
                        );
                    }
                    if (msg.length) {
                        Util.logger.info(` - Remember to also delete linked ${msg.join(' and ')}`);
                    }
                }
                return response;
            }
        }
    }

    /**
     * Deploys metadata - merely kept here to be able to print {@link Util.logBeta} once per deploy
     *
     * @param {MetadataTypeMap} metadataMap metadata mapped by their keyField
     * @param {string} deployDir directory where deploy metadata are saved
     * @param {string} retrieveDir directory where metadata after deploy should be saved
     * @returns {Promise.<MetadataTypeMap>} Promise of keyField => metadata map
     */
    static async deploy(metadataMap, deployDir, retrieveDir) {
        Util.logBeta(this.definition.type);

        let needTransactionalEmail = false;
        for (const key in metadataMap) {
            if (metadataMap[key].definitionType == 'Transactional') {
                needTransactionalEmail = true;
                break;
            }
        }
        if (needTransactionalEmail && !cache.getCache()?.transactionalEmail) {
            // ! interaction and transactionalEmail both link to each other. caching transactionalEmail here "manually", assuming that it's quicker than the other way round
            Util.logger.info(' - Caching dependent Metadata: transactionalEmail');
            TransactionalEmail.buObject = this.buObject;
            TransactionalEmail.client = this.client;
            TransactionalEmail.properties = this.properties;
            const result = await TransactionalEmail.retrieveForCache();
            cache.setMetadata('transactionalEmail', result.metadata);
        }
        return super.deploy(metadataMap, deployDir, retrieveDir);
    }

    /**
     * Updates a single item
     *
     * @param {MetadataTypeItem} metadata a single item
     * @returns {Promise} Promise
     */
    static update(metadata) {
        return super.updateREST(
            metadata,
            '/interaction/v1/interactions/key:' + metadata.key,
            'put'
        );
    }

    /**
     * Creates a single item
     *
     * @param {MetadataTypeItem} metadata a single item
     * @returns {Promise} Promise
     */
    static create(metadata) {
        return super.createREST(metadata, '/interaction/v1/interactions/');
    }

    /**
     * Helper for writing Metadata to disk, used for Retrieve and deploy
     *
     * @param {MetadataTypeMap} results metadata results from deploy
     * @param {string} retrieveDir directory where metadata should be stored after deploy/retrieve
     * @param {string} [overrideType] for use when there is a subtype (such as folder-queries)
     * @param {TemplateMap} [templateVariables] variables to be replaced in the metadata
     * @returns {Promise.<MetadataTypeMap>} Promise of saved metadata
     */
    static async saveResults(results, retrieveDir, overrideType, templateVariables) {
        if (Object.keys(results).length) {
            // only execute the following if records were found
            await this._postRetrieveTasksBulk(results);
        }
        return super.saveResults(results, retrieveDir, overrideType, templateVariables);
    }

    /**
     * helper for Journey's {@link Journey.saveResults}. Gets executed after retreive of metadata type and
     *
     * @param {MetadataTypeMap} metadataMap key=customer key, value=metadata
     */
    static async _postRetrieveTasksBulk(metadataMap) {
        let needTransactionalEmail = false;
        for (const key in metadataMap) {
            if (metadataMap[key].definitionType == 'Transactional') {
                needTransactionalEmail = true;
                break;
            }
        }
        if (needTransactionalEmail && !cache.getCache()?.transactionalEmail) {
            // ! interaction and transactionalEmail both link to each other. caching transactionalEmail here "manually", assuming that it's quicker than the other way round
            Util.logger.info(' - Caching dependent Metadata: transactionalEmail');
            TransactionalEmail.buObject = this.buObject;
            TransactionalEmail.client = this.client;
            TransactionalEmail.properties = this.properties;
            const result = await TransactionalEmail.retrieveForCache();
            cache.setMetadata('transactionalEmail', result.metadata);
        }
    }

    /**
     * manages post retrieve steps
     *
     * @param {MetadataTypeItem} metadata a single item
     * @returns {Promise.<MetadataTypeItem>} Array with one metadata object
     */
    static async postRetrieveTasks(metadata) {
        // folder
        super.setFolderPath(metadata);

        switch (metadata.definitionType) {
            case 'Quicksend': // Single Send Journey
            case 'Multistep': {
                // Single Send Journey
                // ~~~ TRIGGERS ~~~~
                // event && triggers[].type === 'ContactAudience'
                // Multi-Step Journey
                // ~~~ TRIGGERS ~~~~
                // event / definitionType==='Multistep' && channel==='' && triggers[].type === 'EmailAudience'|'APIEvent'
                if (metadata.triggers?.length > 0) {
                    const search = ['arguments', 'metaData'];
                    for (const area of search) {
                        const config = metadata.triggers[0][area];
                        if (config?.eventDefinitionId) {
                            // trigger found; there can only be one entry in this array
                            try {
                                const edKey = cache.searchForField(
                                    'event',
                                    config.eventDefinitionId,
                                    'id',
                                    'eventDefinitionKey'
                                );
                                if (config.eventDefinitionKey !== edKey) {
                                    Util.logger.debug(
                                        `eventDefinitionKey not matching eventDefinitionId. Overwriting '${config.eventDefinitionKey}' with the correct key '${edKey}'.`
                                    );
                                }
                                config.r__event_key = edKey;

                                delete config.eventDefinitionKey;
                                delete config.eventDefinitionId;
                            } catch (ex) {
                                const msg = ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                                    metadata[this.definition.keyField]
                                }) ${metadata.status}: ${ex.message}.`;
                                Util.logger.warn(
                                    metadata.status === 'Published' ? msg : Util.getGrayMsg(msg)
                                );
                            }
                        }
                        if (config?.dataExtensionId) {
                            try {
                                config.r__dataExtension_key = cache.searchForField(
                                    'dataExtension',
                                    config.dataExtensionId,
                                    'ObjectID',
                                    'CustomerKey'
                                );
                                delete config.dataExtensionId;
                            } catch (ex) {
                                Util.logger.warn(
                                    ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                                        metadata[this.definition.keyField]
                                    }): ${ex.message}.`
                                );
                            }
                        }
                    }
                    try {
                        await Event.postRetrieveTasks_SalesforceEntryEvents(
                            metadata.triggers[0].type,
                            metadata.triggers[0].configurationArguments,
                            metadata.key,
                            metadata.status === 'Published',
                            this.definition.type
                        );
                    } catch (ex) {
                        const msg = ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${metadata[this.definition.keyField]}) ${metadata.status}: ${ex.message}`;
                        Util.logger.warn(
                            metadata.status === 'Published' ? msg : Util.getGrayMsg(msg)
                        );
                    }
                }
                // ~~~ ACTIVITIES ~~~~

                this._postRetrieveTasks_activities(metadata);

                // TODO: journey template id? / metaData.templateId
                break;
            }
            case 'Transactional': {
                // Transactional Send Journey
                // ~~~ TRIGGERS ~~~~
                // ! journeys so far only supports transactional EMAIL messages. SMS and Push do not create their own journey.
                // ! transactional (email) journeys only have a dummy trigger without real content.
                // transactionalEmail / definitionType==='Transactional' && channel==='email' && triggers[].type === 'transactional-api'
                // --> nothing to do here

                // ~~~ ACTIVITIES ~~~~
                // ! transactional (email) journeys only have one activity (type=EMAILV2) which links back to the transactionalEmail ()
                switch (metadata.channel) {
                    case 'email': {
                        if (metadata.activities?.length > 0) {
                            const activity = metadata.activities[0];
                            // trigger found; there can only be one entry in this array

                            if (activity.configurationArguments?.triggeredSendId) {
                                try {
                                    const tEmailKey = cache.searchForField(
                                        'transactionalEmail',
                                        activity.configurationArguments?.triggeredSendId,
                                        'definitionId',
                                        'definitionKey'
                                    );
                                    if (
                                        activity.configurationArguments?.triggeredSendKey &&
                                        tEmailKey !=
                                            activity.configurationArguments?.triggeredSendKey
                                    ) {
                                        Util.logger.debug(
                                            `triggeredSendKey not matching triggeredSendId. Overwriting '${activity.configurationArguments.triggeredSendKey}' with the correct key '${tEmailKey}'.`
                                        );
                                    }
                                    activity.configurationArguments.r__transactionalEmail_key =
                                        activity.configurationArguments.triggeredSendKey;
                                    delete activity.configurationArguments.triggeredSendKey;
                                    delete activity.configurationArguments.triggeredSendId;
                                } catch (ex) {
                                    Util.logger.warn(
                                        ` - ${this.definition.type} ${
                                            metadata[this.definition.nameField]
                                        } (${metadata[this.definition.keyField]}): ${ex.message}.`
                                    );
                                }
                            }
                            if (
                                activity.metaData?.highThroughput?.definitionKey &&
                                activity.configurationArguments?.r__transactionalEmail_key &&
                                activity.metaData?.highThroughput?.definitionKey !=
                                    activity.configurationArguments.r__transactionalEmail_key
                            ) {
                                Util.logger.warn(
                                    ` - ${this.definition.type} ${
                                        metadata[this.definition.nameField]
                                    } (${metadata[this.definition.keyField]}): activities[0].metaData.highThroughput.definitionKey not matching key in activities[0].configurationArguments.r__transactionalEmail_key.`
                                );
                            } else if (
                                activity.configurationArguments?.r__transactionalEmail_key &&
                                metadata.status === 'Published'
                            ) {
                                // as long as status is Draft, we wont have r__transactionalEmail_key set as that record will not have been created
                                delete activity.metaData.highThroughput.definitionKey;
                            }

                            this._postRetrieveTasks_activities(metadata);

                            if (activity.metaData?.highThroughput?.dataExtensionId) {
                                try {
                                    activity.metaData.highThroughput.r__dataExtension_key =
                                        cache.searchForField(
                                            'dataExtension',
                                            activity.metaData.highThroughput.dataExtensionId,
                                            'ObjectID',
                                            'CustomerKey'
                                        );
                                    delete activity.metaData.highThroughput.dataExtensionId;
                                } catch (ex) {
                                    Util.logger.warn(
                                        ` - ${this.definition.type} ${
                                            metadata[this.definition.nameField]
                                        } (${metadata[this.definition.keyField]}): ${ex.message}.`
                                    );
                                }
                            }
                        }

                        break;
                    }
                    default: {
                        // it is expected that we'll see 'sms' and 'push' here in the future
                        Util.logger.warn(
                            ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                                metadata[this.definition.keyField]
                            }): channel ${
                                metadata.channel
                            } is not supported yet. Please open a ticket at https://github.com/Accenture/sfmc-devtools/issues/new/choose to request it`
                        );
                    }
                }

                break;
            }
            default: {
                Util.logger.warn(
                    ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                        metadata[this.definition.keyField]
                    }): definitionType ${
                        metadata.definitionType
                    } is not supported yet. Please open a ticket at https://github.com/Accenture/sfmc-devtools/issues/new/choose to request it`
                );
            }
        }

        return metadata;
    }

    /**
     * helper for {@link Journey.postRetrieveTasks}
     *
     * @private
     * @param {MetadataTypeItem} metadata a single item
     */
    static _postRetrieveTasks_activities(metadata) {
        for (const activity of metadata.activities) {
            switch (activity.type) {
                case 'EMAILV2': {
                    // triggeredSend + email+asset
                    const configurationArguments = activity.configurationArguments;
                    if (configurationArguments) {
                        try {
                            // configurationArguments.triggeredSendKey && configurationArguments.triggeredSendId are only set on a running journey; if a journey is new, they do not exist
                            if (configurationArguments.triggeredSendId) {
                                // triggeredSendKey is not always set but triggeredSendId is
                                const tsKey = cache.searchForField(
                                    'triggeredSend',
                                    configurationArguments.triggeredSendId,
                                    'ObjectID',
                                    'CustomerKey'
                                );
                                if (configurationArguments.triggeredSendKey != tsKey) {
                                    Util.logger.debug(
                                        `triggeredSendKey not matching triggeredSendId. Overwriting '${configurationArguments.triggeredSendKey}' with the correct key '${tsKey}'.`
                                    );
                                    configurationArguments.triggeredSendKey = tsKey;
                                }
                                configurationArguments.r__triggeredSend_key =
                                    configurationArguments.triggeredSendKey;
                                delete configurationArguments.triggeredSendKey;
                                delete configurationArguments.triggeredSendId;
                            } else if (configurationArguments.triggeredSendKey) {
                                // very rare case but it's been seen that no triggeredSendId was saved
                                Util.logger.debug(
                                    `triggeredSendKey found on activity but no triggeredSendId present on journey. Checking key directly...`
                                );
                                configurationArguments.r__triggeredSend_key = cache.searchForField(
                                    'triggeredSend',
                                    configurationArguments.triggeredSendKey,
                                    'CustomerKey',
                                    'CustomerKey'
                                );
                                delete configurationArguments.triggeredSendKey;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }
                    }
                    if (
                        configurationArguments?.triggeredSend &&
                        'string' === typeof configurationArguments?.triggeredSend
                    ) {
                        // sometimes, the API returns this object as a string for unknown reasons. Good job, product team!
                        configurationArguments.triggeredSend = JSON.parse(
                            configurationArguments?.triggeredSend
                        );
                    }
                    const triggeredSend = configurationArguments?.triggeredSend;
                    if (triggeredSend) {
                        // this section is likely only relevant for QuickSends and not for Multi-Step Journeys
                        // triggeredSend key
                        if (configurationArguments.r__transactionalEmail_key) {
                            const linkedTE = cache.getByKey(
                                'transactionalEmail',
                                configurationArguments.r__transactionalEmail_key
                            );
                            if (linkedTE) {
                                if (linkedTE.subscriptions) {
                                    triggeredSend.autoAddSubscribers =
                                        linkedTE.subscriptions.autoAddSubscriber;
                                    triggeredSend.autoUpdateSubscribers =
                                        linkedTE.subscriptions.updateSubscriber;

                                    // List
                                    if (linkedTE.subscriptions?.list) {
                                        triggeredSend.publicationListId = cache.searchForField(
                                            'list',
                                            linkedTE.subscriptions.list,
                                            'CustomerKey',
                                            'ID'
                                        );
                                    } else if (linkedTE.subscriptions.r__list_PathName) {
                                        delete triggeredSend.publicationListId;
                                        triggeredSend.r__list_PathName = {
                                            publicationList:
                                                linkedTE.subscriptions.r__list_PathName,
                                        };
                                    }

                                    // dataExtension
                                    if (linkedTE.subscriptions.dataExtension) {
                                        try {
                                            activity.metaData.highThroughput.r__dataExtension_key =
                                                cache.searchForField(
                                                    'dataExtension',
                                                    linkedTE.subscriptions.dataExtension,
                                                    'CustomerKey',
                                                    'CustomerKey'
                                                );
                                            delete activity.metaData.highThroughput.dataExtensionId;
                                        } catch (ex) {
                                            Util.logger.warn(
                                                ` - ${this.definition.type} ${
                                                    metadata[this.definition.nameField]
                                                } (${metadata[this.definition.keyField]}): ${ex.message}.`
                                            );
                                        }
                                    } else if (linkedTE.subscriptions.r__dataExtension_key) {
                                        activity.metaData.highThroughput.r__dataExtension_key =
                                            linkedTE.subscriptions.r__dataExtension_key;
                                        delete activity.metaData.highThroughput.dataExtensionId;
                                    }
                                }
                                if (linkedTE.options) {
                                    triggeredSend.isTrackingClicks =
                                        linkedTE.options.trackLinks || false;
                                    triggeredSend.ccEmail = linkedTE.options.cc || '';
                                    triggeredSend.bccEmail = linkedTE.options.bcc || '';
                                }

                                // send classification
                                if (linkedTE.classification) {
                                    try {
                                        const scKey = cache.searchForField(
                                            'sendClassification',
                                            linkedTE.classification,
                                            'CustomerKey',
                                            'CustomerKey'
                                        );
                                        triggeredSend.r__sendClassification_key = scKey;
                                        delete triggeredSend.sendClassificationId;
                                    } catch (ex) {
                                        Util.logger.warn(
                                            ` - transactionalEmail ${linkedTE.definitionKey}: ${ex.message} (sendClassification key ${linkedTE.classification})`
                                        );
                                    }
                                } else if (linkedTE.r__sendClassification_key) {
                                    triggeredSend.r__sendClassification_key =
                                        linkedTE.r__sendClassification_key;
                                }

                                // senderProfile + deliveryProfile from sendClassification
                                if (triggeredSend.r__sendClassification_key) {
                                    const sc = cache.getByKey(
                                        'sendClassification',
                                        triggeredSend.r__sendClassification_key
                                    );

                                    if (sc.SenderProfile?.ObjectID) {
                                        triggeredSend.r__senderProfile_key = cache.searchForField(
                                            'senderProfile',
                                            sc.SenderProfile.ObjectID,
                                            'ObjectID',
                                            'CustomerKey'
                                        );
                                        delete triggeredSend.senderProfileId;
                                    } else if (sc.r__senderProfile_key) {
                                        triggeredSend.r__senderProfile_key =
                                            sc.r__senderProfile_key;
                                        delete triggeredSend.senderProfileId;
                                    }
                                    if (sc.DeliveryProfile?.ObjectID) {
                                        triggeredSend.r__deliveryProfile_key = cache.searchForField(
                                            'deliveryProfile',
                                            sc.DeliveryProfile.ObjectID,
                                            'ObjectID',
                                            'key'
                                        );
                                        delete triggeredSend.deliveryProfileId;
                                    } else if (sc.r__deliveryProfile_key) {
                                        triggeredSend.r__deliveryProfile_key =
                                            sc.r__deliveryProfile_key;
                                        delete triggeredSend.deliveryProfileId;
                                    }
                                }
                            }
                        } else if (configurationArguments.r__triggeredSend_key) {
                            // if we have a key set outside of this detailed triggeredSend config then lets overwrite what we've got here with what we cached from the related TS as it will be more current; but we cannot retrieve all info unfortunately
                            triggeredSend.r__triggeredSend_key =
                                configurationArguments.r__triggeredSend_key;
                            delete triggeredSend.id;
                            delete triggeredSend.key;
                            const linkedTS = cache.getByKey(
                                'triggeredSend',
                                configurationArguments.r__triggeredSend_key
                            );
                            if (linkedTS) {
                                triggeredSend.emailId = linkedTS.Email?.ID;
                                triggeredSend.dynamicEmailSubject = linkedTS.DynamicEmailSubject;
                                triggeredSend.emailSubject = linkedTS.EmailSubject;
                                // only the bccEmail field can be retrieved for triggeredSends, not the ccEmail field; for some reason BccEmail can be retrieved but does not return a value even if stored correctly in the journey.
                                // triggeredSend.bccEmail = linkedTS.BccEmail;
                                triggeredSend.isMultipart = linkedTS.IsMultipart;
                                triggeredSend.autoAddSubscribers = linkedTS.AutoAddSubscribers;
                                triggeredSend.autoUpdateSubscribers =
                                    linkedTS.AutoUpdateSubscribers;
                                triggeredSend.isTrackingClicks = !linkedTS.SuppressTracking;
                                triggeredSend.suppressTracking = linkedTS.SuppressTracking;
                                triggeredSend.triggeredSendStatus = linkedTS.TriggeredSendStatus;
                                // from name & email are set in the senderProfile, not in the triggeredSend
                                // triggeredSend.fromName = linkedTS.FromName;
                                // triggeredSend.fromAddress = linkedTS.FromAddress;

                                // List
                                if (linkedTS.List?.ID) {
                                    triggeredSend.publicationListId = linkedTS.List.ID;
                                } else if (linkedTS.r__list_PathName) {
                                    delete triggeredSend.publicationListId;
                                    triggeredSend.r__list_PathName = {
                                        publicationList: linkedTS.r__list_PathName,
                                    };
                                }
                                if (linkedTS.SenderProfile?.CustomerKey) {
                                    try {
                                        const spKey = cache.searchForField(
                                            'senderProfile',
                                            linkedTS.SenderProfile.ObjectID,
                                            'ObjectID',
                                            'CustomerKey'
                                        );
                                        triggeredSend.r__senderProfile_key = spKey;
                                        delete triggeredSend.senderProfileId;
                                    } catch (ex) {
                                        Util.logger.warn(
                                            ` - triggeredSend ${linkedTS.CustomerKey}: ${ex.message} (senderProfile key ${linkedTS.SenderProfile.CustomerKey})`
                                        );
                                    }
                                } else if (linkedTS.r__senderProfile_key) {
                                    triggeredSend.r__senderProfile_key =
                                        linkedTS.r__senderProfile_key;
                                }
                                // send classification
                                if (linkedTS.SendClassification?.CustomerKey) {
                                    try {
                                        const scKey = cache.searchForField(
                                            'sendClassification',
                                            linkedTS.SendClassification.ObjectID,
                                            'ObjectID',
                                            'CustomerKey'
                                        );
                                        triggeredSend.r__sendClassification_key = scKey;
                                        delete triggeredSend.sendClassificationId;
                                    } catch (ex) {
                                        Util.logger.warn(
                                            ` - triggeredSend ${linkedTS.CustomerKey}: ${ex.message} (sendClassification key ${linkedTS.SendClassification.CustomerKey})`
                                        );
                                    }
                                } else if (linkedTS.r__sendClassification_key) {
                                    triggeredSend.r__sendClassification_key =
                                        linkedTS.r__sendClassification_key;
                                }
                                if (linkedTS.c__priority) {
                                    delete triggeredSend.priority;
                                    triggeredSend.c__priority = linkedTS.c__priority;
                                }
                                if (linkedTS.Email?.ID) {
                                    triggeredSend.emailId = linkedTS.Email.ID;
                                } else if (linkedTS.r__asset_key) {
                                    delete triggeredSend.emailId;
                                    triggeredSend.r__asset_name_readOnly =
                                        linkedTS.r__asset_name_readOnly;
                                    triggeredSend.r__asset_key = linkedTS.r__asset_key;
                                }
                            }
                        } else if (triggeredSend.id) {
                            // triggeredSendKey is not always set but id is
                            const tsKey = cache.searchForField(
                                'triggeredSend',
                                triggeredSend.id,
                                'ObjectID',
                                'CustomerKey'
                            );
                            if (triggeredSend.key != tsKey) {
                                Util.logger.debug(
                                    `key not matching id. Overwriting '${triggeredSend.key}' with the correct key '${tsKey}'.`
                                );
                                triggeredSend.key = tsKey;
                            }
                            triggeredSend.r__triggeredSend_key = triggeredSend.key;
                            delete triggeredSend.key;
                            delete triggeredSend.id;
                        } else if (triggeredSend.key) {
                            // very rare case but it's been seen that no id was saved
                            Util.logger.debug(
                                `key found on triggeredSend but no id present on journey activity. Checking key directly...`
                            );
                            triggeredSend.r__triggeredSend_key = cache.searchForField(
                                'triggeredSend',
                                triggeredSend.key,
                                'CustomerKey',
                                'CustomerKey'
                            );
                            delete triggeredSend.key;
                        }

                        if (typeof triggeredSend.ccEmail === 'string') {
                            triggeredSend.ccEmail = triggeredSend.ccEmail
                                .split(';')
                                .filter((el) => el !== '');
                        }
                        if (typeof triggeredSend.bccEmail === 'string') {
                            triggeredSend.bccEmail = triggeredSend.bccEmail
                                .split(';')
                                .filter((el) => el !== '');
                        }

                        // List (optional)
                        triggeredSend.r__list_PathName ||= {};
                        if (triggeredSend.publicationListId) {
                            try {
                                triggeredSend.r__list_PathName.publicationList =
                                    cache.getListPathName(triggeredSend.publicationListId, 'ID');
                                delete triggeredSend.publicationListId;
                            } catch (ex) {
                                Util.logger.warn(
                                    ` - ${this.definition.typeName} '${metadata.name}'/'${metadata.key}': ${ex.message}`
                                );
                                // save this TSD because it could be fixed by the user
                            }
                        }
                        if (
                            triggeredSend.suppressionLists &&
                            Array.isArray(triggeredSend.suppressionLists) &&
                            triggeredSend.suppressionLists.length
                        ) {
                            triggeredSend.r__list_PathName.suppressionLists =
                                triggeredSend.suppressionLists.map((sList) => {
                                    try {
                                        return cache.getListPathName(sList.id, 'ID');
                                    } catch (ex) {
                                        Util.logger.warn(
                                            ` - ${this.definition.typeName} '${metadata.name}'/'${metadata.key}': ${ex.message}`
                                        );
                                        // save this TSD because it could be fixed by the user
                                    }
                                });
                            delete triggeredSend.suppressionLists;
                        }
                        if (!Object.keys(triggeredSend.r__list_PathName).length) {
                            // in case we found no linked lists, remove this empty shell
                            delete triggeredSend.r__list_PathName;
                        }

                        // DataExtension (optional)
                        triggeredSend.r__dataExtension_key = {};
                        if (
                            triggeredSend.domainExclusions &&
                            Array.isArray(triggeredSend.domainExclusions) &&
                            triggeredSend.domainExclusions.length
                        ) {
                            let errors = 0;
                            triggeredSend.r__dataExtension_key.domainExclusions =
                                triggeredSend.domainExclusions.map((de) => {
                                    try {
                                        return cache.searchForField(
                                            'dataExtension',
                                            de.id,
                                            'ObjectID',
                                            'CustomerKey'
                                        );
                                    } catch (ex) {
                                        errors++;
                                        Util.logger.warn(
                                            ` - ${this.definition.typeName} '${metadata.name}'/'${metadata.key}': ${ex.message}`
                                        );
                                        // save this TSD because it could be fixed by the user
                                    }
                                });
                            if (!errors) {
                                delete triggeredSend.domainExclusions; // array with id & name of DE
                            }
                        }
                        if (!Object.keys(triggeredSend.r__dataExtension_key).length) {
                            // in case we found no linked dataExtensions, remove this empty shell
                            delete triggeredSend.r__dataExtension_key;
                        }

                        // sender profile
                        if (triggeredSend.senderProfileId) {
                            try {
                                triggeredSend.r__senderProfile_key = cache.searchForField(
                                    'senderProfile',
                                    triggeredSend.senderProfileId,
                                    'ObjectID',
                                    'CustomerKey'
                                );
                                delete triggeredSend.senderProfileId;
                            } catch (ex) {
                                Util.logger.warn(
                                    ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                        metadata[this.definition.keyField]
                                    }): ${ex.message}`
                                );
                            }
                        }
                        // send classification
                        if (triggeredSend.sendClassificationId) {
                            try {
                                triggeredSend.r__sendClassification_key = cache.searchForField(
                                    'sendClassification',
                                    triggeredSend.sendClassificationId,
                                    'ObjectID',
                                    'CustomerKey'
                                );
                                delete triggeredSend.sendClassificationId;
                            } catch (ex) {
                                Util.logger.warn(
                                    ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                        metadata[this.definition.keyField]
                                    }): ${ex.message}`
                                );
                            }
                        }
                        // delivery profile
                        if (triggeredSend.deliveryProfileId) {
                            try {
                                triggeredSend.r__deliveryProfile_key = cache.searchForField(
                                    'deliveryProfile',
                                    triggeredSend.deliveryProfileId,
                                    'ObjectID',
                                    'key'
                                );
                                delete triggeredSend.deliveryProfileId;
                            } catch {
                                Util.logger.warn(
                                    ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                        metadata[this.definition.keyField]
                                    }): Dependent deliveryProfile was not found. Please note that this can only be resolved if you have at least ONE Send Classification set up on the target BU that uses this Delivery Profile.`
                                );
                            }
                        }
                        // message priority
                        if (triggeredSend.priority) {
                            triggeredSend.c__priority = Util.inverseGet(
                                this.definition.priorityMapping,
                                triggeredSend.priority
                            );
                            delete triggeredSend.priority;
                        }
                        // email
                        if (triggeredSend.emailId) {
                            try {
                                // content builder
                                triggeredSend.r__asset_name_readOnly = cache.searchForField(
                                    'asset',
                                    triggeredSend.emailId,
                                    'legacyData.legacyId',
                                    'name'
                                );
                                triggeredSend.r__asset_key = cache.searchForField(
                                    'asset',
                                    triggeredSend.emailId,
                                    'legacyData.legacyId',
                                    'customerKey'
                                );
                                delete triggeredSend.emailId;
                            } catch {
                                try {
                                    // classic
                                    triggeredSend.r__email_name = cache.searchForField(
                                        'email',
                                        triggeredSend.emailId,
                                        'ID',
                                        'Name'
                                    );
                                    delete triggeredSend.emailId;
                                } catch {
                                    const msg = ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                        metadata[this.definition.keyField]
                                    }): Could not find email with ID ${triggeredSend.emailId} in Classic nor in Content Builder.`;
                                    Util.logger.warn(
                                        metadata.status === 'Published' ? msg : Util.getGrayMsg(msg)
                                    );
                                }
                            }
                        }

                        // sort attributes of triggeredSend alphabetically to allow for easier pull request reviews
                        configurationArguments.triggeredSend =
                            Util.sortObjectAttributes(triggeredSend);
                    }
                    break;
                }
                case 'SMSSYNC': {
                    const configurationArguments = activity.configurationArguments;
                    if (configurationArguments) {
                        // mobileMessage
                        try {
                            if (configurationArguments.messageId) {
                                configurationArguments.r__mobileMessage_key = cache.searchForField(
                                    'mobileMessage',
                                    configurationArguments.messageId,
                                    'id',
                                    'id'
                                );
                                delete configurationArguments.messageId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }
                        // mobileKeyword
                        configurationArguments.r__mobileKeyword_key = {};
                        try {
                            if (configurationArguments.keywordId) {
                                configurationArguments.r__mobileKeyword_key.current =
                                    cache.searchForField(
                                        'mobileKeyword',
                                        configurationArguments.keywordId,
                                        'id',
                                        'c__codeKeyword'
                                    );
                                delete configurationArguments.keywordId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }
                        try {
                            if (configurationArguments.nextKeywordId) {
                                configurationArguments.r__mobileKeyword_key.next =
                                    cache.searchForField(
                                        'mobileKeyword',
                                        configurationArguments.nextKeywordId,
                                        'id',
                                        'c__codeKeyword'
                                    );
                                delete configurationArguments.nextKeywordId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }
                        if (!Object.keys(configurationArguments.r__mobileKeyword_key).length) {
                            // in case we found no linked dataExtensions, remove this empty shell
                            delete configurationArguments.r__mobileKeyword_key;
                        }
                        // mobileCode
                        try {
                            if (configurationArguments.codeId) {
                                configurationArguments.r__mobileCode_key = cache.searchForField(
                                    'mobileCode',
                                    configurationArguments.codeId,
                                    'id',
                                    'code'
                                );
                                delete configurationArguments.codeId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }

                        try {
                            // asset-asset: jsonmessage
                            if (configurationArguments.assetId) {
                                configurationArguments.r__asset_name_readOnly =
                                    cache.searchForField(
                                        'asset',
                                        configurationArguments.assetId,
                                        'id',
                                        'name'
                                    );

                                configurationArguments.r__asset_key = cache.searchForField(
                                    'asset',
                                    configurationArguments.assetId,
                                    'id',
                                    'customerKey'
                                );
                                delete configurationArguments.assetId;
                            }
                        } catch (ex) {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${
                                    metadata[this.definition.keyField]
                                }) activity-key=${activity.key}: ${ex.message}`
                            );
                        }

                        // applicationExtensionId always equal "00000000-0000-0000-0000-000000000000"
                        delete configurationArguments.applicationExtensionId;
                    }
                    break;
                }
            }
        }

        // apply sorting by activity key to work around the API shuffling activities around
        metadata.activities = metadata.activities.sort((a, b) => a.key.localeCompare(b.key));
    }

    /**
     * prepares a TSD for deployment
     * ! BETA RELEASE of journey support (v4.3.0); it so far only resolves a limited amount of dependencies and will likely break during cross-BU deployments!
     *
     * @param {MetadataTypeItem} metadata of a single TSD
     * @returns {Promise.<MetadataTypeItem>} metadata object
     */
    static async preDeployTasks(metadata) {
        if (metadata.status !== 'Draft') {
            metadata.status = 'Draft';
        }

        // folder
        super.setFolderId(metadata);

        switch (metadata.definitionType) {
            case 'Quicksend':
            case 'Multistep': {
                // Multi-Step Journey
                // ~~~ TRIGGERS ~~~~

                // event / definitionType==='Multistep' && channel==='' && triggers[].type === 'EmailAudience'|'APIEvent'

                if (metadata.triggers?.length > 0) {
                    const search = ['arguments', 'metaData'];
                    for (const area of search) {
                        const config = metadata.triggers[0][area];
                        if (config?.r__event_key) {
                            // trigger found; there can only be one entry in this array
                            config.eventDefinitionId = cache.searchForField(
                                'event',
                                config.r__event_key,
                                'eventDefinitionKey',
                                'id'
                            );
                            config.eventDefinitionKey = config.r__event_key;
                            delete config.r__event_key;
                        }
                        if (config?.r__dataExtension_key) {
                            // trigger found; there can only be one entry in this array
                            config.dataExtensionId = cache.searchForField(
                                'dataExtension',
                                config.r__dataExtension_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            delete config.r__dataExtension_key;
                        }
                    }
                    const warnings = await Event.preDeployTasks_SalesforceEntryEvents(
                        metadata.triggers[0].type,
                        metadata.triggers[0].configurationArguments
                    );
                    if (warnings) {
                        Util.logger.warn(
                            ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${metadata[this.definition.keyField]}): ${warnings}`
                        );
                    }
                }

                // transactionalEmail / definitionType==='Transactional' && channel==='email' && triggers[].type === 'transactional-api'

                // ~~~ ACTIVITIES ~~~~

                this._preDeployTasks_activities(metadata);

                break;
            }
            case 'Transactional': {
                const cachedVersion = cache.getByKey('journey', metadata.key);
                if (cachedVersion.status === 'Published') {
                    throw new Error(`Cannot update transactional-send journey in Published status`);
                }

                // Transactional Send Journey
                // ~~~ TRIGGERS ~~~~
                // ! journeys so far transactional EMAIL messages. SMS and Push do not create their own journey.
                // ! transactional (email) journeys only have a dummy trigger without real content.

                // transactionalEmail / definitionType==='Transactional' && channel==='email' && triggers[].type === 'transactional-api'
                // --> nothing to do here

                // ~~~ ACTIVITIES ~~~~
                // ! transactional (email) journeys only have one activity (type=EMAILV2) which links back to the transactionalEmail ()
                switch (metadata.channel) {
                    case 'email': {
                        const activity = metadata.activities[0];
                        if (activity.configurationArguments?.r__transactionalEmail_key) {
                            // trigger found; there can only be one entry in this array
                            try {
                                activity.configurationArguments.triggeredSendId =
                                    cache.searchForField(
                                        'transactionalEmail',
                                        activity.configurationArguments.r__transactionalEmail_key,
                                        'definitionKey',
                                        'definitionId'
                                    );
                                activity.configurationArguments.triggeredSendKey =
                                    activity.configurationArguments.r__transactionalEmail_key;
                            } catch (ex) {
                                const isCreateMode = !cachedVersion;
                                if (
                                    (isCreateMode && !Util.OPTIONS.publish) ||
                                    (!isCreateMode && cachedVersion.status === 'Draft')
                                ) {
                                    // no need to add a log entry if the publish-option was provided
                                    Util.logger.info(
                                        ` - ${this.definition.type} ${metadata[this.definition.nameField]} (${
                                            metadata[this.definition.keyField]
                                        }): To activate this transactional journey (and create the associated transactionalEmail record), please run 'mcdev publish ${this.buObject.credential}/${this.buObject.businessUnit} -m journey:"${metadata.key}" ' or click on "Activate" in the GUI.`
                                    );
                                } else if (!isCreateMode) {
                                    // block deployment if we are in update mode
                                    throw ex;
                                }
                            }
                            if (activity.metaData?.highThroughput) {
                                // this is crucial for pinging the /interaction/v1/interactions/transactional/create endpoint that creates the transactionalEmail
                                activity.metaData.highThroughput.definitionKey =
                                    activity.configurationArguments.r__transactionalEmail_key;
                            }
                            delete activity.configurationArguments.r__transactionalEmail_key;
                        }

                        if (activity.metaData?.highThroughput?.r__dataExtension_key) {
                            activity.metaData.highThroughput.dataExtensionId = cache.searchForField(
                                'dataExtension',
                                activity.metaData.highThroughput.r__dataExtension_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            delete activity.metaData.highThroughput.r__dataExtension_key;
                        }

                        this._preDeployTasks_activities(metadata);

                        break;
                    }
                    default: {
                        // it is expected that we'll see 'sms' and 'push' here in the future
                        throw new Error(
                            `channel ${
                                metadata.channel
                            } is not supported yet. Please open a ticket at https://github.com/Accenture/sfmc-devtools/issues/new/choose to request it`
                        );
                    }
                }

                break;
            }
            default: {
                throw new Error(
                    `definitionType ${
                        metadata.definitionType
                    } is not supported yet. Please open a ticket at https://github.com/Accenture/sfmc-devtools/issues/new/choose to request it`
                );
            }
        }
        return metadata;
    }

    /**
     * helper for {@link Journey.preDeployTasks}
     *
     * @private
     * @param {MetadataTypeItem} metadata a single item
     */
    static _preDeployTasks_activities(metadata) {
        for (const activity of metadata.activities) {
            switch (activity.type) {
                case 'EMAILV2': {
                    // triggeredSend + email+asset
                    const configurationArguments = activity.configurationArguments;
                    if (configurationArguments?.r__triggeredSend_key) {
                        // triggeredSendKey is not always set but triggeredSendId is
                        try {
                            configurationArguments.triggeredSendId = cache.searchForField(
                                'triggeredSend',
                                configurationArguments.r__triggeredSend_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            configurationArguments.triggeredSendKey =
                                configurationArguments.r__triggeredSend_key;
                            delete configurationArguments.r__triggeredSend_key;
                        } catch {
                            Util.logger.warn(
                                ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${metadata[this.definition.keyField]}): Could not find triggeredSend with key ${configurationArguments.r__triggeredSend_key}. Attempting to let the API auto-create it`
                            );
                        }
                    }
                    const triggeredSend = configurationArguments?.triggeredSend;
                    if (triggeredSend) {
                        // triggeredSend key
                        if (
                            !configurationArguments.r__triggeredSend_key &&
                            triggeredSend.r__triggeredSend_key
                        ) {
                            try {
                                // key is not always set but id is
                                triggeredSend.id = cache.searchForField(
                                    'triggeredSend',
                                    triggeredSend.r__triggeredSend_key,
                                    'CustomerKey',
                                    'ObjectID'
                                );
                                triggeredSend.key = triggeredSend.r__triggeredSend_key;
                            } catch {
                                Util.logger.warn(
                                    ` - ${this.definition.type} '${metadata[this.definition.nameField]}' (${metadata[this.definition.keyField]}): Could not find triggeredSend with key ${triggeredSend.r__triggeredSend_key}. Attempting to let the API auto-create it`
                                );
                            }
                            delete triggeredSend.r__triggeredSend_key;
                        }

                        if (triggeredSend.ccEmail !== undefined) {
                            triggeredSend.ccEmail = Array.isArray(triggeredSend.ccEmail)
                                ? triggeredSend.ccEmail?.join(';')
                                : triggeredSend.ccEmail;
                        }
                        if (triggeredSend.bccEmail !== undefined) {
                            triggeredSend.bccEmail = Array.isArray(triggeredSend.bccEmail)
                                ? triggeredSend.bccEmail?.join(';')
                                : triggeredSend.bccEmail;
                        }

                        // List (optional)
                        if (triggeredSend.r__list_PathName) {
                            if (triggeredSend.r__list_PathName.publicationList) {
                                triggeredSend.publicationListId = cache.getListObjectId(
                                    triggeredSend.r__list_PathName.publicationList,
                                    'ID'
                                );
                            }
                            if (triggeredSend.r__list_PathName.suppressionLists?.length) {
                                triggeredSend.suppressionLists =
                                    triggeredSend.r__list_PathName.suppressionLists.map(
                                        (listPathName) => {
                                            const id = cache.getListObjectId(listPathName, 'ID');
                                            const name = cache.getListObjectId(
                                                listPathName,
                                                'ListName'
                                            );
                                            return { id, name };
                                        }
                                    );
                            }
                            delete triggeredSend.r__list_PathName;
                        }
                        // DataExtension (optional)
                        if (triggeredSend.r__dataExtension_key?.length) {
                            triggeredSend.domainExclusions = triggeredSend.r__dataExtension_key.map(
                                (key) => {
                                    const id = cache.searchForField(
                                        'dataExtension',
                                        key,
                                        'CustomerKey',
                                        'ObjectID'
                                    );
                                    const name = cache.searchForField(
                                        'dataExtension',
                                        key,
                                        'CustomerKey',
                                        'Name'
                                    );
                                    return { id, name };
                                }
                            );
                        }

                        // sender profile
                        if (triggeredSend.r__senderProfile_key) {
                            triggeredSend.senderProfileId = cache.searchForField(
                                'senderProfile',
                                triggeredSend.r__senderProfile_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            delete triggeredSend.r__senderProfile_key;
                        }
                        // send classification
                        if (triggeredSend.r__sendClassification_key) {
                            triggeredSend.sendClassificationId = cache.searchForField(
                                'sendClassification',
                                triggeredSend.r__sendClassification_key,
                                'CustomerKey',
                                'ObjectID'
                            );
                            delete triggeredSend.r__sendClassification_key;
                        }
                        // delivery profile
                        if (triggeredSend.r__deliveryProfile_key) {
                            // remove it because we cannot resolve it and it should be set by selecting the sendClassification
                            try {
                                triggeredSend.deliveryProfileId = cache.searchForField(
                                    'deliveryProfile',
                                    triggeredSend.r__deliveryProfile_key,
                                    'key',
                                    'ObjectID'
                                );
                                delete triggeredSend.r__deliveryProfile_key;
                            } catch (ex) {
                                Util.logger.error(
                                    `Could not find the ID for Delivery Profile '${triggeredSend.r__deliveryProfile_key}'. Please note that this can only be resolved if you have at least ONE Send Classification set up on the target BU that uses a Delivery Profile with this key.`
                                );
                                throw ex;
                            }
                        }

                        // message priority
                        if (triggeredSend.c__priority) {
                            triggeredSend.priority =
                                this.definition.priorityMapping[triggeredSend.c__priority];
                            delete triggeredSend.c__priority;
                        }

                        // email
                        if (triggeredSend.r__asset_key) {
                            triggeredSend.emailId = cache.searchForField(
                                'asset',
                                triggeredSend.r__asset_key,
                                'customerKey',
                                'legacyData.legacyId'
                            );
                            delete triggeredSend.r__asset_key;
                            delete triggeredSend.r__asset_name_readOnly;
                        } else if (triggeredSend.r__email_name) {
                            // classic
                            triggeredSend.emailId = cache.searchForField(
                                'email',
                                triggeredSend.r__email_name,
                                'Name',
                                'ID'
                            );
                            delete triggeredSend.r__email_name;
                        }
                    }

                    break;
                }
                case 'SMSSYNC': {
                    const configurationArguments = activity.configurationArguments;
                    if (configurationArguments) {
                        // mobileMessage
                        if (configurationArguments.r__mobileMessage_key) {
                            configurationArguments.messageId = cache.searchForField(
                                'mobileMessage',
                                configurationArguments.r__mobileMessage_key,
                                'id',
                                'id'
                            );
                            delete configurationArguments.r__mobileMessage_key;
                        }
                        // mobileKeyword
                        if (configurationArguments.r__mobileKeyword_key?.current) {
                            configurationArguments.keywordId = cache.searchForField(
                                'mobileKeyword',
                                configurationArguments.r__mobileKeyword_key.current,
                                'c__codeKeyword',
                                'id'
                            );
                        }
                        if (configurationArguments.r__mobileKeyword_key?.next) {
                            configurationArguments.nextKeywordId = cache.searchForField(
                                'mobileKeyword',
                                configurationArguments.r__mobileKeyword_key.next,
                                'c__codeKeyword',
                                'id'
                            );
                        }
                        delete configurationArguments.r__mobileKeyword_key;
                        // mobileCode
                        if (configurationArguments.r__mobileCode_key) {
                            configurationArguments.codeId = cache.searchForField(
                                'mobileCode',
                                configurationArguments.r__mobileCode_key,
                                'code',
                                'id'
                            );
                            delete configurationArguments.r__mobileCode_key;
                        }
                        // asset-asset: jsonmessage
                        if (configurationArguments.r__asset_key) {
                            configurationArguments.assetId = cache.searchForField(
                                'asset',
                                configurationArguments.r__asset_key,
                                'customerKey',
                                'id'
                            );
                            delete configurationArguments.r__asset_key;
                            delete configurationArguments.r__asset_name_readOnly;
                        }

                        // applicationExtensionId always equal "00000000-0000-0000-0000-000000000000"
                        configurationArguments.applicationExtensionId =
                            '00000000-0000-0000-0000-000000000000';
                    }

                    break;
                }
            }
        }
    }

    /**
     * helper for {@link MetadataType.upsert}
     *
     * @param {MetadataTypeMap} metadataMap list of metadata
     * @param {string} metadataKey key of item we are looking at
     * @param {boolean} hasError error flag from previous code
     * @param {MetadataTypeItemDiff[]} metadataToUpdate list of items to update
     * @param {MetadataTypeItem[]} metadataToCreate list of items to create
     * @returns {Promise.<'create'|'update'|'skip'>} action to take
     */
    static async createOrUpdate(
        metadataMap,
        metadataKey,
        hasError,
        metadataToUpdate,
        metadataToCreate
    ) {
        const action = await super.createOrUpdate(
            metadataMap,
            metadataKey,
            hasError,
            metadataToUpdate,
            metadataToCreate
        );
        if (action === 'update') {
            const normalizedKey = File.reverseFilterIllegalFilenames(
                metadataMap[metadataKey][this.definition.keyField]
            );
            const cachedVersion = cache.getByKey(this.definition.type, normalizedKey);
            if (cachedVersion) {
                if (
                    cachedVersion.status === 'Draft' ||
                    cachedVersion.definitionType !== 'Multistep'
                ) {
                    // we can update journeys either if there is a draft version or if the type is not multistep. transactional and quicksend journeys do not have versions.
                    // add version to ensure we update the correct one
                    metadataMap[metadataKey].version = cachedVersion.version;
                    // update modifiedDate field to bypass API-error "Another user recently modified this journey. Refresh to edit the latest version."
                    metadataMap[metadataKey].modifiedDate = cachedVersion.modifiedDate;
                } else {
                    // remove last entry from metadataToUpdate again
                    metadataToUpdate.pop();
                    Util.logger.info(
                        Util.getGrayMsg(
                            ` - Found ${this.definition.type} ${
                                metadataMap[metadataKey][this.definition.nameField]
                            } (${
                                metadataMap[metadataKey][this.definition.keyField]
                            }) on BU, but it is not in Draft status. Will create new version.`
                        )
                    );
                    metadataToCreate.push(metadataMap[metadataKey]);
                    return 'create';
                }
            }
        }
        return action;
    }

    /**
     *
     * @param {MetadataTypeItem} item single metadata item
     * @param {string} [_] parameter not used
     * @param {Set.<string>} [findAssetKeys] list of keys that were found referenced via ContentBlockByX; if set, method only gets keys and runs no updates
     * @returns {Promise.<MetadataTypeItem>} key of the item that was updated
     */
    static async replaceCbReference(item, _, findAssetKeys) {
        const parentName = `${this.definition.type} ${item[this.definition.keyField]}`;
        let changes = false;
        let error;

        // *** type specific logic **

        // find email activities with triggeredSend configurationArguments
        const activities = item.activities.filter((activity) => activity.type === 'EMAILV2');
        if (!activities) {
            const ex = new Error('No changes made to the code.');
            // @ts-expect-error custom error object
            ex.code = 200;
            throw ex;
        }

        for (const activity of activities) {
            if (activity.arguments) {
                try {
                    activity.arguments.emailSubjectDataBound = ReplaceCbReference.replaceReference(
                        activity.arguments.emailSubjectDataBound,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
            }
            const triggeredSend = activity.configurationArguments?.triggeredSend;
            if (triggeredSend) {
                // the following is very similar but not equal to the variables in TriggeredSend.js
                if (triggeredSend.bccEmail !== undefined) {
                    try {
                        let bccEmail = Array.isArray(triggeredSend.bccEmail)
                            ? triggeredSend.bccEmail.join(';')
                            : triggeredSend.bccEmail;
                        bccEmail = ReplaceCbReference.replaceReference(
                            bccEmail,
                            parentName,
                            findAssetKeys
                        );
                        triggeredSend.bccEmail = bccEmail.split(';').filter((el) => el !== '');
                        changes = true;
                    } catch (ex) {
                        if (ex.code !== 200) {
                            error = ex;
                        }
                    }
                }
                if (triggeredSend.ccEmail !== undefined) {
                    try {
                        let ccEmail = Array.isArray(triggeredSend.ccEmail)
                            ? triggeredSend.ccEmail?.join(';')
                            : triggeredSend.ccEmail;
                        ccEmail = ReplaceCbReference.replaceReference(
                            ccEmail,
                            parentName,
                            findAssetKeys
                        );
                        triggeredSend.ccEmail = ccEmail.split(';').filter((el) => el !== '');
                        changes = true;
                    } catch (ex) {
                        if (ex.code !== 200) {
                            error = ex;
                        }
                    }
                }
                try {
                    triggeredSend.dynamicEmailSubject = ReplaceCbReference.replaceReference(
                        triggeredSend.dynamicEmailSubject,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
                try {
                    triggeredSend.emailSubject = ReplaceCbReference.replaceReference(
                        triggeredSend.emailSubject,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
                try {
                    triggeredSend.preHeader = ReplaceCbReference.replaceReference(
                        triggeredSend.preHeader,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
                try {
                    triggeredSend.exclusionFilter = ReplaceCbReference.replaceReference(
                        triggeredSend.exclusionFilter,
                        parentName,
                        findAssetKeys
                    );
                    changes = true;
                } catch (ex) {
                    if (ex.code !== 200) {
                        error = ex;
                    }
                }
            }
        }

        if (error) {
            throw error;
        }

        if (!changes) {
            const ex = new Error('No changes made to the code.');
            // @ts-expect-error custom error object
            ex.code = 200;
            throw ex;
        }

        // *** finish ***
        // replaceReference will throw an error if nothing was updated which will end execution here
        // no error means we have a new item to deploy and need to update the item in our retrieve folder
        return item;
    }

    /**
     * Gets executed after deployment of metadata type
     *
     * @param {MetadataTypeMap} upsertResults metadata mapped by their keyField as returned by update/create
     */
    static async postDeployTasks(upsertResults) {
        if (!upsertResults || !Object.keys(upsertResults).length) {
            // nothing to do. skip here to avoid unnecessary logs / api calls
            return;
        }
        let postDeployFlags = 0;
        if (Util.OPTIONS.publish) {
            postDeployFlags++;
        }
        if (Util.OPTIONS.validate) {
            postDeployFlags++;
        }
        if (postDeployFlags > 1) {
            Util.logger.warn(
                `Please provide only one of the following options (--publish, --validate). Flags are processed in this order and only the first one found is executed.`
            );
        }

        if (Util.OPTIONS.publish) {
            Util.logger.info(`Publishing: ${this.definition.type}`);
            // pubslih
            const idArr = Object.values(upsertResults).map(
                (item) => 'id:' + item.id + '/' + item.version
            );
            await this.publish(idArr, upsertResults);
        } else if (Util.OPTIONS.validate) {
            Util.logger.info(`Validating: ${this.definition.type}`);
            // pubslih
            const idArr = Object.values(upsertResults).map(
                (item) => 'id:' + item.id + '/' + item.version
            );
            await this.validate(idArr);
        }
    }

    /**
     * a function to publish the journey via API
     *
     * @param {string[]} keyArr keys or ids of the metadata
     * @param {MetadataTypeMap} [upsertResults] metadata mapped by their keyField as returned by update/create
     * @returns {Promise.<string[]>} Returns list of updated keys/ids that were published. Success could only be seen with a delay in the UI because the publish-endpoint is async
     */
    static async publish(keyArr, upsertResults) {
        const resultsTransactional = [];
        // works only with objectId
        const statusUrls = [];
        const executedKeyArr = [];
        const refreshTransactionalKeys = [];
        const metadataMap = upsertResults
            ? { metadata: upsertResults }
            : await this.retrieveForCache();
        const spinnerTransactional = yoctoSpinner({
            text: `Publishing transactional journey…`,
        });

        for (let key of keyArr) {
            let objectId;
            let version;
            let journey;
            if (!key) {
                continue;
            }
            if (key.startsWith('%23')) {
                // if the key started with %23 assume an ID was copied from the URL but the user forgot to prefix it with id:
                // correct the format
                key = 'id:' + key.slice(3);
            }
            if (key.startsWith('id:')) {
                // ! allow selecting journeys by ID because that's what users see in the URL
                // remove id
                objectId = key.slice(3);
                if (objectId.startsWith('%23')) {
                    // in the journey URL the Id is prefixed with an HTML-encoded "#" which could accidentally be copied by users
                    // despite the slicing above, this still needs testing here because users might have prefixed the ID with id: but did not know to remove the #23
                    objectId = objectId.slice(3);
                    // correct the format to ensure we show sth readable in the "Downloaded" log
                    // objectId =  objectId;
                    // update this here to show it in the log
                    key = 'id:' + objectId;
                }
                if (objectId.includes('/')) {
                    version = objectId.split('/')[1];
                    // in the journey URL the version is appended after the ID, separated by a forward-slash. Needs to be removed from the ID for caching as we always aim to retrieve the latest version only
                    objectId = objectId.split('/')[0];
                } else {
                    // if we didn't find a version we need to cache this from the API after all
                    if (key.includes('/')) {
                        // in the journey URL the version is appended after the ID, separated by a forward-slash. Needs to be removed from the key for caching as we always aim to retrieve the latest version only
                        key = key.split('/')[0];
                    }
                }
                journey = Object.values(metadataMap.metadata).find((el) => el.id === objectId);
                if (!journey) {
                    Util.logger.info(
                        ` ☇ skipping ${this.definition.type} ${key}: not found on server (1)`
                    );
                    continue;
                }
            } else {
                // key assumed
                journey = metadataMap.metadata[key];
            }

            if (!journey) {
                Util.logger.info(
                    ` ☇ skipping ${this.definition.type} ${key}: not found on server (2)`
                );
                continue;
            }
            if (!version) {
                version = journey.version;
            }
            if (journey.status === 'Published') {
                // api would return error code 30000 and ask to open a support case when in fact we simply already have a transactionalEmail created based on this status
                if (journey.definitionType === 'Transactional') {
                    Util.logger.info(
                        ` ☇ skipping ${this.definition.type} ${
                            journey[this.definition.nameField]
                        } (${journey[this.definition.keyField]}): already published. Queueing for refresh.`
                    );
                    refreshTransactionalKeys.push(journey.key);
                } else {
                    Util.logger.warn(
                        ` ☇ skipping ${this.definition.type} ${
                            journey[this.definition.nameField]
                        } (${journey[this.definition.keyField]}): already published.`
                    );
                }
                continue;
            }

            switch (journey.definitionType) {
                case 'Transactional': {
                    resultsTransactional.push(
                        (async () => {
                            spinnerTransactional.start();
                            try {
                                const response = await this.client.rest.post(
                                    `/interaction/v1/interactions/transactional/create`,
                                    { definitionId: journey.id }
                                );
                                if (response.errors?.length) {
                                    throw new Error(JSON.stringify(response));
                                } else {
                                    spinnerTransactional.stop();
                                    Util.logger.info(
                                        ` - published ${this.definition.type}: ${
                                            journey[this.definition.nameField]
                                        } (${journey[this.definition.keyField]}) by creating the matching transactionalEmail`
                                    );
                                    statusUrls.push({ key, statusUrl: response.statusUrl });
                                }
                                spinnerTransactional.start();
                                return journey[this.definition.keyField];
                            } catch (ex) {
                                spinnerTransactional.stop();
                                if (
                                    ex.response.status === 400 &&
                                    ex.response?.data?.errors?.length === 1 &&
                                    ex.response?.data?.errors?.[0]?.errorCode === '121500'
                                ) {
                                    Util.logger.error(
                                        `Failed to publish ${
                                            journey[this.definition.nameField]
                                        } (${journey[this.definition.keyField]}): Make sure the Event Definition Key, Data Extension and E-Mail are saved to the journey`
                                    );
                                } else {
                                    Util.logger.error(
                                        `Failed to publish ${
                                            journey[this.definition.nameField]
                                        } (${journey[this.definition.keyField]}): ${ex.message}`
                                    );
                                    if (ex.response?.data?.errors?.length) {
                                        Util.logger.error(
                                            JSON.stringify(ex.response?.data?.errors, null, 2)
                                        );
                                    }
                                }
                                spinnerTransactional.start();
                            }
                        })()
                    );
                    break;
                }
                case 'Multistep': {
                    // SF Event, Api Event Journeys
                    // ! for SF-triggered journeys this cannot be asynchronous or it will cause a race-condition (see #1627 for details); the requests are accepted but then processed sequentually anyways, eliminating potential speed gains.
                    // It is unknown if the same would happen for API-event journeys but given that it's the same endpoint, lets not risk it and run this sequentially
                    let statusUrl;
                    try {
                        const response = await this.client.rest.post(
                            `/interaction/v1/interactions/publishAsync/${journey.id}?versionNumber=${version}`,
                            {}
                        ); // payload is empty for this request
                        if (response.statusUrl && response.statusId) {
                            Util.logger.info(
                                ` - ${this.definition.type} queued for publishing: ${journey[this.definition.keyField]}/${version} / ${journey[this.definition.nameField]}`
                            );
                            statusUrl = response.statusUrl;
                        } else {
                            throw new Error(response);
                        }
                        if (Util.OPTIONS.skipStatusCheck) {
                            Util.logger.warn(
                                ` - Skipping status check for publishing journey ${key} due to --skipStatusCheck flag`
                            );
                        }
                        if (!Util.OPTIONS.skipStatusCheck && statusUrl) {
                            const spinner = yoctoSpinner({
                                text: `Publishing journey…`,
                            }).start();

                            await Util.sleep(1000);
                            executedKeyArr.push(
                                await this._checkPublishStatus(
                                    statusUrl,
                                    journey[this.definition.keyField],
                                    journey[this.definition.nameField],
                                    spinner
                                )
                            );
                        } else {
                            // no guarantees if the journey was actually published
                            executedKeyArr.push(key);
                        }
                    } catch (ex) {
                        switch (ex.message) {
                            case 'Cannot publish interaction in Published status.': {
                                Util.logger.info(
                                    ` - ${this.definition.type} ${key}/${version} is already published.`
                                );

                                break;
                            }
                            case 'Cannot publish interaction in Stopped status.': {
                                Util.logger.warn(
                                    ` - ${this.definition.type} ${key}/${version} is stopped. Please create a new version and publish that.`
                                );

                                break;
                            }
                            case 'Cannot publish interaction in Paused status.': {
                                Util.logger.warn(
                                    ` - ${this.definition.type} ${key}/${version} is already published but currently paused. Run 'mcdev resume' instead.`
                                );

                                break;
                            }
                            default: {
                                Util.logger.error(
                                    `Failed to publish ${this.definition.type} ${key}: ${ex.message}`
                                );
                            }
                        }
                    }
                    break;
                }
                default: {
                    throw new Error(
                        `${this.definition.type} type ${journey.definitionType} not supported yet by publish method`
                    );
                }
            }
        } // for loop

        const publishedJourneyCounter = {
            multiStep: executedKeyArr.filter(Boolean).length,
            transactional: 0,
        };
        // Transactional Send Journeys
        if (resultsTransactional.length) {
            const transactionalKeyArr = (await Promise.all(resultsTransactional)).filter(Boolean);
            spinnerTransactional.stop();

            // if all publish actions failed, we don't need to re-retrieve anything here
            if (transactionalKeyArr.length) {
                executedKeyArr.push(...transactionalKeyArr);
                publishedJourneyCounter.transactional = transactionalKeyArr.length;
                // reset transactionalEmail cache to trigger re-caching it.
                cache.clearCache(this.buObject.mid, 'transactionalEmail');
            }
        }

        // reload published journeys including their events/transactionalEmails
        await this._reRetrieve(
            executedKeyArr,
            publishedJourneyCounter.transactional,
            publishedJourneyCounter.multiStep
        );

        Util.logger.info(
            `Published ${executedKeyArr.filter(Boolean).length} of ${keyArr.length} items`
        );

        if (refreshTransactionalKeys.length) {
            // in case we tried to publish a transactional journey that was already published we will instead run a refresh for those
            executedKeyArr.push(...(await this.refresh(refreshTransactionalKeys)));
        }
        return executedKeyArr.filter(Boolean);
    }

    /**
     *
     * @param {string[]} executedKeyArr list of journey keys
     * @param {number} transactionalCounter how many transactiona-send journeys did we expect to refresh
     * @param {number} multiStepCounter how many multi-step journeys did we expect to refresh
     * @returns {Promise.<void>} -
     */
    static async _reRetrieve(executedKeyArr, transactionalCounter, multiStepCounter) {
        if (!executedKeyArr.filter(Boolean).length) {
            return;
        }
        Util.logger.info('Re-retrieving published journeys');
        const retriever = new Retriever(this.properties, this.buObject);
        try {
            // we need to retrieve the updated journeys and all dependencies
            const updatedJourneyRetrieve = await retriever.retrieve(
                ['journey'],
                executedKeyArr.filter(Boolean)
            );

            /** @type {MetadataTypeItem[]} */
            const updatedJourneys =
                updatedJourneyRetrieve?.journey?.length > 1
                    ? Object.values(
                          updatedJourneyRetrieve?.journey.reduce(
                              (previousValue, currentValue) =>
                                  Object.assign(previousValue, currentValue),
                              {}
                          )
                      )
                    : Object.values(updatedJourneyRetrieve?.journey[0]);

            if (updatedJourneys) {
                // regardless of upsert vs publish-only mode, we need to retrieve the events/transactionalEmail and their dependencies
                const updatedEvents = [];
                const updatedTransactionalEmails = [];
                for (const journey of updatedJourneys) {
                    // multi-step journeys
                    updatedEvents.push(journey.triggers?.[0]?.metaData?.r__event_key);
                    // transactional-send journeys
                    updatedTransactionalEmails.push(
                        journey.activities?.[0]?.configurationArguments?.r__transactionalEmail_key
                    );
                }
                /** @type {TypeKeyCombo} */
                const eventTransEmailCombo = {};
                if (updatedEvents.filter(Boolean).length) {
                    eventTransEmailCombo.event = updatedEvents.filter(Boolean);
                } else if (multiStepCounter) {
                    Util.logger.error(`Could not find events for the published journeys`);
                }
                if (updatedTransactionalEmails.filter(Boolean).length) {
                    eventTransEmailCombo.transactionalEmail =
                        updatedTransactionalEmails.filter(Boolean);
                    Util.logger.info('Retrieving relevant transactionalEmails');
                } else if (transactionalCounter) {
                    Util.logger.error(
                        `Could not find transactional Emails for the published journeys`
                    );
                }

                const toBeRetrievedTypes = Object.keys(eventTransEmailCombo);
                if (toBeRetrievedTypes.length) {
                    Util.logger.info(
                        'Retrieving relevant ' +
                            toBeRetrievedTypes.map((item) => item + 's').join(', ')
                    );
                    await retriever.retrieve(toBeRetrievedTypes, eventTransEmailCombo);
                }
            }
        } catch (ex) {
            Util.logger.errorStack(ex, 'retrieve failed');
        }
    }

    /**
     * helper for {@link Journey.publish} and {@link Journey.validate}
     *
     * @param {string} statusUrl URL to check the status of the publish request
     * @param {string} key journey-key or id for log messages
     * @param {string} name journey-name for log messages
     * @param {import('yocto-spinner').Spinner} spinner reference to spinner to allow stopping it when done
     * @param {number} [tries] number of tries used to check the status
     * @returns {Promise.<string>} key of the item that was published successfully
     */
    static async _checkPublishStatus(statusUrl, key, name, spinner, tries = 1) {
        const action = statusUrl.includes('/validateStatus') ? 'validating' : 'publishing';
        try {
            const response = await this.client.rest.get(statusUrl);
            switch (response.status) {
                case 'ValidateCompleted':
                case 'PublishCompleted': {
                    spinner.stop();
                    const action = statusUrl.includes('/validateStatus')
                        ? 'validation successful -'
                        : 'published';

                    Util.logger.info(` - ${action} ${this.definition.type}: ${key} / ${name}`);
                    this._showPublishStatusDetails(response);
                    return key;
                }
                case 'ValidateInProcess':
                case 'PublishInProcess': {
                    Util.logger.debug(
                        ` - ${action} ${this.definition.type} still in progress: ${key} / ${name}`
                    );
                    if (tries < 50) {
                        await (tries < 10 ? Util.sleep(2000) : Util.sleep(5000));
                        return await this._checkPublishStatus(
                            statusUrl,
                            key,
                            name,
                            spinner,
                            tries + 1
                        );
                    } else {
                        return;
                    }
                }
                case 'Error': {
                    spinner.stop();
                    Util.logger.error(
                        ` - ${action} ${this.definition.type} failed: ${key} / ${name}`
                    );
                    this._showPublishStatusDetails(response);
                    return;
                }
                // No default
            }
        } catch (ex) {
            Util.logger.error(`Failed to check status of ${key}: ${ex.message}`);
        }
    }

    /**
     * helper for {@link Journey._checkPublishStatus}
     *
     * @param {{status:string, errors:Array, warnings:Array}} response publishStatus response
     */
    static _showPublishStatusDetails(response) {
        const types = { errors: 'Errors', warnings: 'Warnings' };
        const messages = { errors: [], warnings: [] };
        for (const type in types) {
            let counter = 1;
            if (response[type] && response[type].length) {
                messages[type].push(`   ${types[type]}:`);
                for (const msg of response[type]) {
                    messages[type].push(
                        `     #${counter++}`,
                        `     Code: ${msg.errorCode}`,
                        `     Details: ${msg.errorDetail.split(' EmailID: ').join('\n       EmailID: ').split(' Personalization error: ').join('\n       Personalization error: ')}`
                    );
                    if (msg.additionalInfo && Object.keys(msg.additionalInfo).length) {
                        messages[type].push(`     Additional Info:`);
                        for (const key in msg.additionalInfo) {
                            messages[type].push(`       ${key}: ${msg.additionalInfo[key]}`);
                        }
                    }
                    // add spacer line
                    messages[type].push('');
                }
            }
        }
        for (const msg of messages.errors) {
            Util.logger.error(msg);
        }
        for (const msg of messages.warnings) {
            Util.logger.warn(' ' + msg);
        }
    }

    /**
     * a function to validate the journey via API
     *
     * @param {string[]} keyArr keys or ids of the metadata
     * @returns {Promise.<string[]>} Returns list of updated keys/ids that were published. Success could only be seen with a delay in the UI because the publish-endpoint is async
     */
    static async validate(keyArr) {
        // works only with objectId
        const executedKeyArr = [];
        const metadataMap = await this.retrieveForCache();

        for (let key of keyArr) {
            let objectId;
            let version;
            let journey;
            if (!key) {
                continue;
            }
            if (key.startsWith('%23')) {
                // if the key started with %23 assume an ID was copied from the URL but the user forgot to prefix it with id:
                // correct the format
                key = 'id:' + key.slice(3);
            }
            if (key.startsWith('id:')) {
                // ! allow selecting journeys by ID because that's what users see in the URL
                // remove id
                objectId = key.slice(3);
                if (objectId.startsWith('%23')) {
                    // in the journey URL the Id is prefixed with an HTML-encoded "#" which could accidentally be copied by users
                    // despite the slicing above, this still needs testing here because users might have prefixed the ID with id: but did not know to remove the #23
                    objectId = objectId.slice(3);
                    // correct the format to ensure we show sth readable in the "Downloaded" log
                    // objectId =  objectId;
                    // update this here to show it in the log
                    key = 'id:' + objectId;
                }
                if (objectId.includes('/')) {
                    version = objectId.split('/')[1];
                    // in the journey URL the version is appended after the ID, separated by a forward-slash. Needs to be removed from the ID for caching as we always aim to retrieve the latest version only
                    objectId = objectId.split('/')[0];
                } else {
                    // if we didn't find a version we need to cache this from the API after all
                    if (key.includes('/')) {
                        // in the journey URL the version is appended after the ID, separated by a forward-slash. Needs to be removed from the key for caching as we always aim to retrieve the latest version only
                        key = key.split('/')[0];
                    }
                }
                journey = Object.values(metadataMap.metadata).find((el) => el.id === objectId);
                if (!journey) {
                    Util.logger.info(
                        ` ☇ skipping ${this.definition.type} ${key}: not found on server (1)`
                    );
                    continue;
                }
            } else {
                // key assumed
                journey = metadataMap.metadata[key];
            }

            if (!journey) {
                Util.logger.info(
                    ` ☇ skipping ${this.definition.type} ${key}: not found on server (2)`
                );
                continue;
            }
            if (!version) {
                version = journey.version;
            }
            if (journey.status === 'Published') {
                // api would return error code 30000 and ask to open a support case when in fact we simply already have a transactionalEmail created based on this status
                Util.logger.error(
                    ` ☇ skipping ${this.definition.type} ${
                        journey[this.definition.nameField]
                    } (${journey[this.definition.keyField]}): already published`
                );
                continue;
            }

            switch (journey.definitionType) {
                case 'Multistep': {
                    // SF Event, Api Event Journeys
                    // ! for SF-triggered journeys this cannot be asynchronous or it will cause a race-condition (see #1627 for details); the requests are accepted but then processed sequentually anyways, eliminating potential speed gains.
                    // It is unknown if the same would happen for API-event journeys but given that it's the same endpoint, lets not risk it and run this sequentially
                    let statusUrl;
                    try {
                        const response = await this.client.rest.post(
                            `/interaction/v1/interactions/validateAsync/${journey.id}?versionNumber=${version}`,
                            {}
                        ); // payload is empty for this request
                        if (response.statusUrl && response.statusId) {
                            Util.logger.info(
                                ` - ${this.definition.type} queued for validating: ${journey[this.definition.keyField]}/${version} / ${journey[this.definition.nameField]}`
                            );
                            statusUrl = response.statusUrl;
                        } else {
                            throw new Error(response);
                        }
                        const spinner = yoctoSpinner({
                            text: `Validating journey…`,
                        }).start();

                        await Util.sleep(1000);
                        executedKeyArr.push(
                            await this._checkPublishStatus(
                                statusUrl,
                                journey[this.definition.keyField],
                                journey[this.definition.nameField],
                                spinner
                            )
                        );
                    } catch (ex) {
                        switch (ex.message) {
                            case 'Cannot validate interaction in Published status.': {
                                Util.logger.info(
                                    ` - ${this.definition.type} ${key}/${version} is already published. Can only validate Draft Journeys`
                                );

                                break;
                            }
                            case 'Cannot validate interaction in Stopped status.': {
                                Util.logger.warn(
                                    ` - ${this.definition.type} ${key}/${version} is stopped. Can only validate Draft Journeys.`
                                );

                                break;
                            }
                            case 'Cannot validate interaction in Paused status.': {
                                Util.logger.warn(
                                    ` - ${this.definition.type} ${key}/${version} is already published but currently paused. Can only validate Draft Journeys.`
                                );

                                break;
                            }
                            default: {
                                Util.logger.error(
                                    `Failed to validate ${this.definition.type} ${key}: ${ex.message}`
                                );
                            }
                        }
                    }
                    break;
                }
                default: {
                    throw new Error(
                        `${this.definition.type} type ${journey.definitionType} not supported yet by validate method`
                    );
                }
            }
        } // for loop

        Util.logger.info(
            `Validated ${executedKeyArr.filter(Boolean).length} of ${keyArr.length} items without errors`
        );
        return executedKeyArr.filter(Boolean);
    }

    /**
     * stops latest journey version
     *
     * @param {string[]} keyArr customerkey of the metadata
     * @returns {Promise.<string[]>} Returns list of keys that were paused
     */
    static async stop(keyArr) {
        let version;
        const endpoint = '/interaction/v1/interactions/stop/';
        const stoppedKeyArr = [];
        const pauseTransactionalKeyArr = [];
        const apiLimit = pLimit(20);
        const journeyCache = await this.retrieveForCache();

        const stoppableJourneyStatus = ['Paused', 'Published', 'Finishing'];

        await Promise.allSettled(
            keyArr.map((key) =>
                apiLimit(async () => {
                    [key, version] = key.split('/');
                    if (journeyCache.metadata[key]) {
                        switch (journeyCache.metadata[key].definitionType) {
                            case 'Transactional': {
                                // transactional send journeys cannot be "stopped" but only "paused"
                                pauseTransactionalKeyArr.push(key);
                                break;
                            }
                            case 'Multistep': {
                                const toBeStoppedVersions = [];
                                if (version === '*') {
                                    const responseAllVersions = await this.client.rest.getBulk(
                                        '/interaction/v1/interactions/?id=' +
                                            journeyCache.metadata[key].id +
                                            '&mostRecentVersionOnly=false',
                                        this.definition.restPageSize || 500
                                    );
                                    if (responseAllVersions?.items?.length) {
                                        // find all active versions
                                        const allActiveVersions = responseAllVersions.items
                                            .filter((item) =>
                                                stoppableJourneyStatus.includes(item.status)
                                            )
                                            .map((item) => item.version);
                                        if (allActiveVersions.length) {
                                            toBeStoppedVersions.push(...allActiveVersions);
                                        }
                                    }
                                    if (!toBeStoppedVersions.length) {
                                        Util.logger.warn(
                                            ` ☇ skipping stop of ${this.definition.type} ${key}: no active versions found`
                                        );
                                    }
                                } else {
                                    if (!version) {
                                        version = journeyCache.metadata[key].version;
                                        Util.logger.info(
                                            Util.getGrayMsg(
                                                ` - ${this.definition.type} ${key}: no version provided. Will try to stop latest version: Version ${version}. To stop all versions, append /* after the key.`
                                            )
                                        );
                                        if (
                                            !stoppableJourneyStatus.includes(
                                                journeyCache.metadata[key].status
                                            )
                                        ) {
                                            Util.logger.warn(
                                                ` ☇ skipping stop of ${this.definition.type} ${key}: version ${version} has status "${journeyCache.metadata[key].status}" which cannot be stopped. To stop all versions, append /* after the key.`
                                            );
                                        }
                                    }
                                    toBeStoppedVersions.push(version);
                                }
                                const rateLimitActivities = pLimit(2);
                                const stoppedVersions = (
                                    await Promise.all(
                                        toBeStoppedVersions.map((version) =>
                                            rateLimitActivities(async () => {
                                                try {
                                                    await this.client.rest.post(
                                                        endpoint +
                                                            journeyCache.metadata[key].id +
                                                            `?versionNumber=${version}`,
                                                        {}
                                                    );
                                                    Util.logger.info(
                                                        ` - Stopped ${this.definition.type} ${key} / ${journeyCache.metadata[key].name} - Version ${version}`
                                                    );
                                                    return version;
                                                } catch (ex) {
                                                    Util.logger.error(
                                                        ` - Stopping ${this.definition.type} ${key} / ${journeyCache.metadata[key].name} - Version ${version} failed: ${ex.message}`
                                                    );
                                                    return;
                                                }
                                            })
                                        )
                                    )
                                ).filter(Boolean);
                                if (stoppedVersions.length === toBeStoppedVersions.length) {
                                    stoppedKeyArr.push(key);
                                }

                                break;
                            }
                            default: {
                                Util.logger.error(
                                    ` - Stopping ${this.definition.type} ${key} / ${journeyCache.metadata[key].name} failed: Unsupported definitionType '${journeyCache.metadata[key].definitionType}'`
                                );
                            }
                        }
                    } else {
                        Util.logger.error(
                            ` ☇ skipping stop of ${this.definition.type} ${key}: not found on server`
                        );
                    }
                })
            )
        );
        stoppedKeyArr.push(...(await this.pause(pauseTransactionalKeyArr)));

        return stoppedKeyArr;
    }

    /**
     * pauses selected journey versions
     *
     * @param {string[]} keyArr customerkey of the metadata
     * @param {MetadataTypeMapObj} [journeyCache] metadata cache used by refresh to avoid recaching
     * @returns {Promise.<string[]>} Returns list of keys that were paused
     */
    static async pause(keyArr, journeyCache) {
        let version;
        const pausedKeyArr = [];
        const apiLimit = pLimit(20);
        journeyCache ||= await this.retrieveForCache();

        await Promise.allSettled(
            keyArr.map((key) =>
                apiLimit(async () => {
                    [key, version] = key.split('/');
                    if (journeyCache.metadata[key]) {
                        if (journeyCache.metadata[key].status !== 'Published') {
                            Util.logger.error(
                                ` - Pausing ${this.definition.type} ${key} / ${journeyCache.metadata[key].name} failed: Cannot pause a journey in status ${journeyCache.metadata[key].status}`
                            );
                            return;
                        }
                        switch (journeyCache.metadata[key].definitionType) {
                            case 'Transactional': {
                                try {
                                    const response = await this.client.rest.post(
                                        '/interaction/v1/interactions/transactional/pause',
                                        { definitionId: journeyCache.metadata[key].id }
                                    );
                                    if (response.errors?.length) {
                                        throw new Error(JSON.stringify(response));
                                    } else {
                                        Util.logger.info(
                                            ` - 🛑 paused ${this.definition.type} ${key} / ${journeyCache.metadata[key].name}`
                                        );
                                        pausedKeyArr.push(key);
                                    }
                                } catch (ex) {
                                    Util.logger.error(
                                        ` - Pausing ${this.definition.type} ${key} / ${journeyCache.metadata[key].name} failed: ${ex.message}`
                                    );
                                }
                                break;
                            }
                            case 'Multistep': {
                                version ||= journeyCache.metadata[key].version;
                                try {
                                    await this.client.rest.post(
                                        '/interaction/v1/interactions/pause/' +
                                            journeyCache.metadata[key].id +
                                            (version === '*'
                                                ? '?allVersions=true'
                                                : `?versionNumber=${version}`),
                                        {}
                                    );
                                    Util.logger.info(
                                        ` -- 🛑 paused ${this.definition.type} ${key}/${version} / ${journeyCache.metadata[key].name}`
                                    );
                                    pausedKeyArr.push(key);
                                } catch (ex) {
                                    Util.logger.error(
                                        ` - Pausing ${this.definition.type} ${key} / ${journeyCache.metadata[key].name} failed: ${ex.message}`
                                    );
                                }
                                break;
                            }
                            default: {
                                Util.logger.error(
                                    ` - Pausing ${this.definition.type} ${key} / ${journeyCache.metadata[key].name} failed: Unsupported definitionType '${journeyCache.metadata[key].definitionType}'`
                                );
                            }
                        }
                    } else {
                        Util.logger.error(
                            ` ☇ skipping pause of ${this.definition.type} ${key}: not found on server`
                        );
                    }
                })
            )
        );

        return pausedKeyArr;
    }
    /**
     * resumes selected journey versions
     *
     * @param {string[]} keyArr customerkey of the metadata
     * @param {MetadataTypeMapObj} [journeyCache] metadata cache used by refresh to avoid recaching
     * @returns {Promise.<string[]>} Returns list of keys that were resumed
     */
    static async execute(keyArr, journeyCache) {
        let version;
        const endpoint = '/interaction/v1/interactions/resume/';
        const resumedKeyArr = [];
        const apiLimit = pLimit(20);
        journeyCache ||= await this.retrieveForCache();

        await Promise.allSettled(
            keyArr.map((key) =>
                apiLimit(async () => {
                    [key, version] = key.split('/');
                    if (journeyCache.metadata[key]) {
                        if (journeyCache.metadata[key].status !== 'Paused') {
                            Util.logger.error(
                                ` - Resuming ${this.definition.type} ${key} / ${journeyCache.metadata[key].name} failed: Cannot pause a journey in status ${journeyCache.metadata[key].status}`
                            );
                            return;
                        }
                        switch (journeyCache.metadata[key].definitionType) {
                            case 'Transactional': {
                                try {
                                    const response = await this.client.rest.post(
                                        '/interaction/v1/interactions/transactional/resume',
                                        { definitionId: journeyCache.metadata[key].id }
                                    );
                                    if (response.errors?.length) {
                                        throw new Error(JSON.stringify(response));
                                    } else {
                                        Util.logger.info(
                                            ` - ✅ resumed ${this.definition.type} ${key} / ${journeyCache.metadata[key].name}`
                                        );
                                        resumedKeyArr.push(key);
                                    }
                                } catch (ex) {
                                    Util.logger.error(
                                        ` - Resuming ${this.definition.type} ${key} / ${journeyCache.metadata[key].name} failed: ${ex.message}`
                                    );
                                }
                                break;
                            }
                            case 'Multistep': {
                                version ||= journeyCache.metadata[key].version;
                                try {
                                    await this.client.rest.post(
                                        endpoint +
                                            journeyCache.metadata[key].id +
                                            (version === '*'
                                                ? '?allVersions=true'
                                                : `?versionNumber=${version}`),
                                        {}
                                    );
                                    Util.logger.info(
                                        ` - ✅ resumed ${this.definition.type} ${key}/${version}`
                                    );
                                    resumedKeyArr.push(key);
                                } catch (ex) {
                                    Util.logger.error(
                                        ` - Resuming ${this.definition.type} ${key} / ${journeyCache.metadata[key].name} failed: ${ex.message}`
                                    );
                                }
                                break;
                            }
                            default: {
                                Util.logger.error(
                                    ` - Resuming ${this.definition.type} ${key} / ${journeyCache.metadata[key].name} failed: Unsupported definitionType '${journeyCache.metadata[key].definitionType}'`
                                );
                            }
                        }
                    } else {
                        Util.logger.error(
                            ` ☇ skipping resume of ${this.definition.type} ${key}: not found on server`
                        );
                    }
                })
            )
        );

        return resumedKeyArr;
    }

    /**
     * TSD-specific refresh method that finds active TSDs and refreshes them
     *
     * @param {string[]} keyArr metadata keys
     * @returns {Promise.<string[]>} Returns list of keys that were refreshed
     */
    static async refresh(keyArr) {
        console.time('Time'); // eslint-disable-line no-console
        if (!Array.isArray(keyArr) || !keyArr.length) {
            Util.logger.error('No refresh-keys provided');
            return [];
            // keyArr = await this.getKeysForValidTSDs((await this.findRefreshableItems()).metadata);
            // checkKey = false;
        }
        const journeyCache = await this.retrieveForCache();
        // then executes pause, publish, start on them.
        Util.logger.info(`Refreshing ${keyArr.length} ${this.definition.typeName}...`);
        Util.logger.debug(`Refreshing keys: ${keyArr.join(', ')}`);
        const refreshedKeyArr = [];
        const tsKeys = [];
        const rateLimit = pLimit(10);
        const transactionalJourneyKeys = [];
        await Promise.all(
            keyArr.map((key) =>
                rateLimit(async () => {
                    if (!journeyCache.metadata[key]) {
                        Util.logger.error(
                            ` ☇ skipping refresh of ${this.definition.type} ${key}: not found on server`
                        );
                        return;
                    }
                    switch (journeyCache.metadata[key].definitionType) {
                        case 'Transactional': {
                            if (journeyCache.metadata[key]?.status === 'Published') {
                                const result = await this._refreshItem(key, journeyCache);
                                if (result) {
                                    refreshedKeyArr.push(key);
                                    transactionalJourneyKeys.push(key);
                                }
                            } else {
                                Util.logger.error(
                                    ` ☇ skipping refresh of ${this.definition.type} ${key}: Can only refresh journeys with status 'Published'. Found status: ${journeyCache.metadata[key]?.status}`
                                );
                            }
                            break;
                        }
                        case 'Multistep': {
                            // find all published & paused versions
                            const responseAllVersions = await this.client.rest.getBulk(
                                '/interaction/v1/interactions/?id=' +
                                    journeyCache.metadata[key].id +
                                    '&mostRecentVersionOnly=false',
                                this.definition.restPageSize || 500
                            );
                            if (responseAllVersions?.items?.length) {
                                const allActiveVersions = responseAllVersions.items
                                    .filter(
                                        (item) =>
                                            item.status === 'Paused' || item.status === 'Published'
                                    )
                                    .map((item) => item.version);
                                if (allActiveVersions.length) {
                                    Util.logger.info(
                                        Util.getGrayMsg(
                                            ` - journey ${key} / ${journeyCache.metadata[key].name} Paused/Published version numbers: ` +
                                                allActiveVersions.join(', ')
                                        )
                                    );
                                    // get TS keys from email activities of paused/published versions
                                    const rateLimitActivities = pLimit(2);
                                    tsKeys.push(
                                        ...(
                                            await Promise.all(
                                                allActiveVersions.map((version) =>
                                                    rateLimitActivities(async () => {
                                                        const journey = await this.client.rest.get(
                                                            '/interaction/v1/interactions/' +
                                                                journeyCache.metadata[key]?.id +
                                                                '?extras=activities&versionNumber=' +
                                                                version
                                                        );
                                                        // return all triggeredSends
                                                        // ! if somebody changed the key of the triggeredSend then the journey would have wrong info in triggeredSendKey. There is the alternative field triggeredSendId but that would be too costly to use here because we would need to retrieve all TSs to find the correct one. Also, changing TS keys is not a common practice.
                                                        return journey.activities
                                                            .filter(
                                                                (activity) =>
                                                                    activity.type === 'EMAILV2' &&
                                                                    activity.configurationArguments
                                                                        ?.triggeredSendKey
                                                            )
                                                            .map(
                                                                (activity) =>
                                                                    activity.configurationArguments
                                                                        ?.triggeredSendKey
                                                            );
                                                    })
                                                )
                                            )
                                        ).flat()
                                    );

                                    refreshedKeyArr.push(key);
                                } else {
                                    Util.logger.error(
                                        ` ☇ skipping refresh of ${this.definition.type} ${key}: no published/paused versions found`
                                    );
                                }
                            }
                            break;
                        }
                        default: {
                            Util.logger.error(
                                ` - Refreshing ${this.definition.type} ${key} / ${journeyCache.metadata[key].name} failed: Unsupported definitionType '${journeyCache.metadata[key].definitionType}'`
                            );
                        }
                    }
                })
            )
        );

        if (tsKeys.length) {
            // refresh TriggeredSends
            TriggeredSend.buObject = this.buObject;
            TriggeredSend.client = this.client;
            TriggeredSend.properties = this.properties;
            // hard-refresh all triggeredSends even if the TS was paused (inactive) before
            await TriggeredSend.refresh(tsKeys, false);
        } else {
            Util.logger.info(Util.getGrayMsg('No triggeredSends found to refresh'));
        }

        // reload refreshed transactional journeys including their transactionalEmails
        if (transactionalJourneyKeys.length) {
            // reset transactionalEmail cache to trigger re-caching it.
            cache.clearCache(this.buObject.mid, 'transactionalEmail');

            await this._reRetrieve(transactionalJourneyKeys, transactionalJourneyKeys.length, 0);
        }

        Util.logger.info(
            `Refreshed ${refreshedKeyArr.length} of ${keyArr.length} ${this.definition.type}`
        );
        console.timeEnd('Time'); // eslint-disable-line no-console
        return refreshedKeyArr;
    }
    /**
     * helper for {@link Journey.refresh} that pauses, publishes and starts a triggered send
     *
     * @param {string} key external key of triggered send item
     * @param {MetadataTypeMapObj} journeyCache metadata cache
     * @returns {Promise.<boolean>} true if refresh was successful
     */
    static async _refreshItem(key, journeyCache) {
        // pause
        const pausedKeys = await this.pause([key], journeyCache);
        if (!pausedKeys?.length || pausedKeys[0] !== key) {
            Util.logger.error(` - failed to pause ${this.definition.typeName}: ${key}`);
            return false;
        }

        // update cache or else resume (execute) will fail
        journeyCache.metadata[key].status = 'Paused';

        // resume
        const resumedKeys = await this.execute([key], journeyCache);
        if (!resumedKeys?.length || resumedKeys[0] !== key) {
            Util.logger.error(` - failed to resume ${this.definition.typeName}: ${key}`);
            return false;
        }

        return true;
    }
}

// Assign definition to static attributes
import MetadataTypeDefinitions from '../MetadataTypeDefinitions.js';
Journey.definition = MetadataTypeDefinitions.journey;

export default Journey;
